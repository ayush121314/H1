/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: function() { return /* binding */ BISHOP; },\n/* harmony export */   BLACK: function() { return /* binding */ BLACK; },\n/* harmony export */   Chess: function() { return /* binding */ Chess; },\n/* harmony export */   DEFAULT_POSITION: function() { return /* binding */ DEFAULT_POSITION; },\n/* harmony export */   KING: function() { return /* binding */ KING; },\n/* harmony export */   KNIGHT: function() { return /* binding */ KNIGHT; },\n/* harmony export */   Move: function() { return /* binding */ Move; },\n/* harmony export */   PAWN: function() { return /* binding */ PAWN; },\n/* harmony export */   QUEEN: function() { return /* binding */ QUEEN; },\n/* harmony export */   ROOK: function() { return /* binding */ ROOK; },\n/* harmony export */   SQUARES: function() { return /* binding */ SQUARES; },\n/* harmony export */   WHITE: function() { return /* binding */ WHITE; },\n/* harmony export */   validateFen: function() { return /* binding */ validateFen; }\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcz8zMmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyNSwgSmVmZiBIbHl3YSAoamhseXdhQGdtYWlsLmNvbSlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5leHBvcnQgY29uc3QgV0hJVEUgPSAndyc7XG5leHBvcnQgY29uc3QgQkxBQ0sgPSAnYic7XG5leHBvcnQgY29uc3QgUEFXTiA9ICdwJztcbmV4cG9ydCBjb25zdCBLTklHSFQgPSAnbic7XG5leHBvcnQgY29uc3QgQklTSE9QID0gJ2InO1xuZXhwb3J0IGNvbnN0IFJPT0sgPSAncic7XG5leHBvcnQgY29uc3QgUVVFRU4gPSAncSc7XG5leHBvcnQgY29uc3QgS0lORyA9ICdrJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPU0lUSU9OID0gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxJztcbmV4cG9ydCBjbGFzcyBNb3ZlIHtcbiAgICBjb2xvcjtcbiAgICBmcm9tO1xuICAgIHRvO1xuICAgIHBpZWNlO1xuICAgIGNhcHR1cmVkO1xuICAgIHByb21vdGlvbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4wLlxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcbiAgICAgKiBgaXNFblBhc3NhbnRgLCBgaXNLaW5nc2lkZUNhc3RsZWAsIGBpc1F1ZWVuc2lkZUNhc3RsZWAsIGBpc0Nhc3RsZWAsIGFuZFxuICAgICAqIGBpc0JpZ1Bhd25gXG4gICAgICovXG4gICAgZmxhZ3M7XG4gICAgc2FuO1xuICAgIGxhbjtcbiAgICBiZWZvcmU7XG4gICAgYWZ0ZXI7XG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IGludGVybmFsO1xuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5waWVjZSA9IHBpZWNlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xuICAgICAgICB0aGlzLnRvID0gdG9BbGdlYnJhaWM7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogQ2hlc3MgY2xhc3MgdG8gZ2VuZXJhdGUgU0FOIGFuZCBGRU4uIEl0J3MgYSBiaXQgb2YgYSBoYWNrLCBidXQgbWFrZXMgdGhlXG4gICAgICAgICAqIGNvZGUgY2xlYW5lciBlbHNld2hlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhbiA9IGNoZXNzWydfbW92ZVRvU2FuJ10oaW50ZXJuYWwsIGNoZXNzWydfbW92ZXMnXSh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sYW4gPSBmcm9tQWxnZWJyYWljICsgdG9BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBGRU4gZm9yIHRoZSAnYWZ0ZXInIGtleVxuICAgICAgICBjaGVzc1snX21ha2VNb3ZlJ10oaW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIGNoZXNzWydfdW5kb01vdmUnXSgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW92ZSBmbGFnc1xuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBCSVRTKSB7XG4gICAgICAgICAgICBpZiAoQklUU1tmbGFnXSAmIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWQgPSBjYXB0dXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGlvbiA9IHByb21vdGlvbjtcbiAgICAgICAgICAgIHRoaXMubGFuICs9IHByb21vdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NhcHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNQcm9tb3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xuICAgIH1cbiAgICBpc0VuUGFzc2FudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0tpbmdzaWRlQ2FzdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNRdWVlbnNpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0JpZ1Bhd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XG4gICAgfVxufVxuY29uc3QgRU1QVFkgPSAtMTtcbmNvbnN0IEZMQUdTID0ge1xuICAgIE5PUk1BTDogJ24nLFxuICAgIENBUFRVUkU6ICdjJyxcbiAgICBCSUdfUEFXTjogJ2InLFxuICAgIEVQX0NBUFRVUkU6ICdlJyxcbiAgICBQUk9NT1RJT046ICdwJyxcbiAgICBLU0lERV9DQVNUTEU6ICdrJyxcbiAgICBRU0lERV9DQVNUTEU6ICdxJyxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBTUVVBUkVTID0gW1xuICAgICdhOCcsICdiOCcsICdjOCcsICdkOCcsICdlOCcsICdmOCcsICdnOCcsICdoOCcsXG4gICAgJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3JyxcbiAgICAnYTYnLCAnYjYnLCAnYzYnLCAnZDYnLCAnZTYnLCAnZjYnLCAnZzYnLCAnaDYnLFxuICAgICdhNScsICdiNScsICdjNScsICdkNScsICdlNScsICdmNScsICdnNScsICdoNScsXG4gICAgJ2E0JywgJ2I0JywgJ2M0JywgJ2Q0JywgJ2U0JywgJ2Y0JywgJ2c0JywgJ2g0JyxcbiAgICAnYTMnLCAnYjMnLCAnYzMnLCAnZDMnLCAnZTMnLCAnZjMnLCAnZzMnLCAnaDMnLFxuICAgICdhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMicsXG4gICAgJ2ExJywgJ2IxJywgJ2MxJywgJ2QxJywgJ2UxJywgJ2YxJywgJ2cxJywgJ2gxJ1xuXTtcbmNvbnN0IEJJVFMgPSB7XG4gICAgTk9STUFMOiAxLFxuICAgIENBUFRVUkU6IDIsXG4gICAgQklHX1BBV046IDQsXG4gICAgRVBfQ0FQVFVSRTogOCxcbiAgICBQUk9NT1RJT046IDE2LFxuICAgIEtTSURFX0NBU1RMRTogMzIsXG4gICAgUVNJREVfQ0FTVExFOiA2NCxcbn07XG4vKlxuICogTk9URVMgQUJPVVQgMHg4OCBNT1ZFIEdFTkVSQVRJT04gQUxHT1JJVEhNXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGx5d2EvY2hlc3MuanMvaXNzdWVzLzIzMFxuICpcbiAqIEEgbG90IG9mIHBlb3BsZSBhcmUgY29uZnVzZWQgd2hlbiB0aGV5IGZpcnN0IHNlZSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAqIG9mIGNoZXNzLmpzLiBJdCB1c2VzIHRoZSAweDg4IE1vdmUgR2VuZXJhdGlvbiBBbGdvcml0aG0gd2hpY2ggaW50ZXJuYWxseVxuICogc3RvcmVzIHRoZSBib2FyZCBhcyBhbiA4eDE2IGFycmF5LiBUaGlzIGlzIHB1cmVseSBmb3IgZWZmaWNpZW5jeSBidXQgaGFzIGFcbiAqIGNvdXBsZSBvZiBpbnRlcmVzdGluZyBiZW5lZml0czpcbiAqXG4gKiAxLiAweDg4IG9mZmVycyBhIHZlcnkgaW5leHBlbnNpdmUgXCJvZmYgdGhlIGJvYXJkXCIgY2hlY2suIEJpdHdpc2UgQU5EICgmKSBhbnlcbiAqICAgIHNxdWFyZSB3aXRoIDB4ODgsIGlmIHRoZSByZXN1bHQgaXMgbm9uLXplcm8gdGhlbiB0aGUgc3F1YXJlIGlzIG9mZiB0aGVcbiAqICAgIGJvYXJkLiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSBrbmlnaHQgc3F1YXJlIEE4ICgwIGluIDB4ODggbm90YXRpb24pLFxuICogICAgdGhlcmUgYXJlIDggcG9zc2libGUgZGlyZWN0aW9ucyBpbiB3aGljaCB0aGUga25pZ2h0IGNhbiBtb3ZlLiBUaGVzZVxuICogICAgZGlyZWN0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhlIDh4MTYgYm9hcmQgYW5kIGFyZSBzdG9yZWQgaW4gdGhlXG4gKiAgICBQSUVDRV9PRkZTRVRTIG1hcC4gT25lIHBvc3NpYmxlIG1vdmUgaXMgQTggLSAxOCAodXAgb25lIHNxdWFyZSwgYW5kIHR3b1xuICogICAgc3F1YXJlcyB0byB0aGUgbGVmdCAtIHdoaWNoIGlzIG9mZiB0aGUgYm9hcmQpLiAwIC0gMTggPSAtMTggJiAweDg4ID0gMHg4OFxuICogICAgKGJlY2F1c2Ugb2YgdHdvLWNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gb2YgLTE4KS4gVGhlIG5vbi16ZXJvIHJlc3VsdFxuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvZmYgdGhlIGJvYXJkIGFuZCB0aGUgbW92ZSBpcyBpbGxlZ2FsLiBUYWtlIHRoZVxuICogICAgb3Bwb3NpdGUgbW92ZSAoZnJvbSBBOCB0byBDNyksIDAgKyAxOCA9IDE4ICYgMHg4OCA9IDAuIEEgcmVzdWx0IG9mIHplcm9cbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb24gdGhlIGJvYXJkLlxuICpcbiAqIDIuIFRoZSByZWxhdGl2ZSBkaXN0YW5jZSAob3IgZGlmZmVyZW5jZSkgYmV0d2VlbiB0d28gc3F1YXJlcyBvbiBhIDh4MTYgYm9hcmRcbiAqICAgIGlzIHVuaXF1ZSBhbmQgY2FuIGJlIHVzZWQgdG8gaW5leHBlbnNpdmVseSBkZXRlcm1pbmUgaWYgYSBwaWVjZSBvbiBhXG4gKiAgICBzcXVhcmUgY2FuIGF0dGFjayBhbnkgb3RoZXIgYXJiaXRyYXJ5IHNxdWFyZS4gRm9yIGV4YW1wbGUsIGxldCdzIHNlZSBpZiBhXG4gKiAgICBwYXduIG9uIEU3IGNhbiBhdHRhY2sgRTIuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gRTcgKDIwKSAtIEUyICgxMDApIGlzXG4gKiAgICAtODAuIFdlIGFkZCAxMTkgdG8gbWFrZSB0aGUgQVRUQUNLUyBhcnJheSBpbmRleCBub24tbmVnYXRpdmUgKGJlY2F1c2UgdGhlXG4gKiAgICB3b3JzdCBjYXNlIGRpZmZlcmVuY2UgaXMgQTggLSBIMSA9IC0xMTkpLiBUaGUgQVRUQUNLUyBhcnJheSBjb250YWlucyBhXG4gKiAgICBiaXRtYXNrIG9mIHBpZWNlcyB0aGF0IGNhbiBhdHRhY2sgZnJvbSB0aGF0IGRpc3RhbmNlIGFuZCBkaXJlY3Rpb24uXG4gKiAgICBBVFRBQ0tTWy04MCArIDExOT0zOV0gZ2l2ZXMgdXMgMjQgb3IgMGIxMTAwMCBpbiBiaW5hcnkuIExvb2sgYXQgdGhlXG4gKiAgICBQSUVDRV9NQVNLUyBtYXAgdG8gZGV0ZXJtaW5lIHRoZSBtYXNrIGZvciBhIGdpdmVuIHBpZWNlIHR5cGUuIEluIG91ciBwYXduXG4gKiAgICBleGFtcGxlLCB3ZSB3b3VsZCBjaGVjayB0byBzZWUgaWYgMjQgJiAweDEgaXMgbm9uLXplcm8sIHdoaWNoIGl0IGlzXG4gKiAgICBub3QuIFNvLCBuYXR1cmFsbHksIGEgcGF3biBvbiBFNyBjYW4ndCBhdHRhY2sgYSBwaWVjZSBvbiBFMi4gSG93ZXZlciwgYVxuICogICAgcm9vayBjYW4gc2luY2UgMjQgJiAweDggaXMgbm9uLXplcm8uIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gY2hlY2sgaXMgdGhhdFxuICogICAgdGhlcmUgYXJlIG5vIGJsb2NraW5nIHBpZWNlcyBiZXR3ZWVuIEU3IGFuZCBFMi4gVGhhdCdzIHdoZXJlIHRoZSBSQVlTXG4gKiAgICBhcnJheSBjb21lcyBpbi4gSXQgcHJvdmlkZXMgYW4gb2Zmc2V0IChpbiB0aGlzIGNhc2UgMTYpIHRvIGFkZCB0byBFNyAoMjApXG4gKiAgICB0byBjaGVjayBmb3IgYmxvY2tpbmcgcGllY2VzLiBFNyAoMjApICsgMTYgPSBFNiAoMzYpICsgMTYgPSBFNSAoNTIpIGV0Yy5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IE94ODggPSB7XG4gICAgYTg6IDAsIGI4OiAxLCBjODogMiwgZDg6IDMsIGU4OiA0LCBmODogNSwgZzg6IDYsIGg4OiA3LFxuICAgIGE3OiAxNiwgYjc6IDE3LCBjNzogMTgsIGQ3OiAxOSwgZTc6IDIwLCBmNzogMjEsIGc3OiAyMiwgaDc6IDIzLFxuICAgIGE2OiAzMiwgYjY6IDMzLCBjNjogMzQsIGQ2OiAzNSwgZTY6IDM2LCBmNjogMzcsIGc2OiAzOCwgaDY6IDM5LFxuICAgIGE1OiA0OCwgYjU6IDQ5LCBjNTogNTAsIGQ1OiA1MSwgZTU6IDUyLCBmNTogNTMsIGc1OiA1NCwgaDU6IDU1LFxuICAgIGE0OiA2NCwgYjQ6IDY1LCBjNDogNjYsIGQ0OiA2NywgZTQ6IDY4LCBmNDogNjksIGc0OiA3MCwgaDQ6IDcxLFxuICAgIGEzOiA4MCwgYjM6IDgxLCBjMzogODIsIGQzOiA4MywgZTM6IDg0LCBmMzogODUsIGczOiA4NiwgaDM6IDg3LFxuICAgIGEyOiA5NiwgYjI6IDk3LCBjMjogOTgsIGQyOiA5OSwgZTI6IDEwMCwgZjI6IDEwMSwgZzI6IDEwMiwgaDI6IDEwMyxcbiAgICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XG59O1xuY29uc3QgUEFXTl9PRkZTRVRTID0ge1xuICAgIGI6IFsxNiwgMzIsIDE3LCAxNV0sXG4gICAgdzogWy0xNiwgLTMyLCAtMTcsIC0xNV0sXG59O1xuY29uc3QgUElFQ0VfT0ZGU0VUUyA9IHtcbiAgICBuOiBbLTE4LCAtMzMsIC0zMSwgLTE0LCAxOCwgMzMsIDMxLCAxNF0sXG4gICAgYjogWy0xNywgLTE1LCAxNywgMTVdLFxuICAgIHI6IFstMTYsIDEsIDE2LCAtMV0sXG4gICAgcTogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbiAgICBrOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQVRUQUNLUyA9IFtcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDU2LCAwLCA1NiwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBSQVlTID0gW1xuICAgIDE3LCAwLCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsXG4gICAgMCwgMTcsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAxNSwgMCwgMCxcbiAgICAwLCAwLCAxNywgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDE3LCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMTcsIDAsIDAsIDE2LCAwLCAwLCAxNSwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAxNywgMCwgMTYsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDE3LCAxNiwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgLTE1LCAtMTYsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAtMTUsIDAsIC0xNiwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIC0xNSwgMCwgMCwgLTE2LCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgLTE1LCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAtMTUsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLFxuICAgIDAsIC0xNSwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsXG4gICAgLTE1LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIDAsIC0xN1xuXTtcbmNvbnN0IFBJRUNFX01BU0tTID0geyBwOiAweDEsIG46IDB4MiwgYjogMHg0LCByOiAweDgsIHE6IDB4MTAsIGs6IDB4MjAgfTtcbmNvbnN0IFNZTUJPTFMgPSAncG5icnFrUE5CUlFLJztcbmNvbnN0IFBST01PVElPTlMgPSBbS05JR0hULCBCSVNIT1AsIFJPT0ssIFFVRUVOXTtcbmNvbnN0IFJBTktfMSA9IDc7XG5jb25zdCBSQU5LXzIgPSA2O1xuLypcbiAqIGNvbnN0IFJBTktfMyA9IDVcbiAqIGNvbnN0IFJBTktfNCA9IDRcbiAqIGNvbnN0IFJBTktfNSA9IDNcbiAqIGNvbnN0IFJBTktfNiA9IDJcbiAqL1xuY29uc3QgUkFOS183ID0gMTtcbmNvbnN0IFJBTktfOCA9IDA7XG5jb25zdCBTSURFUyA9IHtcbiAgICBbS0lOR106IEJJVFMuS1NJREVfQ0FTVExFLFxuICAgIFtRVUVFTl06IEJJVFMuUVNJREVfQ0FTVExFLFxufTtcbmNvbnN0IFJPT0tTID0ge1xuICAgIHc6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTEsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG4gICAgYjogW1xuICAgICAgICB7IHNxdWFyZTogT3g4OC5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgICAgeyBzcXVhcmU6IE94ODguaDgsIGZsYWc6IEJJVFMuS1NJREVfQ0FTVExFIH0sXG4gICAgXSxcbn07XG5jb25zdCBTRUNPTkRfUkFOSyA9IHsgYjogUkFOS183LCB3OiBSQU5LXzIgfTtcbmNvbnN0IFRFUk1JTkFUSU9OX01BUktFUlMgPSBbJzEtMCcsICcwLTEnLCAnMS8yLTEvMicsICcqJ107XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCByYW5rIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gcmFuayhzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlID4+IDQ7XG59XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCBmaWxlIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gZmlsZShzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlICYgMHhmO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjKSB7XG4gICAgcmV0dXJuICcwMTIzNDU2Nzg5Jy5pbmRleE9mKGMpICE9PSAtMTtcbn1cbi8vIENvbnZlcnRzIGEgMHg4OCBzcXVhcmUgdG8gYWxnZWJyYWljIG5vdGF0aW9uLlxuZnVuY3Rpb24gYWxnZWJyYWljKHNxdWFyZSkge1xuICAgIGNvbnN0IGYgPSBmaWxlKHNxdWFyZSk7XG4gICAgY29uc3QgciA9IHJhbmsoc3F1YXJlKTtcbiAgICByZXR1cm4gKCdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArXG4gICAgICAgICc4NzY1NDMyMScuc3Vic3RyaW5nKHIsIHIgKyAxKSk7XG59XG5mdW5jdGlvbiBzd2FwQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPT09IFdISVRFID8gQkxBQ0sgOiBXSElURTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZlbihmZW4pIHtcbiAgICAvLyAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/XG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG11c3QgY29udGFpbiBzaXggc3BhY2UtZGVsaW1pdGVkIGZpZWxkcycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/XG4gICAgY29uc3QgbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xuICAgIGNvbnN0IGhhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgIGlmIChpc05hTihoYWxmTW92ZXMpIHx8IGhhbGZNb3ZlcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IGhhbGYgbW92ZSBjb3VudGVyIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogZW4tcGFzc2FudCBzcXVhcmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cbiAgICBpZiAoL1tea0txUS1dLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBjYXN0bGluZyBhdmFpbGFiaWxpdHkgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNnRoIGNyaXRlcmlvbjogMm5kIGZpZWxkIGlzIFwid1wiICh3aGl0ZSkgb3IgXCJiXCIgKGJsYWNrKT9cbiAgICBpZiAoIS9eKHd8YikkLy50ZXN0KHRva2Vuc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gN3RoIGNyaXRlcmlvbjogMXN0IGZpZWxkIGNvbnRhaW5zIDggcm93cz9cbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvd3MubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXG4gICAgICAgIGxldCBzdW1GaWVsZHMgPSAwO1xuICAgICAgICBsZXQgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1dhc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChjb25zZWN1dGl2ZSBudW1iZXIpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IHBhcnNlSW50KHJvd3NbaV1ba10sIDEwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtRmllbGRzICE9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKHRvbyBtYW55IHNxdWFyZXMgaW4gcmFuayknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA5dGggY3JpdGVyaW9uOiBpcyBlbi1wYXNzYW50IHNxdWFyZSBsZWdhbD9cbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcbiAgICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJykpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBpbGxlZ2FsIGVuLXBhc3NhbnQgc3F1YXJlJyB9O1xuICAgIH1cbiAgICAvLyAxMHRoIGNyaXRlcmlvbjogZG9lcyBjaGVzcyBwb3NpdGlvbiBjb250YWluIGV4YWN0IHR3byBraW5ncz9cbiAgICBjb25zdCBraW5ncyA9IFtcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcbiAgICAgICAgeyBjb2xvcjogJ2JsYWNrJywgcmVnZXg6IC9rL2cgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodG9rZW5zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiBtaXNzaW5nICR7Y29sb3J9IGtpbmdgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b2tlbnNbMF0ubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IHRvbyBtYW55ICR7Y29sb3J9IGtpbmdzYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDExdGggY3JpdGVyaW9uOiBhcmUgYW55IHBhd25zIG9uIHRoZSBmaXJzdCBvciBlaWdodGggcm93cz9cbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcbmZ1bmN0aW9uIGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpIHtcbiAgICBjb25zdCBmcm9tID0gbW92ZS5mcm9tO1xuICAgIGNvbnN0IHRvID0gbW92ZS50bztcbiAgICBjb25zdCBwaWVjZSA9IG1vdmUucGllY2U7XG4gICAgbGV0IGFtYmlndWl0aWVzID0gMDtcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xuICAgIGxldCBzYW1lRmlsZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGNvbnN0IGFtYmlnVG8gPSBtb3Zlc1tpXS50bztcbiAgICAgICAgY29uc3QgYW1iaWdQaWVjZSA9IG1vdmVzW2ldLnBpZWNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGwgbmVlZFxuICAgICAgICAgKiB0byBhZGQgYSBkaXNhbWJpZ3VhdG9yIHRvIHRoZSBhbGdlYnJhaWMgbm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwaWVjZSA9PT0gYW1iaWdQaWVjZSAmJiBmcm9tICE9PSBhbWJpZ0Zyb20gJiYgdG8gPT09IGFtYmlnVG8pIHtcbiAgICAgICAgICAgIGFtYmlndWl0aWVzKys7XG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgc2FtZVJhbmsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRmlsZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbWJpZ3VpdGllcyA+IDApIHtcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXG4gICAgICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xuICAgIGNvbnN0IHIgPSByYW5rKHRvKTtcbiAgICBpZiAocGllY2UgPT09IFBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPTU9USU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvbW90aW9uID0gUFJPTU9USU9OU1tpXTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgcGllY2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IEJJVFMuUFJPTU9USU9OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgIGNhcHR1cmVkLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyUGllY2VUeXBlKHNhbikge1xuICAgIGxldCBwaWVjZVR5cGUgPSBzYW4uY2hhckF0KDApO1xuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNhbi5tYXRjaCgvW2EtaF1cXGQuKlthLWhdXFxkLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVdOO1xuICAgIH1cbiAgICBwaWVjZVR5cGUgPSBwaWVjZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcbiAgICAgICAgcmV0dXJuIEtJTkc7XG4gICAgfVxuICAgIHJldHVybiBwaWVjZVR5cGU7XG59XG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbmZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpO1xufVxuZnVuY3Rpb24gdHJpbUZlbihmZW4pIHtcbiAgICAvKlxuICAgICAqIHJlbW92ZSBsYXN0IHR3byBmaWVsZHMgaW4gRkVOIHN0cmluZyBhcyB0aGV5J3JlIG5vdCBuZWVkZWQgd2hlbiBjaGVja2luZ1xuICAgICAqIGZvciByZXBldGl0aW9uXG4gICAgICovXG4gICAgcmV0dXJuIGZlbi5zcGxpdCgnICcpLnNsaWNlKDAsIDQpLmpvaW4oJyAnKTtcbn1cbmV4cG9ydCBjbGFzcyBDaGVzcyB7XG4gICAgX2JvYXJkID0gbmV3IEFycmF5KDEyOCk7XG4gICAgX3R1cm4gPSBXSElURTtcbiAgICBfaGVhZGVyID0ge307XG4gICAgX2tpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfTtcbiAgICBfZXBTcXVhcmUgPSAtMTtcbiAgICBfaGFsZk1vdmVzID0gMDtcbiAgICBfbW92ZU51bWJlciA9IDA7XG4gICAgX2hpc3RvcnkgPSBbXTtcbiAgICBfY29tbWVudHMgPSB7fTtcbiAgICBfY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAvLyB0cmFja3MgbnVtYmVyIG9mIHRpbWVzIGEgcG9zaXRpb24gaGFzIGJlZW4gc2VlbiBmb3IgcmVwZXRpdGlvbiBjaGVja2luZ1xuICAgIF9wb3NpdGlvbkNvdW50ID0ge307XG4gICAgY29uc3RydWN0b3IoZmVuID0gREVGQVVMVF9QT1NJVElPTiwgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uIH0pO1xuICAgIH1cbiAgICBjbGVhcih7IHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgICAgIHRoaXMuX3R1cm4gPSBXSElURTtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gcHJlc2VydmVIZWFkZXJzID8gdGhpcy5faGVhZGVyIDoge307XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQgPSB7fTtcbiAgICAgICAgLypcbiAgICAgICAgICogRGVsZXRlIHRoZSBTZXRVcCBhbmQgRkVOIGhlYWRlcnMgKGlmIHByZXNlcnZlZCksIHRoZSBib2FyZCBpcyBlbXB0eSBhbmRcbiAgICAgICAgICogdGhlc2UgaGVhZGVycyBkb24ndCBtYWtlIHNlbnNlIGluIHRoaXMgc3RhdGUuIFRoZXknbGwgZ2V0IGFkZGVkIGxhdGVyXG4gICAgICAgICAqIHZpYSAubG9hZCgpIG9yIC5wdXQoKVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnU2V0VXAnXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgfVxuICAgIGxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uID0gZmFsc2UsIHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIC8vIGFwcGVuZCBjb21tb25seSBvbWl0dGVkIGZlbiB0b2tlbnNcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudHMgPSBbJy0nLCAnLScsICcwJywgJzEnXTtcbiAgICAgICAgICAgIGZlbiA9IHRva2Vucy5jb25jYXQoYWRqdXN0bWVudHMuc2xpY2UoLSg2IC0gdG9rZW5zLmxlbmd0aCkpKS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2ssIGVycm9yIH0gPSB2YWxpZGF0ZUZlbihmZW4pO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0b2tlbnNbMF07XG4gICAgICAgIGxldCBzcXVhcmUgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyKHsgcHJlc2VydmVIZWFkZXJzIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHBvc2l0aW9uLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChwaWVjZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RpZ2l0KHBpZWNlKSkge1xuICAgICAgICAgICAgICAgIHNxdWFyZSArPSBwYXJzZUludChwaWVjZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwaWVjZSA8ICdhJyA/IFdISVRFIDogQkxBQ0s7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHV0KHsgdHlwZTogcGllY2UudG9Mb3dlckNhc2UoKSwgY29sb3IgfSwgYWxnZWJyYWljKHNxdWFyZSkpO1xuICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R1cm4gPSB0b2tlbnNbMV07XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignSycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdRJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ2snKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZigncScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSB0b2tlbnNbM10gPT09ICctJyA/IEVNUFRZIDogT3g4OFt0b2tlbnNbM11dO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKTtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cChmZW4pO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KGZlbik7XG4gICAgfVxuICAgIGZlbigpIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gMDtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGU6IHBpZWNlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgICAgICBmZW4gKz0gY29sb3IgPT09IFdISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBPeDg4LmgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhc3RsaW5nID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ0snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ1EnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ2snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ3EnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gZW1wdHkgY2FzdGxpbmcgZmxhZz9cbiAgICAgICAgY2FzdGxpbmcgPSBjYXN0bGluZyB8fCAnLSc7XG4gICAgICAgIGxldCBlcFNxdWFyZSA9ICctJztcbiAgICAgICAgLypcbiAgICAgICAgICogb25seSBwcmludCB0aGUgZXAgc3F1YXJlIGlmIGVuIHBhc3NhbnQgaXMgYSB2YWxpZCBtb3ZlIChwYXduIGlzIHByZXNlbnRcbiAgICAgICAgICogYW5kIGVwIGNhcHR1cmUgaXMgbm90IHBpbm5lZClcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSAhPT0gRU1QVFkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ1Bhd25TcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IDE2IDogLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc3F1YXJlIG9mZiB0aGUgYm9hcmQ/XG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSBjb2xvciAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXduIG1ha2VzIGFuIGVwIGNhcHR1cmUsIGRvZXMgaXQgbGVhdmUgaXQncyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlOiBQQVdOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogQklUUy5FUF9DQVBUVVJFLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVwIGlzIGxlZ2FsLCBicmVhayBhbmQgc2V0IHRoZSBlcCBzcXVhcmUgaW4gdGhlIEZFTiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gYWxnZWJyYWljKHRoaXMuX2VwU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmZW4sXG4gICAgICAgICAgICB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmcsXG4gICAgICAgICAgICBlcFNxdWFyZSxcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIF0uam9pbignICcpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydTZXRVcCddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICB9XG4gICAgcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgcGllY2VcbiAgICAgICAgaWYgKFNZTUJPTFMuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzcXVhcmVcbiAgICAgICAgaWYgKCEoc3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3EgPSBPeDg4W3NxdWFyZV07XG4gICAgICAgIC8vIGRvbid0IGxldCB0aGUgdXNlciBwbGFjZSBtb3JlIHRoYW4gb25lIGtpbmdcbiAgICAgICAgaWYgKHR5cGUgPT0gS0lORyAmJlxuICAgICAgICAgICAgISh0aGlzLl9raW5nc1tjb2xvcl0gPT0gRU1QVFkgfHwgdGhpcy5fa2luZ3NbY29sb3JdID09IHNxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQaWVjZU9uU3F1YXJlID0gdGhpcy5fYm9hcmRbc3FdO1xuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIGtpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHBpZWNlIGZyb20gYXJncywgc2V0IHRoZSBgX2tpbmdzYCByZXNwZWN0aXZlIGVudHJ5IHRvIGBFTVBUWWBcbiAgICAgICAgaWYgKGN1cnJlbnRQaWVjZU9uU3F1YXJlICYmIGN1cnJlbnRQaWVjZU9uU3F1YXJlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2N1cnJlbnRQaWVjZU9uU3F1YXJlLmNvbG9yXSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvYXJkW3NxXSA9IHsgdHlwZTogdHlwZSwgY29sb3I6IGNvbG9yIH07XG4gICAgICAgIGlmICh0eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1tjb2xvcl0gPSBzcTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlKHNxdWFyZSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2V0KHNxdWFyZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtPeDg4W3NxdWFyZV1dO1xuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbcGllY2UuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgfVxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVLaW5nSW5QbGFjZSA9IHRoaXMuX2JvYXJkW094ODguZTFdPy50eXBlID09PSBLSU5HICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmUxXT8uY29sb3IgPT09IFdISVRFO1xuICAgICAgICBjb25zdCBibGFja0tpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lOF0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZThdPy5jb2xvciA9PT0gQkxBQ0s7XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYTFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYThdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDhdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVFblBhc3NhbnRTcXVhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gLTE2IDogMTYpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAxNiA6IC0xNik7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtjdXJyZW50U3F1YXJlICsgMSwgY3VycmVudFNxdWFyZSAtIDFdO1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3RhcnRTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFt0aGlzLl9lcFNxdWFyZV0gIT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW2N1cnJlbnRTcXVhcmVdPy5jb2xvciAhPT0gc3dhcENvbG9yKHRoaXMuX3R1cm4pIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8udHlwZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5DYXB0dXJlID0gKHNxdWFyZSkgPT4gIShzcXVhcmUgJiAweDg4KSAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IHRoaXMuX3R1cm4gJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV047XG4gICAgICAgIGlmICghYXR0YWNrZXJzLnNvbWUoY2FuQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGFja2VkKGNvbG9yLCBzcXVhcmUsIHZlcmJvc2UpIHtcbiAgICAgICAgY29uc3QgYXR0YWNrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVtcHR5IHNxdWFyZSBvciB3cm9uZyBjb2xvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IGkgLSBzcXVhcmU7XG4gICAgICAgICAgICAvLyBza2lwIC0gdG8vZnJvbSBzcXVhcmUgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xuICAgICAgICAgICAgaWYgKEFUVEFDS1NbaW5kZXhdICYgUElFQ0VfTUFTS1NbcGllY2UudHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZlcmVuY2UgPiAwICYmIHBpZWNlLmNvbG9yID09PSBXSElURSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmZXJlbmNlIDw9IDAgJiYgcGllY2UuY29sb3IgPT09IEJMQUNLKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGllY2UgaXMgYSBrbmlnaHQgb3IgYSBraW5nXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBSQVlTW2luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtqXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFja2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2tlcnMoc3F1YXJlLCBhdHRhY2tlZEJ5KSB7XG4gICAgICAgIGlmICghYXR0YWNrZWRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKHRoaXMuX3R1cm4sIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gdGhpcy5fa2luZ3NbY29sb3JdO1xuICAgICAgICByZXR1cm4gc3F1YXJlID09PSAtMSA/IGZhbHNlIDogdGhpcy5fYXR0YWNrZWQoc3dhcENvbG9yKGNvbG9yKSwgc3F1YXJlKTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UG9zaXRpb25Db3VudCh0aGlzLmZlbigpKSA+PSAzO1xuICAgIH1cbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWxmTW92ZXMgPj0gMTAwOyAvLyA1MCBtb3ZlcyBwZXIgc2lkZSA9IDEwMCBoYWxmIG1vdmVzXG4gICAgfVxuICAgIGlzRHJhdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRHJhd0J5RmlmdHlNb3ZlcygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzU3RhbGVtYXRlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVGhyZWVmb2xkUmVwZXRpdGlvbigpKTtcbiAgICB9XG4gICAgaXNHYW1lT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja21hdGUoKSB8fCB0aGlzLmlzU3RhbGVtYXRlKCkgfHwgdGhpcy5pc0RyYXcoKTtcbiAgICB9XG4gICAgbW92ZXMoeyB2ZXJib3NlID0gZmFsc2UsIHNxdWFyZSA9IHVuZGVmaW5lZCwgcGllY2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgc3F1YXJlLCBwaWVjZSB9KTtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IG5ldyBNb3ZlKHRoaXMsIG1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IHRoaXMuX21vdmVUb1Nhbihtb3ZlLCBtb3ZlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9tb3Zlcyh7IGxlZ2FsID0gdHJ1ZSwgcGllY2UgPSB1bmRlZmluZWQsIHNxdWFyZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZvclNxdWFyZSA9IHNxdWFyZSA/IHNxdWFyZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmb3JQaWVjZSA9IHBpZWNlPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBsZXQgZmlyc3RTcXVhcmUgPSBPeDg4LmE4O1xuICAgICAgICBsZXQgbGFzdFNxdWFyZSA9IE94ODguaDE7XG4gICAgICAgIGxldCBzaW5nbGVTcXVhcmUgPSBmYWxzZTtcbiAgICAgICAgLy8gYXJlIHdlIGdlbmVyYXRpbmcgbW92ZXMgZm9yIGEgc2luZ2xlIHNxdWFyZT9cbiAgICAgICAgaWYgKGZvclNxdWFyZSkge1xuICAgICAgICAgICAgLy8gaWxsZWdhbCBzcXVhcmUsIHJldHVybiBlbXB0eSBtb3Zlc1xuICAgICAgICAgICAgaWYgKCEoZm9yU3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RTcXVhcmUgPSBsYXN0U3F1YXJlID0gT3g4OFtmb3JTcXVhcmVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVNxdWFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IGZpcnN0U3F1YXJlOyBmcm9tIDw9IGxhc3RTcXVhcmU7IGZyb20rKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChmcm9tICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGZyb20gKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtcHR5IHNxdWFyZSBvciBvcHBvbmVudCwgc2tpcFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtmcm9tXSB8fCB0aGlzLl9ib2FyZFtmcm9tXS5jb2xvciA9PT0gdGhlbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzLl9ib2FyZFtmcm9tXTtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3F1YXJlLCBub24tY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04pO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgc3F1YXJlXG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTRUNPTkRfUkFOS1t1c10gPT09IHJhbmsoZnJvbSkgJiYgIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCB1bmRlZmluZWQsIEJJVFMuQklHX1BBV04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhd24gY2FwdHVyZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10/LmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSB0aGlzLl9lcFNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCBQQVdOLCBCSVRTLkVQX0NBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gUElFQ0VfT0ZGU0VUU1t0eXBlXS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3R5cGVdW2pdO1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duIGNvbG9yLCBzdG9wIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbdG9dLmNvbG9yID09PSB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCB0eXBlLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJyZWFrLCBpZiBrbmlnaHQgb3Iga2luZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEtOSUdIVCB8fCB0eXBlID09PSBLSU5HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZWNrIGZvciBjYXN0bGluZyBpZiB3ZSdyZTpcbiAgICAgICAgICogICBhKSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3JcbiAgICAgICAgICogICBiKSBkb2luZyBzaW5nbGUgc3F1YXJlIG1vdmUgZ2VuZXJhdGlvbiBvbiB0aGUga2luZydzIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvclBpZWNlID09PSB1bmRlZmluZWQgfHwgZm9yUGllY2UgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlU3F1YXJlIHx8IGxhc3RTcXVhcmUgPT09IHRoaXMuX2tpbmdzW3VzXSkge1xuICAgICAgICAgICAgICAgIC8vIGtpbmctc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gKyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSArIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdGcm9tICsgMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgS0lORywgdW5kZWZpbmVkLCBCSVRTLktTSURFX0NBU1RMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVlZW4tc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gLSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gLSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuUVNJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXG4gICAgICAgICAqIHRvIGJlIGNhcHR1cmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFsZWdhbCB8fCB0aGlzLl9raW5nc1t1c10gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzXG4gICAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKHVzKSkge1xuICAgICAgICAgICAgICAgIGxlZ2FsTW92ZXMucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgIH1cbiAgICBtb3ZlKG1vdmUsIHsgc3RyaWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBtb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKCdOeGI3JykgICAgICAgPC0gYXJndW1lbnQgaXMgYSBjYXNlLXNlbnNpdGl2ZSBTQU4gc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKHsgZnJvbTogJ2g3JywgPC0gYXJndW1lbnQgaXMgYSBtb3ZlIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgIHRvIDonaDgnLFxuICAgICAgICAgKiAgICAgICAgIHByb21vdGlvbjogJ3EnIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHN0cmljdCBhcmd1bWVudCBtYXkgYmUgc3VwcGxpZWQgdG8gdGVsbCBjaGVzcy5qcyB0b1xuICAgICAgICAgKiBzdHJpY3RseSBmb2xsb3cgdGhlIFNBTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1vdmVPYmogPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtb3ZlT2JqID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHwgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGZpbmQgbW92ZVxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHttb3ZlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7SlNPTi5zdHJpbmdpZnkobW92ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZSBtb3ZlXG4gICAgICAgICAqIGlzIG1hZGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZXR0eU1vdmUgPSBuZXcgTW92ZSh0aGlzLCBtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZU9iaik7XG4gICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQocHJldHR5TW92ZS5hZnRlcik7XG4gICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgIH1cbiAgICBfcHVzaChtb3ZlKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBtb3ZlLFxuICAgICAgICAgICAga2luZ3M6IHsgYjogdGhpcy5fa2luZ3MuYiwgdzogdGhpcy5fa2luZ3MudyB9LFxuICAgICAgICAgICAgdHVybjogdGhpcy5fdHVybixcbiAgICAgICAgICAgIGNhc3RsaW5nOiB7IGI6IHRoaXMuX2Nhc3RsaW5nLmIsIHc6IHRoaXMuX2Nhc3RsaW5nLncgfSxcbiAgICAgICAgICAgIGVwU3F1YXJlOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgIGhhbGZNb3ZlczogdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgbW92ZU51bWJlcjogdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tYWtlTW92ZShtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIHRoaXMuX3B1c2gobW92ZSk7XG4gICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0gdGhpcy5fYm9hcmRbbW92ZS5mcm9tXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUuZnJvbV07XG4gICAgICAgIC8vIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3blxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUudG8gLSAxNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS50byArIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBwYXduIHByb21vdGlvbiwgcmVwbGFjZSB3aXRoIG5ldyBwaWVjZVxuICAgICAgICBpZiAobW92ZS5wcm9tb3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0geyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgbW92ZWQgdGhlIGtpbmdcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW21vdmUudG9dLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3VzXSA9IG1vdmUudG87XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYXN0bGVkLCBtb3ZlIHRoZSByb29rIG5leHQgdG8gdGhlIGtpbmdcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW2Nhc3RsaW5nVG9dID0gdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nXG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBST09LU1t1c10ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBST09LU1t1c11baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSAmIFJPT0tTW3VzXVtpXS5mbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSBePSBST09LU1t1c11baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIGNhcHR1cmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t0aGVtXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3RoZW1dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUudG8gPT09IFJPT0tTW3RoZW1dW2ldLnNxdWFyZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSAmIFJPT0tTW3RoZW1dW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gXj0gUk9PS1NbdGhlbV1baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGJpZyBwYXduIG1vdmUsIHVwZGF0ZSB0aGUgZW4gcGFzc2FudCBzcXVhcmVcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkJJR19QQVdOKSB7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIDUwIG1vdmUgY291bnRlciBpZiBhIHBhd24gaXMgbW92ZWQgb3IgYSBwaWVjZSBpcyBjYXB0dXJlZFxuICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRoZW07XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fZGVjUG9zaXRpb25Db3VudChwcmV0dHlNb3ZlLmFmdGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdW5kb01vdmUoKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZSA9IG9sZC5tb3ZlO1xuICAgICAgICB0aGlzLl9raW5ncyA9IG9sZC5raW5ncztcbiAgICAgICAgdGhpcy5fdHVybiA9IG9sZC50dXJuO1xuICAgICAgICB0aGlzLl9jYXN0bGluZyA9IG9sZC5jYXN0bGluZztcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBvbGQuZXBTcXVhcmU7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IG9sZC5oYWxmTW92ZXM7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBvbGQubW92ZU51bWJlcjtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS5mcm9tXSA9IHRoaXMuX2JvYXJkW21vdmUudG9dO1xuICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLmZyb21dLnR5cGUgPSBtb3ZlLnBpZWNlOyAvLyB0byB1bmRvIGFueSBwcm9tb3Rpb25zXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFttb3ZlLnRvXTtcbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICAgICAgLy8gZW4gcGFzc2FudCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbaW5kZXhdID0geyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVndWxhciBjYXB0dXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5LU0lERV9DQVNUTEUgfCBCSVRTLlFTSURFX0NBU1RMRSkpIHtcbiAgICAgICAgICAgIGxldCBjYXN0bGluZ1RvLCBjYXN0bGluZ0Zyb207XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICAgIHBnbih7IG5ld2xpbmUgPSAnXFxuJywgbWF4V2lkdGggPSAwLCB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xuICAgICAgICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGhlYWRlckV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAvKiBhZGQgdGhlIFBHTiBoZWFkZXIgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRPRE86IG9yZGVyIG9mIGVudW1lcmF0ZWQgcHJvcGVydGllcyBpbiBoZWFkZXIgb2JqZWN0IGlzIG5vdFxuICAgICAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXN1bHQucHVzaCgnWycgKyBpICsgJyBcIicgKyB0aGlzLl9oZWFkZXJbaV0gKyAnXCJdJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyRXhpc3RzICYmIHRoaXMuX2hpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRDb21tZW50ID0gKG1vdmVTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBtb3ZlU3RyaW5nLmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vdmVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBvcCBhbGwgb2YgaGlzdG9yeSBvbnRvIHJldmVyc2VkX2hpc3RvcnlcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGxldCBtb3ZlU3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhIGNvbW1lbnRlZCBzdGFydGluZyBwb3NpdGlvbiB3aXRoIG5vIG1vdmVzXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQoJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXG4gICAgICAgIHdoaWxlIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW92ZVN0cmluZyA9IGFwcGVuZENvbW1lbnQobW92ZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBUeXBlU2NyaXB0IHN0b3AgY29tcGxhaW5pbmcgYWJvdXQgbW92ZSBiZWluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIHN0YXJ0ZWQgd2l0aCBibGFjayB0byBtb3ZlLCBzdGFydCBQR04gd2l0aCAjLiAuLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCR7dGhpcy5fbW92ZU51bWJlcn0uIC4uLmA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjb21tZW50IHByZWNlZGluZyB0aGUgZmlyc3QgbW92ZT9cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSB0aGlzLl9tb3ZlTnVtYmVyICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyArICcgJyArIHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgb3RoZXIgbGVmdG92ZXIgbW92ZXM/XG4gICAgICAgIGlmIChtb3ZlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyB0aGVyZSBhIHJlc3VsdD9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9oZWFkZXIuUmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbW92ZXMucHVzaCh0aGlzLl9oZWFkZXIuUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBoaXN0b3J5IHNob3VsZCBiZSBiYWNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBzdGFydGVkIGdlbmVyYXRpbmcgUEdOLFxuICAgICAgICAgKiBzbyBqb2luIHRvZ2V0aGVyIG1vdmVzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobWF4V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJykgKyBtb3Zlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAoamFoKTogaHVoP1xuICAgICAgICBjb25zdCBzdHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgd3JhcENvbW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIG1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbW92ZS5zcGxpdCgnICcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdyYXAgdGhlIFBHTiBvdXRwdXQgYXQgbWF4X3dpZHRoXG4gICAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaV0uaW5jbHVkZXMoJ3snKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSB3cmFwQ29tbWVudChjdXJyZW50V2lkdGgsIG1vdmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbW92ZSB3aWxsIHB1c2ggcGFzdCBtYXhfd2lkdGhcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHRoZSBsaW5lIHdpdGggd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICBjdXJyZW50V2lkdGggKz0gbW92ZXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBzZXRIZWFkZXJgIGFuZCBgZ2V0SGVhZGVyc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBoZWFkZXIoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbaSArIDFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgbG9hZFBnbihwZ24sIHsgc3RyaWN0ID0gZmFsc2UsIG5ld2xpbmVDaGFyID0gJ1xccj9cXG4nLCB9ID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gbWFzayhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUGduSGVhZGVyKGhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyT2JqID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gaGVhZGVyLnNwbGl0KG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhcikpKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAnJztcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXlxccypcXFtcXHMqKFtBLVphLXpdKylcXHMqXCIoLiopXCJcXHMqXFxdXFxzKiQvO1xuICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcnNbaV0ucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2ldLnJlcGxhY2UocmVnZXgsICckMicpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyT2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyT2JqO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmlwIHdoaXRlc3BhY2UgZnJvbSBoZWFkL3RhaWwgb2YgUEdOIGJsb2NrXG4gICAgICAgIHBnbiA9IHBnbi50cmltKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlZ0V4cCB0byBzcGxpdCBoZWFkZXIuIFRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGhlYWRlciBhbmQgbW92ZXRleHRcbiAgICAgICAgICogd2lsbCBhbHdheXMgaGF2ZSBhIGJsYW5rIGxpbmUgYmV0d2VlbiB0aGVtIChpZSwgdHdvIG5ld2xpbmVfY2hhcidzKS4gSGFuZGxlc1xuICAgICAgICAgKiBjYXNlIHdoZXJlIG1vdmV0ZXh0IGlzIGVtcHR5IGJ5IG1hdGNoaW5nIG5ld2xpbmVDaGFyIHVudGlsIGVuZCBvZiBzdHJpbmcgaXNcbiAgICAgICAgICogbWF0Y2hlZCAtIGVmZmVjdGl2ZWx5IHRyaW1taW5nIGZyb20gdGhlIGVuZCBleHRyYSBuZXdsaW5lQ2hhci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBkZWZhdWx0IG5ld2xpbmVfY2hhciwgd2lsbCBlcXVhbDpcbiAgICAgICAgICogL14oXFxbKCg/Olxccj9cXG4pfC4pKlxcXSkoKD86XFxzKlxccj9cXG4pezJ9fCg/OlxccypcXHI/XFxuKSokKS9cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihcXFxcWygoPzonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpfC4pKlxcXFxdKScgK1xuICAgICAgICAgICAgJygoPzpcXFxccyonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpezJ9fCg/OlxcXFxzKicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJykqJCknKTtcbiAgICAgICAgLy8gSWYgbm8gaGVhZGVyIGdpdmVuLCBiZWdpbiB3aXRoIG1vdmVzLlxuICAgICAgICBjb25zdCBoZWFkZXJSZWdleFJlc3VsdHMgPSBoZWFkZXJSZWdleC5leGVjKHBnbik7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGhlYWRlclJlZ2V4UmVzdWx0c1xuICAgICAgICAgICAgPyBoZWFkZXJSZWdleFJlc3VsdHMubGVuZ3RoID49IDJcbiAgICAgICAgICAgICAgICA/IGhlYWRlclJlZ2V4UmVzdWx0c1sxXVxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIC8vIFB1dCB0aGUgYm9hcmQgaW4gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgLy8gcGFyc2UgUEdOIGhlYWRlclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VQZ25IZWFkZXIoaGVhZGVyU3RyaW5nKTtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdXNlciBpcyBpbmNsdWRpbmcgZmVuIChwb3NzaWJseSB3aXRoIHdyb25nIHRhZyBjYXNlKVxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZmVuJykge1xuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgc2hvdWxkIGF0dGVtcHQgdG8gbG9hZCBhIGZlbiB0YWcsIGV2ZW4gaWYgaXQncyB0aGVcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXG4gICAgICAgICAgICAgKiBhbmQgW0ZFTiBwb3NpdGlvbl1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICAgICAgICAgIGlmICghKCdGRU4nIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQR046IEZFTiB0YWcgbXVzdCBiZSBzdXBwbGllZCB3aXRoIFNldFVwIHRhZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjbGVhciB0aGUgaGVhZGVycyB3aGVuIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoaGVhZGVyc1snRkVOJ10sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIE5COiB0aGUgcmVnZXhlcyBiZWxvdyB0aGF0IGRlbGV0ZSBtb3ZlIG51bWJlcnMsIHJlY3Vyc2l2ZSBhbm5vdGF0aW9ucyxcbiAgICAgICAgICogYW5kIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgbWF5IGFsc28gbWF0Y2ggdGV4dCBpbiBjb21tZW50cy4gVG9cbiAgICAgICAgICogcHJldmVudCB0aGlzLCB3ZSB0cmFuc2Zvcm0gY29tbWVudHMgYnkgaGV4LWVuY29kaW5nIHRoZW0gaW4gcGxhY2UgYW5kXG4gICAgICAgICAqIGRlY29kaW5nIHRoZW0gYWdhaW4gYWZ0ZXIgdGhlIG90aGVyIHRva2VucyBoYXZlIGJlZW4gZGVsZXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hpbGUgdGhlIHNwZWMgc3RhdGVzIHRoYXQgUEdOIGZpbGVzIHNob3VsZCBiZSBBU0NJSSBlbmNvZGVkLCB3ZSB1c2VcbiAgICAgICAgICoge2VuLGRlfWNvZGVVUklDb21wb25lbnQgaGVyZSB0byBzdXBwb3J0IGFyYml0cmFyeSBVVEY4IGFzIGEgY29udmVuaWVuY2VcbiAgICAgICAgICogZm9yIG1vZGVybiB1c2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdG9IZXgocykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBlbmNvZGVVUkkgZG9lc24ndCB0cmFuc2Zvcm0gbW9zdCBBU0NJSSBjaGFyYWN0ZXJzLCBzbyB3ZSBoYW5kbGVcbiAgICAgICAgICAgICAgICAgKiB0aGVzZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIDwgMTI4XG4gICAgICAgICAgICAgICAgICAgID8gYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChjKS5yZXBsYWNlKC8lL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbUhleChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IGRlY29kZVVSSUNvbXBvbmVudCgnJScgKyAocy5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKS5qb2luKCclJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZUNvbW1lbnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZUNoYXIpLCAnZycpLCAnICcpO1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0b0hleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpfX1gO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVDb21tZW50ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXJ0c1dpdGgoJ3snKSAmJiBzLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUhleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgaGVhZGVyIHRvIGdldCB0aGUgbW92ZXNcbiAgICAgICAgbGV0IG1zID0gcGduXG4gICAgICAgICAgICAucmVwbGFjZShoZWFkZXJTdHJpbmcsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgIC8vIGVuY29kZSBjb21tZW50cyBzbyB0aGV5IGRvbid0IGdldCBkZWxldGVkIGJlbG93XG4gICAgICAgIG5ldyBSZWdFeHAoYCh7W159XSp9KSs/fDsoW14ke21hc2sobmV3bGluZUNoYXIpfV0qKWAsICdnJyksIGZ1bmN0aW9uIChfbWF0Y2gsIGJyYWNrZXQsIHNlbWljb2xvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJyYWNrZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZW5jb2RlQ29tbWVudChicmFja2V0KVxuICAgICAgICAgICAgICAgIDogJyAnICsgZW5jb2RlQ29tbWVudChgeyR7c2VtaWNvbG9uLnNsaWNlKDEpfX1gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhciksICdnJyksICcgJyk7XG4gICAgICAgIC8vIGRlbGV0ZSByZWN1cnNpdmUgYW5ub3RhdGlvbiB2YXJpYXRpb25zXG4gICAgICAgIGNvbnN0IHJhdlJlZ2V4ID0gLyhcXChbXigpXStcXCkpKz8vZztcbiAgICAgICAgd2hpbGUgKHJhdlJlZ2V4LnRlc3QobXMpKSB7XG4gICAgICAgICAgICBtcyA9IG1zLnJlcGxhY2UocmF2UmVnZXgsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgbW92ZSBudW1iZXJzXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFxkK1xcLihcXC5cXC4pPy9nLCAnJyk7XG4gICAgICAgIC8vIGRlbGV0ZSAuLi4gaW5kaWNhdGluZyBibGFjayB0byBtb3ZlXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFwuXFwuXFwuL2csICcnKTtcbiAgICAgICAgLyogZGVsZXRlIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgKi9cbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXCRcXGQrL2csICcnKTtcbiAgICAgICAgLy8gdHJpbSBhbmQgZ2V0IGFycmF5IG9mIG1vdmVzXG4gICAgICAgIGxldCBtb3ZlcyA9IG1zLnRyaW0oKS5zcGxpdChuZXcgUmVnRXhwKC9cXHMrLykpO1xuICAgICAgICAvLyBkZWxldGUgZW1wdHkgZW50cmllc1xuICAgICAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcigobW92ZSkgPT4gbW92ZSAhPT0gJycpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGhhbGZNb3ZlID0gMDsgaGFsZk1vdmUgPCBtb3Zlcy5sZW5ndGg7IGhhbGZNb3ZlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBkZWNvZGVDb21tZW50KG1vdmVzW2hhbGZNb3ZlXSk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX21vdmVGcm9tU2FuKG1vdmVzW2hhbGZNb3ZlXSwgc3RyaWN0KTtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbW92ZVxuICAgICAgICAgICAgaWYgKG1vdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdhcyB0aGUgbW92ZSBhbiBlbmQgb2YgZ2FtZSBtYXJrZXJcbiAgICAgICAgICAgICAgICBpZiAoVEVSTUlOQVRJT05fTUFSS0VSUy5pbmRleE9mKG1vdmVzW2hhbGZNb3ZlXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb3Zlc1toYWxmTW92ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZSBpbiBQR046ICR7bW92ZXNbaGFsZk1vdmVdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBlbmQgb2YgZ2FtZSBtYXJrZXIgaWYgbWFraW5nIGEgdmFsaWQgbW92ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQodGhpcy5mZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogUGVyIHNlY3Rpb24gOC4yLjYgb2YgdGhlIFBHTiBzcGVjLCB0aGUgUmVzdWx0IHRhZyBwYWlyIG11c3QgbWF0Y2ggbWF0Y2hcbiAgICAgICAgICogdGhlIHRlcm1pbmF0aW9uIG1hcmtlci4gT25seSBkbyB0aGlzIHdoZW4gaGVhZGVycyBhcmUgcHJlc2VudCwgYnV0IHRoZVxuICAgICAgICAgKiByZXN1bHQgdGFnIGlzIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiYgIXRoaXMuX2hlYWRlclsnUmVzdWx0J10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCdSZXN1bHQnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQ29udmVydCBhIG1vdmUgZnJvbSAweDg4IGNvb3JkaW5hdGVzIHRvIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvblxuICAgICAqIChTQU4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cmljdCBVc2UgdGhlIHN0cmljdCBTQU4gcGFyc2VyLiBJdCB3aWxsIHRocm93IGVycm9yc1xuICAgICAqIG9uIG92ZXJseSBkaXNhbWJpZ3VhdGVkIG1vdmVzIChzZWUgYmVsb3cpOlxuICAgICAqXG4gICAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XG4gICAgICogNC4gLi4uIE5nZTcgaXMgb3Zlcmx5IGRpc2FtYmlndWF0ZWQgYmVjYXVzZSB0aGUga25pZ2h0IG9uIGM2IGlzIHBpbm5lZFxuICAgICAqIDQuIC4uLiBOZTcgaXMgdGVjaG5pY2FsbHkgdGhlIHZhbGlkIFNBTlxuICAgICAqL1xuICAgIF9tb3ZlVG9TYW4obW92ZSwgbW92ZXMpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8tTyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGNvbnN0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpO1xuICAgICAgICBsZXQgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbGV0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBsZWdhbDogdHJ1ZSwgcGllY2U6IHBpZWNlVHlwZSB9KTtcbiAgICAgICAgLy8gc3RyaWN0IHBhcnNlclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09IHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc3RyaWN0IHBhcnNlciBmYWlsZWRcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpZWNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHByb21vdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGRlZmF1bHQgcGVybWlzc2l2ZSAobm9uLXN0cmljdCkgcGFyc2VyIGFsbG93cyB0aGUgdXNlciB0byBwYXJzZVxuICAgICAgICAgKiBub24tc3RhbmRhcmQgY2hlc3Mgbm90YXRpb25zLiBUaGlzIHBhcnNlciBpcyBvbmx5IHJ1biBhZnRlciB0aGUgc3RyaWN0XG4gICAgICAgICAqIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvbiAoU0FOKSBwYXJzZXIgaGFzIGZhaWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBydW5uaW5nIHRoZSBwZXJtaXNzaXZlIHBhcnNlciwgd2UnbGwgcnVuIGEgcmVnZXggdG8gZ3JhYiB0aGUgcGllY2UsIHRoZVxuICAgICAgICAgKiB0by9mcm9tIHNxdWFyZSwgYW5kIGFuIG9wdGlvbmFsIHByb21vdGlvbiBwaWVjZS4gVGhpcyByZWdleCB3aWxsXG4gICAgICAgICAqIHBhcnNlIGNvbW1vbiBub24tc3RhbmRhcmQgbm90YXRpb24gbGlrZTogUGUyLWU0LCBSYzFjNCwgUWYzeGY3LFxuICAgICAgICAgKiBmN2Y4cSwgYjFjM1xuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBTb21lIHBvc2l0aW9ucyBhbmQgbW92ZXMgbWF5IGJlIGFtYmlndW91cyB3aGVuIHVzaW5nIHRoZSBwZXJtaXNzaXZlXG4gICAgICAgICAqIHBhcnNlci4gRm9yIGV4YW1wbGUsIGluIHRoaXMgcG9zaXRpb246IDZrMS84LzgvQjcvOC84LzgvQk40SzEgdyAtIC0gMCAxLFxuICAgICAgICAgKiB0aGUgbW92ZSBiMWMzIG1heSBiZSBpbnRlcnByZXRlZCBhcyBOYzMgb3IgQjFjMyAoYSBkaXNhbWJpZ3VhdGVkIGJpc2hvcFxuICAgICAgICAgKiBtb3ZlKS4gSW4gdGhlc2UgY2FzZXMsIHRoZSBwZXJtaXNzaXZlIHBhcnNlciB3aWxsIGRlZmF1bHQgdG8gdGhlIG1vc3RcbiAgICAgICAgICogYmFzaWMgaW50ZXJwcmV0YXRpb24gKHdoaWNoIGlzIGIxYzMgcGFyc2luZyB0byBOYzMpLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG92ZXJseURpc2FtYmlndWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF1bMS04XSl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy8pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgZnJvbSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgW2EtaF0/WzEtOF0/IHBvcnRpb24gb2YgdGhlIHJlZ2V4IGJlbG93IGhhbmRsZXMgbW92ZXMgdGhhdCBtYXkgYmVcbiAgICAgICAgICAgICAqIG92ZXJseSBkaXNhbWJpZ3VhdGVkIChlLmcuIE5nZTcgaXMgdW5uZWNlc3NhcnkgYW5kIG5vbi1zdGFuZGFyZCB3aGVuXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBvbmUgbGVnYWwga25pZ2h0IG1vdmUgdG8gZTcpLiBJbiB0aGlzIGNhc2UsIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgICAgICogJ2Zyb20nIHZhcmlhYmxlIHdpbGwgYmUgYSByYW5rIG9yIGZpbGUsIG5vdCBhIHNxdWFyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF0/WzEtOF0/KXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHBpZWNlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgcHJvbW90aW9uID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7XG4gICAgICAgICAgICBsZWdhbDogdHJ1ZSxcbiAgICAgICAgICAgIHBpZWNlOiBwaWVjZSA/IHBpZWNlIDogcGllY2VUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmcm9tIHNxdWFyZSwgaXQgY291bGQgYmUganVzdCAneCcgbWlzc2luZyBmcm9tIGEgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKS5yZXBsYWNlKCd4JywgJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZC1jb21wYXJlIG1vdmUgcHJvcGVydGllcyB3aXRoIHRoZSByZXN1bHRzIGZyb20gb3VyIHBlcm1pc3NpdmUgcmVnZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgICAgICAgICBPeDg4W2Zyb21dID09IG1vdmVzW2ldLmZyb20gJiZcbiAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybHlEaXNhbWJpZ3VhdGVkKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTUEVDSUFMIENBU0U6IHdlIHBhcnNlZCBhIG1vdmUgc3RyaW5nIHRoYXQgbWF5IGhhdmUgYW4gdW5uZWVkZWRcbiAgICAgICAgICAgICAgICAgKiByYW5rL2ZpbGUgZGlzYW1iaWd1YXRvciAoZS5nLiBOZ2U3KS4gIFRoZSAnZnJvbScgdmFyaWFibGUgd2lsbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IGFsZ2VicmFpYyhtb3Zlc1tpXS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICAgICAoZnJvbSA9PSBzcXVhcmVbMF0gfHwgZnJvbSA9PSBzcXVhcmVbMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXNjaWkoKSB7XG4gICAgICAgIGxldCBzID0gJyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXFxuJztcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaXNwbGF5IHRoZSByYW5rXG4gICAgICAgICAgICBpZiAoZmlsZShpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgJzg3NjU0MzIxJ1tyYW5rKGkpXSArICcgfCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9ib2FyZFtpXS5jb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArIHN5bWJvbCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAuICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBzICs9ICd8XFxuJztcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBzICs9ICcgICAgIGEgIGIgIGMgIGQgIGUgIGYgIGcgIGgnO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcGVyZnQoZGVwdGgpIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiBmYWxzZSB9KTtcbiAgICAgICAgbGV0IG5vZGVzID0gMDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl90dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIC0gMSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgKz0gdGhpcy5wZXJmdChkZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XG4gICAgfVxuICAgIGJvYXJkKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZTogYWxnZWJyYWljKGkpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fYm9hcmRbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcbiAgICAgICAgaWYgKHNxdWFyZSBpbiBPeDg4KSB7XG4gICAgICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGlzdG9yeSh7IHZlcmJvc2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIaXN0b3J5LnB1c2gobmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHBvc2l0aW9uIG9jY3VycmVuY2UgY291bnRzIGZvciB0aGUgcHVycG9zZSBvZiByZXBldGl0aW9uXG4gICAgICogY2hlY2tpbmcuIEFsbCB0aHJlZSBtZXRob2RzIChgX2luY2AsIGBfZGVjYCwgYW5kIGBfZ2V0YCkgdHJpbSB0aGVcbiAgICAgKiBpcnJlbGV2ZW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGZlbiwgaW5pdGlhbGlzaW5nIG5ldyBwb3NpdGlvbnMsIGFuZFxuICAgICAqIHJlbW92aW5nIG9sZCBwb3NpdGlvbnMgZnJvbSB0aGUgcmVjb3JkIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxuICAgICAqL1xuICAgIF9nZXRQb3NpdGlvbkNvdW50KGZlbikge1xuICAgICAgICBjb25zdCB0cmltbWVkRmVuID0gdHJpbUZlbihmZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSB8fCAwO1xuICAgIH1cbiAgICBfaW5jUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSArPSAxO1xuICAgIH1cbiAgICBfZGVjUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcnVuZUNvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1lbnRzID0ge307XG4gICAgICAgIGNvbnN0IGNvcHlDb21tZW50ID0gKGZlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tZW50c1tmZW5dID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0gY3VycmVudENvbW1lbnRzO1xuICAgIH1cbiAgICBnZXRDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgfVxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQucmVwbGFjZSgneycsICdbJykucmVwbGFjZSgnfScsICddJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgdG8gYHJlbW92ZUNvbW1lbnRgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAoKHJpZ2h0c1tLSU5HXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tLSU5HXSA9PT0gcmVzdWx0W0tJTkddKSAmJlxuICAgICAgICAgICAgKHJpZ2h0c1tRVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbUVVFRU5dID09PSByZXN1bHRbUVVFRU5dKSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chess.js/dist/esm/chess.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fayushsinghchauhan%2FDownloads%2Fdont_delete%2Fcd3%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fayushsinghchauhan%2FDownloads%2Fdont_delete%2Fcd3%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \****************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmF5dXNoc2luZ2hjaGF1aGFuJTJGRG93bmxvYWRzJTJGZG9udF9kZWxldGUlMkZjZDMlMkZzcmMlMkZwYWdlcyUyRmluZGV4LnRzeCZwYWdlPSUyRiEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2YxNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9pbmRleC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fayushsinghchauhan%2FDownloads%2Fdont_delete%2Fcd3%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./src/components/GameDashboard.tsx":
/*!******************************************!*\
  !*** ./src/components/GameDashboard.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameDashboard: function() { return /* binding */ GameDashboard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction GameDashboard(param) {\n    let { gameState, player1Wallet, player2Wallet, player1Bet, player2Bet, player1EscrowLocked = false, player2EscrowLocked = false, escrowLocked, finalBetAmount, winner } = param;\n    const getGameStatus = ()=>{\n        if (!player1Wallet && !player2Wallet) {\n            return \"Please connect both player wallets to start the game\";\n        }\n        if (!player1Wallet || !player2Wallet) {\n            return \"Waiting for \".concat(!player1Wallet ? \"Player 1\" : \"Player 2\", \" to connect wallet\");\n        }\n        switch(gameState){\n            case \"waiting\":\n                return \"Waiting for players to announce their bets\";\n            case \"betting\":\n                if (player1Bet > 0 && player2Bet > 0) {\n                    const minimumBet = Math.min(player1Bet, player2Bet);\n                    return \"Both players have announced bets - Minimum bet: \".concat(minimumBet, \" APT. This is the amount that will be locked in escrow.\");\n                } else if (player1Bet > 0) {\n                    return \"Player 1 bet: \".concat(player1Bet, \" APT. Waiting for Player 2 to announce bet.\");\n                } else if (player2Bet > 0) {\n                    return \"Player 2 bet: \".concat(player2Bet, \" APT. Waiting for Player 1 to announce bet.\");\n                }\n                return \"Waiting for players to announce their bets\";\n            case \"bet_announced\":\n                return \"Both players have announced bets. Lock the escrow to start the game.\";\n            case \"escrow_locked\":\n                return \"Escrow locked. Game will start shortly.\";\n            case \"playing\":\n                return \"Game in progress. Total pot: \".concat(finalBetAmount, \" APT\");\n            case \"completed\":\n                if (winner === \"draw\") {\n                    return \"Game ended in a draw! Both players receive their bets back.\";\n                } else if (winner === \"player1\") {\n                    return \"Player 1 wins \".concat(finalBetAmount, \" APT!\");\n                } else if (winner === \"player2\") {\n                    return \"Player 2 wins \".concat(finalBetAmount, \" APT!\");\n                }\n                return \"Game completed.\";\n            default:\n                return \"Unknown game state\";\n        }\n    };\n    const getEscrowStatus = ()=>{\n        if (gameState === \"waiting\" || gameState === \"completed\") {\n            return null;\n        }\n        const minimumBet = player1Bet > 0 && player2Bet > 0 ? Math.min(player1Bet, player2Bet) : 0;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"mb-4 p-3 border rounded bg-gray-50\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                    className: \"text-lg font-semibold mb-2\",\n                    children: \"Escrow Status\"\n                }, void 0, false, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                    lineNumber: 87,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-2 gap-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"font-medium\",\n                                            children: \"Player 1:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                            lineNumber: 90,\n                                            columnNumber: 16\n                                        }, this),\n                                        \" \",\n                                        player1EscrowLocked ? \" Locked\" : \"\\uD83D\\uDD13 Unlocked\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                    lineNumber: 90,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"font-medium\",\n                                            children: \"Announced Bet:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                            lineNumber: 91,\n                                            columnNumber: 16\n                                        }, this),\n                                        \" \",\n                                        player1Bet,\n                                        \" APT\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                    lineNumber: 91,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                            lineNumber: 89,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"font-medium\",\n                                            children: \"Player 2:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                            lineNumber: 94,\n                                            columnNumber: 16\n                                        }, this),\n                                        \" \",\n                                        player2EscrowLocked ? \" Locked\" : \"\\uD83D\\uDD13 Unlocked\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                    lineNumber: 94,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"font-medium\",\n                                            children: \"Announced Bet:\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                            lineNumber: 95,\n                                            columnNumber: 16\n                                        }, this),\n                                        \" \",\n                                        player2Bet,\n                                        \" APT\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                    lineNumber: 95,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                            lineNumber: 93,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                    lineNumber: 88,\n                    columnNumber: 9\n                }, this),\n                minimumBet > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mt-2 p-2 bg-blue-50 border border-blue-200 rounded\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-blue-800 font-medium\",\n                        children: [\n                            \"Minimum bet: \",\n                            minimumBet,\n                            \" APT\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"block text-sm font-normal mt-1\",\n                                children: [\n                                    \"Each player will lock \",\n                                    minimumBet,\n                                    \" APT in escrow, for a total pot of \",\n                                    minimumBet * 2,\n                                    \" APT\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                                lineNumber: 103,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                        lineNumber: 101,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                    lineNumber: 100,\n                    columnNumber: 11\n                }, this),\n                (player1EscrowLocked || player2EscrowLocked) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mt-2\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-sm\",\n                        children: player1EscrowLocked && player2EscrowLocked ? \" Both players have locked their escrow. Game is ready to start.\" : player1EscrowLocked ? \" Waiting for Player 2 to lock escrow...\" : \" Waiting for Player 1 to lock escrow...\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                        lineNumber: 112,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                    lineNumber: 111,\n                    columnNumber: 11\n                }, this),\n                escrowLocked && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mt-2 p-2 bg-green-100 rounded\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-green-700\",\n                        children: [\n                            \" Escrow locked! Final amount: \",\n                            finalBetAmount,\n                            \" APT\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                        lineNumber: 123,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                    lineNumber: 122,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n            lineNumber: 86,\n            columnNumber: 7\n        }, this);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"mb-6 p-4 border rounded bg-blue-50\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-xl font-bold mb-2\",\n                children: \"Game Status\"\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                lineNumber: 132,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"mb-4\",\n                children: getGameStatus()\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n                lineNumber: 133,\n                columnNumber: 7\n            }, this),\n            getEscrowStatus()\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/GameDashboard.tsx\",\n        lineNumber: 131,\n        columnNumber: 5\n    }, this);\n}\n_c = GameDashboard;\nvar _c;\n$RefreshReg$(_c, \"GameDashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRTt3QkFBRUYsV0FBVTtrQ0FDVlgsdUJBQXVCQyxzQkFDcEIscUVBQ0FELHNCQUNFLDZDQUNBOzs7Ozs7Ozs7OztnQkFJWEUsOEJBQ0MsOERBQUNRO29CQUFJQyxXQUFVOzhCQUNiLDRFQUFDRTt3QkFBRUYsV0FBVTs7NEJBQWlCOzRCQUFnQ1I7NEJBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUt2RjtJQUVBLHFCQUNFLDhEQUFDTztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0k7Z0JBQUdKLFdBQVU7MEJBQXlCOzs7Ozs7MEJBQ3ZDLDhEQUFDRTtnQkFBRUYsV0FBVTswQkFBUU47Ozs7OztZQUNwQkk7Ozs7Ozs7QUFHUDtLQWpIZ0JmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0dhbWVEYXNoYm9hcmQudHN4PzA2NzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIFdhbGxldCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xufVxuXG50eXBlIFdpbm5lciA9ICdwbGF5ZXIxJyB8ICdwbGF5ZXIyJyB8ICdkcmF3JyB8IG51bGw7XG50eXBlIEdhbWVTdGF0ZSA9ICd3YWl0aW5nJyB8ICdiZXR0aW5nJyB8ICdiZXRfYW5ub3VuY2VkJyB8ICdlc2Nyb3dfbG9ja2VkJyB8ICdwbGF5aW5nJyB8ICdjb21wbGV0ZWQnO1xuXG5pbnRlcmZhY2UgR2FtZURhc2hib2FyZFByb3BzIHtcbiAgZ2FtZVN0YXRlOiBHYW1lU3RhdGU7XG4gIHBsYXllcjFXYWxsZXQ6IFdhbGxldCB8IG51bGw7XG4gIHBsYXllcjJXYWxsZXQ6IFdhbGxldCB8IG51bGw7XG4gIHBsYXllcjFCZXQ6IG51bWJlcjtcbiAgcGxheWVyMkJldDogbnVtYmVyO1xuICBwbGF5ZXIxRXNjcm93TG9ja2VkPzogYm9vbGVhbjtcbiAgcGxheWVyMkVzY3Jvd0xvY2tlZD86IGJvb2xlYW47XG4gIGVzY3Jvd0xvY2tlZDogYm9vbGVhbjtcbiAgZmluYWxCZXRBbW91bnQ6IG51bWJlcjtcbiAgd2lubmVyOiBXaW5uZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHYW1lRGFzaGJvYXJkKHtcbiAgZ2FtZVN0YXRlLFxuICBwbGF5ZXIxV2FsbGV0LFxuICBwbGF5ZXIyV2FsbGV0LFxuICBwbGF5ZXIxQmV0LFxuICBwbGF5ZXIyQmV0LFxuICBwbGF5ZXIxRXNjcm93TG9ja2VkID0gZmFsc2UsXG4gIHBsYXllcjJFc2Nyb3dMb2NrZWQgPSBmYWxzZSxcbiAgZXNjcm93TG9ja2VkLFxuICBmaW5hbEJldEFtb3VudCxcbiAgd2lubmVyXG59OiBHYW1lRGFzaGJvYXJkUHJvcHMpIHtcbiAgY29uc3QgZ2V0R2FtZVN0YXR1cyA9ICgpID0+IHtcbiAgICBpZiAoIXBsYXllcjFXYWxsZXQgJiYgIXBsYXllcjJXYWxsZXQpIHtcbiAgICAgIHJldHVybiAnUGxlYXNlIGNvbm5lY3QgYm90aCBwbGF5ZXIgd2FsbGV0cyB0byBzdGFydCB0aGUgZ2FtZSc7XG4gICAgfVxuXG4gICAgaWYgKCFwbGF5ZXIxV2FsbGV0IHx8ICFwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICByZXR1cm4gYFdhaXRpbmcgZm9yICR7IXBsYXllcjFXYWxsZXQgPyAnUGxheWVyIDEnIDogJ1BsYXllciAyJ30gdG8gY29ubmVjdCB3YWxsZXRgO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZ2FtZVN0YXRlKSB7XG4gICAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgICAgcmV0dXJuICdXYWl0aW5nIGZvciBwbGF5ZXJzIHRvIGFubm91bmNlIHRoZWlyIGJldHMnO1xuICAgICAgY2FzZSAnYmV0dGluZyc6XG4gICAgICAgIGlmIChwbGF5ZXIxQmV0ID4gMCAmJiBwbGF5ZXIyQmV0ID4gMCkge1xuICAgICAgICAgIGNvbnN0IG1pbmltdW1CZXQgPSBNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KTtcbiAgICAgICAgICByZXR1cm4gYEJvdGggcGxheWVycyBoYXZlIGFubm91bmNlZCBiZXRzIC0gTWluaW11bSBiZXQ6ICR7bWluaW11bUJldH0gQVBULiBUaGlzIGlzIHRoZSBhbW91bnQgdGhhdCB3aWxsIGJlIGxvY2tlZCBpbiBlc2Nyb3cuYDtcbiAgICAgICAgfSBlbHNlIGlmIChwbGF5ZXIxQmV0ID4gMCkge1xuICAgICAgICAgIHJldHVybiBgUGxheWVyIDEgYmV0OiAke3BsYXllcjFCZXR9IEFQVC4gV2FpdGluZyBmb3IgUGxheWVyIDIgdG8gYW5ub3VuY2UgYmV0LmA7XG4gICAgICAgIH0gZWxzZSBpZiAocGxheWVyMkJldCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gYFBsYXllciAyIGJldDogJHtwbGF5ZXIyQmV0fSBBUFQuIFdhaXRpbmcgZm9yIFBsYXllciAxIHRvIGFubm91bmNlIGJldC5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnV2FpdGluZyBmb3IgcGxheWVycyB0byBhbm5vdW5jZSB0aGVpciBiZXRzJztcbiAgICAgIGNhc2UgJ2JldF9hbm5vdW5jZWQnOlxuICAgICAgICByZXR1cm4gJ0JvdGggcGxheWVycyBoYXZlIGFubm91bmNlZCBiZXRzLiBMb2NrIHRoZSBlc2Nyb3cgdG8gc3RhcnQgdGhlIGdhbWUuJztcbiAgICAgIGNhc2UgJ2VzY3Jvd19sb2NrZWQnOlxuICAgICAgICByZXR1cm4gJ0VzY3JvdyBsb2NrZWQuIEdhbWUgd2lsbCBzdGFydCBzaG9ydGx5Lic7XG4gICAgICBjYXNlICdwbGF5aW5nJzpcbiAgICAgICAgcmV0dXJuIGBHYW1lIGluIHByb2dyZXNzLiBUb3RhbCBwb3Q6ICR7ZmluYWxCZXRBbW91bnR9IEFQVGA7XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBpZiAod2lubmVyID09PSAnZHJhdycpIHtcbiAgICAgICAgICByZXR1cm4gJ0dhbWUgZW5kZWQgaW4gYSBkcmF3ISBCb3RoIHBsYXllcnMgcmVjZWl2ZSB0aGVpciBiZXRzIGJhY2suJztcbiAgICAgICAgfSBlbHNlIGlmICh3aW5uZXIgPT09ICdwbGF5ZXIxJykge1xuICAgICAgICAgIHJldHVybiBgUGxheWVyIDEgd2lucyAke2ZpbmFsQmV0QW1vdW50fSBBUFQhYDtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5uZXIgPT09ICdwbGF5ZXIyJykge1xuICAgICAgICAgIHJldHVybiBgUGxheWVyIDIgd2lucyAke2ZpbmFsQmV0QW1vdW50fSBBUFQhYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0dhbWUgY29tcGxldGVkLic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJ1Vua25vd24gZ2FtZSBzdGF0ZSc7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEVzY3Jvd1N0YXR1cyA9ICgpID0+IHtcbiAgICBpZiAoZ2FtZVN0YXRlID09PSAnd2FpdGluZycgfHwgZ2FtZVN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbWluaW11bUJldCA9IHBsYXllcjFCZXQgPiAwICYmIHBsYXllcjJCZXQgPiAwID8gTWF0aC5taW4ocGxheWVyMUJldCwgcGxheWVyMkJldCkgOiAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNCBwLTMgYm9yZGVyIHJvdW5kZWQgYmctZ3JheS01MFwiPlxuICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIG1iLTJcIj5Fc2Nyb3cgU3RhdHVzPC9oMz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yXCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxwPjxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtXCI+UGxheWVyIDE6PC9zcGFuPiB7cGxheWVyMUVzY3Jvd0xvY2tlZCA/ICfinIUgTG9ja2VkJyA6ICfwn5STIFVubG9ja2VkJ308L3A+XG4gICAgICAgICAgICA8cD48c3BhbiBjbGFzc05hbWU9XCJmb250LW1lZGl1bVwiPkFubm91bmNlZCBCZXQ6PC9zcGFuPiB7cGxheWVyMUJldH0gQVBUPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8cD48c3BhbiBjbGFzc05hbWU9XCJmb250LW1lZGl1bVwiPlBsYXllciAyOjwvc3Bhbj4ge3BsYXllcjJFc2Nyb3dMb2NrZWQgPyAn4pyFIExvY2tlZCcgOiAn8J+UkyBVbmxvY2tlZCd9PC9wPlxuICAgICAgICAgICAgPHA+PHNwYW4gY2xhc3NOYW1lPVwiZm9udC1tZWRpdW1cIj5Bbm5vdW5jZWQgQmV0Ojwvc3Bhbj4ge3BsYXllcjJCZXR9IEFQVDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICB7bWluaW11bUJldCA+IDAgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMiBwLTIgYmctYmx1ZS01MCBib3JkZXIgYm9yZGVyLWJsdWUtMjAwIHJvdW5kZWRcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmx1ZS04MDAgZm9udC1tZWRpdW1cIj5cbiAgICAgICAgICAgICAgTWluaW11bSBiZXQ6IHttaW5pbXVtQmV0fSBBUFRcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW5vcm1hbCBtdC0xXCI+XG4gICAgICAgICAgICAgICAgRWFjaCBwbGF5ZXIgd2lsbCBsb2NrIHttaW5pbXVtQmV0fSBBUFQgaW4gZXNjcm93LCBmb3IgYSB0b3RhbCBwb3Qgb2Yge21pbmltdW1CZXQgKiAyfSBBUFRcbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgeyhwbGF5ZXIxRXNjcm93TG9ja2VkIHx8IHBsYXllcjJFc2Nyb3dMb2NrZWQpICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtc21cIj5cbiAgICAgICAgICAgICAge3BsYXllcjFFc2Nyb3dMb2NrZWQgJiYgcGxheWVyMkVzY3Jvd0xvY2tlZCBcbiAgICAgICAgICAgICAgICA/ICfinIUgQm90aCBwbGF5ZXJzIGhhdmUgbG9ja2VkIHRoZWlyIGVzY3Jvdy4gR2FtZSBpcyByZWFkeSB0byBzdGFydC4nXG4gICAgICAgICAgICAgICAgOiBwbGF5ZXIxRXNjcm93TG9ja2VkIFxuICAgICAgICAgICAgICAgICAgPyAn4o+zIFdhaXRpbmcgZm9yIFBsYXllciAyIHRvIGxvY2sgZXNjcm93Li4uJ1xuICAgICAgICAgICAgICAgICAgOiAn4o+zIFdhaXRpbmcgZm9yIFBsYXllciAxIHRvIGxvY2sgZXNjcm93Li4uJ31cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAge2VzY3Jvd0xvY2tlZCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC0yIHAtMiBiZy1ncmVlbi0xMDAgcm91bmRlZFwiPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmVlbi03MDBcIj7inIUgRXNjcm93IGxvY2tlZCEgRmluYWwgYW1vdW50OiB7ZmluYWxCZXRBbW91bnR9IEFQVDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTYgcC00IGJvcmRlciByb3VuZGVkIGJnLWJsdWUtNTBcIj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCBtYi0yXCI+R2FtZSBTdGF0dXM8L2gyPlxuICAgICAgPHAgY2xhc3NOYW1lPVwibWItNFwiPntnZXRHYW1lU3RhdHVzKCl9PC9wPlxuICAgICAge2dldEVzY3Jvd1N0YXR1cygpfVxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsiUmVhY3QiLCJHYW1lRGFzaGJvYXJkIiwiZ2FtZVN0YXRlIiwicGxheWVyMVdhbGxldCIsInBsYXllcjJXYWxsZXQiLCJwbGF5ZXIxQmV0IiwicGxheWVyMkJldCIsInBsYXllcjFFc2Nyb3dMb2NrZWQiLCJwbGF5ZXIyRXNjcm93TG9ja2VkIiwiZXNjcm93TG9ja2VkIiwiZmluYWxCZXRBbW91bnQiLCJ3aW5uZXIiLCJnZXRHYW1lU3RhdHVzIiwibWluaW11bUJldCIsIk1hdGgiLCJtaW4iLCJnZXRFc2Nyb3dTdGF0dXMiLCJkaXYiLCJjbGFzc05hbWUiLCJoMyIsInAiLCJzcGFuIiwiaDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/GameDashboard.tsx\n"));

/***/ }),

/***/ "./src/contracts/EscrowContractAdapter.ts":
/*!************************************************!*\
  !*** ./src/contracts/EscrowContractAdapter.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DisputeResolution: function() { return /* binding */ DisputeResolution; },\n/* harmony export */   EscrowContractAdapter: function() { return /* binding */ EscrowContractAdapter; },\n/* harmony export */   EscrowStatus: function() { return /* binding */ EscrowStatus; }\n/* harmony export */ });\n/* harmony import */ var aptos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aptos */ \"./node_modules/aptos/dist/index.mjs\");\n\nvar EscrowStatus;\n(function(EscrowStatus) {\n    EscrowStatus[EscrowStatus[\"PENDING\"] = 0] = \"PENDING\";\n    EscrowStatus[EscrowStatus[\"FUNDED\"] = 1] = \"FUNDED\";\n    EscrowStatus[EscrowStatus[\"PLAYING\"] = 2] = \"PLAYING\";\n    EscrowStatus[EscrowStatus[\"COMPLETED\"] = 3] = \"COMPLETED\";\n    EscrowStatus[EscrowStatus[\"DISPUTED\"] = 4] = \"DISPUTED\";\n    EscrowStatus[EscrowStatus[\"CANCELLED\"] = 5] = \"CANCELLED\";\n    EscrowStatus[EscrowStatus[\"TIMED_OUT\"] = 6] = \"TIMED_OUT\";\n})(EscrowStatus || (EscrowStatus = {}));\n// Class to interface with the chess escrow contract on Aptos\nclass EscrowContractAdapter {\n    // Set the escrow contract address\n    setEscrowAddress(address) {\n        this.escrowAddress = address;\n    }\n    // Get the escrow address\n    getEscrowAddress() {\n        return this.escrowAddress;\n    }\n    // Create a new escrow contract\n    async createEscrow(sender, player1Address, player2Address, minimumBet, arbiterAddress) {\n        let timeoutSeconds = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 24 * 60 * 60;\n        try {\n            // Convert APT to octas (smallest unit) - 1 APT = 10^8 Octas\n            const minimumBetOctas = (minimumBet * 100000000).toString();\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::create_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    player1Address,\n                    player2Address,\n                    minimumBetOctas,\n                    arbiterAddress,\n                    timeoutSeconds.toString()\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            if (response && response.hash) {\n                // In a real implementation, we'd need to query the chain to get the address\n                // of the newly created escrow resource. Here, we're simplifying by\n                // assuming it's the sender's address (which is where the resource is stored).\n                this.escrowAddress = sender.address;\n                return sender.address;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error creating escrow:\", error);\n            throw error;\n        }\n    }\n    // Deposit funds into the escrow\n    async deposit(sender, amount) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            // Convert APT to octas\n            const amountInOctas = (amount * 100000000).toString();\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::deposit\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    amountInOctas\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error depositing to escrow:\", error);\n            throw error;\n        }\n    }\n    // Sign to start the game\n    async signToStartGame(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::sign_to_start_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error signing to start game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game with a winner\n    async completeGame(sender, winnerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::complete_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    winnerAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game as a draw\n    async completeGameAsDraw(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::complete_game_as_draw\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game as draw:\", error);\n            throw error;\n        }\n    }\n    // Release funds to the winner or back to players in case of a draw\n    async releaseFunds(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::release_funds\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error releasing funds:\", error);\n            throw error;\n        }\n    }\n    // Raise a dispute\n    async raiseDispute(sender, reason) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::raise_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    reason\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error raising dispute:\", error);\n            throw error;\n        }\n    }\n    // Resolve a dispute (arbiter only)\n    async resolveDispute(sender, resolution, resolutionNotes) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::resolve_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    resolution.toString(),\n                    resolutionNotes\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error resolving dispute:\", error);\n            throw error;\n        }\n    }\n    // Check if game has timed out\n    async checkTimeout(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::check_timeout\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error checking timeout:\", error);\n            throw error;\n        }\n    }\n    // Cancel the escrow\n    async cancelEscrow(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::cancel_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error cancelling escrow:\", error);\n            throw error;\n        }\n    }\n    // Refund after cancellation\n    async refundAfterCancellation(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::refund_after_cancellation\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error refunding after cancellation:\", error);\n            throw error;\n        }\n    }\n    //\n    // View functions (read-only contract calls)\n    //\n    // Get escrow status\n    async getEscrowStatus() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const resource = await this.client.getAccountResource(this.escrowAddress, \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::GameEscrow\"));\n            if (resource && resource.data) {\n                return resource.data.status;\n            }\n            throw new Error(\"Could not retrieve escrow status\");\n        } catch (error) {\n            console.error(\"Error getting escrow status:\", error);\n            throw error;\n        }\n    }\n    // Get winner address\n    async getWinner() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_winner\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<address>\n            // If Some(address), it will be an object with a vector\n            if (result && result.length > 0 && result[0]) {\n                return result[0];\n            }\n            return null; // None case (draw or not set)\n        } catch (error) {\n            console.error(\"Error getting winner:\", error);\n            throw error;\n        }\n    }\n    // Get escrow balance\n    async getEscrowBalance() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_escrow_balance\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting escrow balance:\", error);\n            throw error;\n        }\n    }\n    // Check if both deposits are complete\n    async areBothDepositsComplete() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::are_both_deposits_complete\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                return Boolean(result[0]);\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error checking deposits completion:\", error);\n            throw error;\n        }\n    }\n    // Get minimum bet\n    async getMinimumBet() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_minimum_bet\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting minimum bet:\", error);\n            throw error;\n        }\n    }\n    // Get player info\n    async getPlayerInfo(playerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_player_info\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    playerAddress\n                ]\n            });\n            if (result && result.length >= 3) {\n                return {\n                    hasDeposited: Boolean(result[0]),\n                    depositAmount: Number(result[1]) / 100000000,\n                    signedGameStart: Boolean(result[2])\n                };\n            }\n            throw new Error(\"Invalid player info result\");\n        } catch (error) {\n            console.error(\"Error getting player info:\", error);\n            throw error;\n        }\n    }\n    // Get total escrowed amount\n    async getTotalEscrowedAmount() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_total_escrowed_amount\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting total escrowed amount:\", error);\n            throw error;\n        }\n    }\n    // Get game time remaining\n    async getGameTimeRemaining() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::escrow::get_game_time_remaining\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<u64>\n            if (result && result.length > 0 && result[0]) {\n                return Number(result[0]);\n            }\n            return null; // None case (game not started or not in playing state)\n        } catch (error) {\n            console.error(\"Error getting game time remaining:\", error);\n            throw error;\n        }\n    }\n    // Helper method to submit a transaction\n    async submitTransaction(sender, payload) {\n        try {\n            // For Petra and similar wallets\n            if (sender.signAndSubmitTransaction) {\n                return await sender.signAndSubmitTransaction(payload);\n            }\n            // For direct wallet API (window.aptos)\n            if ( true && window.aptos) {\n                return await window.aptos.signAndSubmitTransaction(payload);\n            }\n            throw new Error(\"No compatible wallet found\");\n        } catch (error) {\n            console.error(\"Transaction error:\", error);\n            throw error;\n        }\n    }\n    constructor(nodeUrl, moduleAddress = \"0x72e87c94e15ee1a95d23486984c9914849399a775e9ae4006b3b230c990a4cc0\"){\n        this.escrowAddress = null;\n        this.client = new aptos__WEBPACK_IMPORTED_MODULE_0__.AptosClient(nodeUrl);\n        this.moduleAddress = moduleAddress;\n    }\n}\nvar DisputeResolution;\n(function(DisputeResolution) {\n    DisputeResolution[DisputeResolution[\"DRAW\"] = 0] = \"DRAW\";\n    DisputeResolution[DisputeResolution[\"PLAYER1_WINS\"] = 1] = \"PLAYER1_WINS\";\n    DisputeResolution[DisputeResolution[\"PLAYER2_WINS\"] = 2] = \"PLAYER2_WINS\";\n    DisputeResolution[DisputeResolution[\"CANCEL\"] = 3] = \"CANCEL\";\n})(DisputeResolution || (DisputeResolution = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udHJhY3RzL0VzY3Jvd0NvbnRyYWN0QWRhcHRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlFOztVQUdyREM7Ozs7Ozs7O0dBQUFBLGlCQUFBQTtBQVVaLDZEQUE2RDtBQUN0RCxNQUFNQztJQWFYLGtDQUFrQztJQUMzQkMsaUJBQWlCQyxPQUFlLEVBQVE7UUFDN0MsSUFBSSxDQUFDQyxhQUFhLEdBQUdEO0lBQ3ZCO0lBRUEseUJBQXlCO0lBQ2xCRSxtQkFBa0M7UUFDdkMsT0FBTyxJQUFJLENBQUNELGFBQWE7SUFDM0I7SUFFQSwrQkFBK0I7SUFDL0IsTUFBYUUsYUFDWEMsTUFBVyxFQUNYQyxjQUFzQixFQUN0QkMsY0FBc0IsRUFDdEJDLFVBQWtCLEVBQ2xCQyxjQUFzQixFQUVFO1lBRHhCQyxpQkFBQUEsaUVBQXlCLEtBQUssS0FBSztRQUVuQyxJQUFJO1lBQ0YsNERBQTREO1lBQzVELE1BQU1DLGtCQUFrQixDQUFDSCxhQUFhLFNBQVEsRUFBR0ksUUFBUTtZQUV6RCxNQUFNQyxVQUFVO2dCQUNkQyxNQUFNO2dCQUNOQyxVQUFVLEdBQXNCLE9BQW5CLElBQUksQ0FBQ0MsYUFBYSxFQUFDO2dCQUNoQ0MsZ0JBQWdCLEVBQUU7Z0JBQ2xCQyxXQUFXO29CQUNUWjtvQkFDQUM7b0JBQ0FJO29CQUNBRjtvQkFDQUMsZUFBZUUsUUFBUTtpQkFDeEI7WUFDSDtZQUVBLE1BQU1PLFdBQVcsTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDZixRQUFRUTtZQUV0RCxJQUFJTSxZQUFZQSxTQUFTRSxJQUFJLEVBQUU7Z0JBQzdCLDRFQUE0RTtnQkFDNUUsbUVBQW1FO2dCQUNuRSw4RUFBOEU7Z0JBQzlFLElBQUksQ0FBQ25CLGFBQWEsR0FBR0csT0FBT0osT0FBTztnQkFDbkMsT0FBT0ksT0FBT0osT0FBTztZQUN2QjtZQUVBLE9BQU87UUFDVCxFQUFFLE9BQU9xQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE1BQU1BO1FB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Q2pDO1lBRUEsbURBQW1EO1lBQ25ELElBQUk4QyxVQUFVQSxPQUFPRSxNQUFNLEdBQUcsS0FBS0YsTUFBTSxDQUFDLEVBQUUsRUFBRTtnQkFDNUMsT0FBT0ksT0FBT0osTUFBTSxDQUFDLEVBQUU7WUFDekI7WUFFQSxPQUFPLE1BQU0sdURBQXVEO1FBQ3RFLEVBQUUsT0FBTzFCLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsd0NBQXdDO0lBQ3hDLE1BQWNGLGtCQUNaZixNQUFXLEVBQ1hRLE9BQVksRUFDRTtRQUNkLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsSUFBSVIsT0FBTzBELHdCQUF3QixFQUFFO2dCQUNuQyxPQUFPLE1BQU0xRCxPQUFPMEQsd0JBQXdCLENBQUNsRDtZQUMvQztZQUVBLHVDQUF1QztZQUN2QyxJQUFJLEtBQWtCLElBQWVtRCxPQUFPQyxLQUFLLEVBQUU7Z0JBQ2pELE9BQU8sTUFBTUQsT0FBT0MsS0FBSyxDQUFDRix3QkFBd0IsQ0FBQ2xEO1lBQ3JEO1lBRUEsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCLEVBQUUsT0FBT0osT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQyxNQUFNQTtRQUNSO0lBQ0Y7SUFyaUJBNEMsWUFDRUMsT0FBZSxFQUNmbkQsZ0JBQXdCLG9FQUFvRSxDQUM1RjthQUxNZCxnQkFBK0I7UUFNckMsSUFBSSxDQUFDeUMsTUFBTSxHQUFHLElBQUk5Qyw4Q0FBV0EsQ0FBQ3NFO1FBQzlCLElBQUksQ0FBQ25ELGFBQWEsR0FBR0E7SUFDdkI7QUFnaUJGOztVQUdZb0Q7Ozs7O0dBQUFBLHNCQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udHJhY3RzL0VzY3Jvd0NvbnRyYWN0QWRhcHRlci50cz8xMjc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwdG9zQ2xpZW50LCBUeXBlcywgVHhuQnVpbGRlclR5cGVzLCBCQ1MgfSBmcm9tICdhcHRvcyc7XG5cbi8vIEVudW0gZm9yIGNvbnRyYWN0IHN0YXRlcyBtYXRjaGluZyB0aGUgTW92ZSBjb250cmFjdFxuZXhwb3J0IGVudW0gRXNjcm93U3RhdHVzIHtcbiAgUEVORElORyA9IDAsXG4gIEZVTkRFRCA9IDEsXG4gIFBMQVlJTkcgPSAyLFxuICBDT01QTEVURUQgPSAzLFxuICBESVNQVVRFRCA9IDQsXG4gIENBTkNFTExFRCA9IDUsXG4gIFRJTUVEX09VVCA9IDZcbn1cblxuLy8gQ2xhc3MgdG8gaW50ZXJmYWNlIHdpdGggdGhlIGNoZXNzIGVzY3JvdyBjb250cmFjdCBvbiBBcHRvc1xuZXhwb3J0IGNsYXNzIEVzY3Jvd0NvbnRyYWN0QWRhcHRlciB7XG4gIHByaXZhdGUgY2xpZW50OiBBcHRvc0NsaWVudDtcbiAgcHJpdmF0ZSBtb2R1bGVBZGRyZXNzOiBzdHJpbmc7XG4gIHByaXZhdGUgZXNjcm93QWRkcmVzczogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIFxuICBjb25zdHJ1Y3RvcihcbiAgICBub2RlVXJsOiBzdHJpbmcsXG4gICAgbW9kdWxlQWRkcmVzczogc3RyaW5nID0gJzB4NzJlODdjOTRlMTVlZTFhOTVkMjM0ODY5ODRjOTkxNDg0OTM5OWE3NzVlOWFlNDAwNmIzYjIzMGM5OTBhNGNjMCcsIC8vIE5ld2x5IGRlcGxveWVkIG1vZHVsZSBhZGRyZXNzXG4gICkge1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IEFwdG9zQ2xpZW50KG5vZGVVcmwpO1xuICAgIHRoaXMubW9kdWxlQWRkcmVzcyA9IG1vZHVsZUFkZHJlc3M7XG4gIH1cbiAgXG4gIC8vIFNldCB0aGUgZXNjcm93IGNvbnRyYWN0IGFkZHJlc3NcbiAgcHVibGljIHNldEVzY3Jvd0FkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5lc2Nyb3dBZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBcbiAgLy8gR2V0IHRoZSBlc2Nyb3cgYWRkcmVzc1xuICBwdWJsaWMgZ2V0RXNjcm93QWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5lc2Nyb3dBZGRyZXNzO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgYSBuZXcgZXNjcm93IGNvbnRyYWN0XG4gIHB1YmxpYyBhc3luYyBjcmVhdGVFc2Nyb3coXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHBsYXllcjFBZGRyZXNzOiBzdHJpbmcsXG4gICAgcGxheWVyMkFkZHJlc3M6IHN0cmluZyxcbiAgICBtaW5pbXVtQmV0OiBudW1iZXIsXG4gICAgYXJiaXRlckFkZHJlc3M6IHN0cmluZyxcbiAgICB0aW1lb3V0U2Vjb25kczogbnVtYmVyID0gMjQgKiA2MCAqIDYwLCAvLyAyNCBob3VycyBpbiBzZWNvbmRzXG4gICk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IEFQVCB0byBvY3RhcyAoc21hbGxlc3QgdW5pdCkgLSAxIEFQVCA9IDEwXjggT2N0YXNcbiAgICAgIGNvbnN0IG1pbmltdW1CZXRPY3RhcyA9IChtaW5pbXVtQmV0ICogMTAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpjcmVhdGVfZXNjcm93YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICBwbGF5ZXIxQWRkcmVzcyxcbiAgICAgICAgICBwbGF5ZXIyQWRkcmVzcyxcbiAgICAgICAgICBtaW5pbXVtQmV0T2N0YXMsXG4gICAgICAgICAgYXJiaXRlckFkZHJlc3MsXG4gICAgICAgICAgdGltZW91dFNlY29uZHMudG9TdHJpbmcoKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc2VuZGVyLCBwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2gpIHtcbiAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB3ZSdkIG5lZWQgdG8gcXVlcnkgdGhlIGNoYWluIHRvIGdldCB0aGUgYWRkcmVzc1xuICAgICAgICAvLyBvZiB0aGUgbmV3bHkgY3JlYXRlZCBlc2Nyb3cgcmVzb3VyY2UuIEhlcmUsIHdlJ3JlIHNpbXBsaWZ5aW5nIGJ5XG4gICAgICAgIC8vIGFzc3VtaW5nIGl0J3MgdGhlIHNlbmRlcidzIGFkZHJlc3MgKHdoaWNoIGlzIHdoZXJlIHRoZSByZXNvdXJjZSBpcyBzdG9yZWQpLlxuICAgICAgICB0aGlzLmVzY3Jvd0FkZHJlc3MgPSBzZW5kZXIuYWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHNlbmRlci5hZGRyZXNzO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBEZXBvc2l0IGZ1bmRzIGludG8gdGhlIGVzY3Jvd1xuICBwdWJsaWMgYXN5bmMgZGVwb3NpdChcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCBBUFQgdG8gb2N0YXNcbiAgICAgIGNvbnN0IGFtb3VudEluT2N0YXMgPSAoYW1vdW50ICogMTAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpkZXBvc2l0YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIGFtb3VudEluT2N0YXNdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc2VuZGVyLCBwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICEhcmVzcG9uc2UgJiYgISFyZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVwb3NpdGluZyB0byBlc2Nyb3c6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU2lnbiB0byBzdGFydCB0aGUgZ2FtZVxuICBwdWJsaWMgYXN5bmMgc2lnblRvU3RhcnRHYW1lKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpzaWduX3RvX3N0YXJ0X2dhbWVgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaWduaW5nIHRvIHN0YXJ0IGdhbWU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ29tcGxldGUgdGhlIGdhbWUgd2l0aCBhIHdpbm5lclxuICBwdWJsaWMgYXN5bmMgY29tcGxldGVHYW1lKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICB3aW5uZXJBZGRyZXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9OjpjaGVzc19lc2Nyb3c6OmVzY3Jvdzo6Y29tcGxldGVfZ2FtZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzLCB3aW5uZXJBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbXBsZXRpbmcgZ2FtZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDb21wbGV0ZSB0aGUgZ2FtZSBhcyBhIGRyYXdcbiAgcHVibGljIGFzeW5jIGNvbXBsZXRlR2FtZUFzRHJhdyhcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9OjpjaGVzc19lc2Nyb3c6OmVzY3Jvdzo6Y29tcGxldGVfZ2FtZV9hc19kcmF3YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc2VuZGVyLCBwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICEhcmVzcG9uc2UgJiYgISFyZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29tcGxldGluZyBnYW1lIGFzIGRyYXc6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVsZWFzZSBmdW5kcyB0byB0aGUgd2lubmVyIG9yIGJhY2sgdG8gcGxheWVycyBpbiBjYXNlIG9mIGEgZHJhd1xuICBwdWJsaWMgYXN5bmMgcmVsZWFzZUZ1bmRzKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpyZWxlYXNlX2Z1bmRzYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc2VuZGVyLCBwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICEhcmVzcG9uc2UgJiYgISFyZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVsZWFzaW5nIGZ1bmRzOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFJhaXNlIGEgZGlzcHV0ZVxuICBwdWJsaWMgYXN5bmMgcmFpc2VEaXNwdXRlKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICByZWFzb246IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpyYWlzZV9kaXNwdXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHJlYXNvbl1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByYWlzaW5nIGRpc3B1dGU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVzb2x2ZSBhIGRpc3B1dGUgKGFyYml0ZXIgb25seSlcbiAgcHVibGljIGFzeW5jIHJlc29sdmVEaXNwdXRlKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2UgKGFyYml0ZXIpXG4gICAgcmVzb2x1dGlvbjogbnVtYmVyLCAvLyAwPWRyYXcsIDE9cGxheWVyMSB3aW5zLCAyPXBsYXllcjIgd2lucywgMz1jYW5jZWxcbiAgICByZXNvbHV0aW9uTm90ZXM6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpyZXNvbHZlX2Rpc3B1dGVgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzcywgcmVzb2x1dGlvbi50b1N0cmluZygpLCByZXNvbHV0aW9uTm90ZXNdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3VibWl0VHJhbnNhY3Rpb24oc2VuZGVyLCBwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICEhcmVzcG9uc2UgJiYgISFyZXNwb25zZS5oYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzb2x2aW5nIGRpc3B1dGU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgZ2FtZSBoYXMgdGltZWQgb3V0XG4gIHB1YmxpYyBhc3luYyBjaGVja1RpbWVvdXQoXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6Y2hlc3NfZXNjcm93Ojplc2Nyb3c6OmNoZWNrX3RpbWVvdXRgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyB0aW1lb3V0OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENhbmNlbCB0aGUgZXNjcm93XG4gIHB1YmxpYyBhc3luYyBjYW5jZWxFc2Nyb3coXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6Y2hlc3NfZXNjcm93Ojplc2Nyb3c6OmNhbmNlbF9lc2Nyb3dgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYW5jZWxsaW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZWZ1bmQgYWZ0ZXIgY2FuY2VsbGF0aW9uXG4gIHB1YmxpYyBhc3luYyByZWZ1bmRBZnRlckNhbmNlbGxhdGlvbihcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9OjpjaGVzc19lc2Nyb3c6OmVzY3Jvdzo6cmVmdW5kX2FmdGVyX2NhbmNlbGxhdGlvbmAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlZnVuZGluZyBhZnRlciBjYW5jZWxsYXRpb246XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy9cbiAgLy8gVmlldyBmdW5jdGlvbnMgKHJlYWQtb25seSBjb250cmFjdCBjYWxscylcbiAgLy9cbiAgXG4gIC8vIEdldCBlc2Nyb3cgc3RhdHVzXG4gIHB1YmxpYyBhc3luYyBnZXRFc2Nyb3dTdGF0dXMoKTogUHJvbWlzZTxFc2Nyb3dTdGF0dXM+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0QWNjb3VudFJlc291cmNlKFxuICAgICAgICB0aGlzLmVzY3Jvd0FkZHJlc3MsXG4gICAgICAgIGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpHYW1lRXNjcm93YFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlLmRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5kYXRhIGFzIGFueSkuc3RhdHVzIGFzIEVzY3Jvd1N0YXR1cztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJldHJpZXZlIGVzY3JvdyBzdGF0dXNcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIGVzY3JvdyBzdGF0dXM6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHdpbm5lciBhZGRyZXNzXG4gIHB1YmxpYyBhc3luYyBnZXRXaW5uZXIoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpnZXRfd2lubmVyYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IHdpdGggdGhlIE9wdGlvbjxhZGRyZXNzPlxuICAgICAgLy8gSWYgU29tZShhZGRyZXNzKSwgaXQgd2lsbCBiZSBhbiBvYmplY3Qgd2l0aCBhIHZlY3RvclxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXSBhcyBzdHJpbmc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsOyAvLyBOb25lIGNhc2UgKGRyYXcgb3Igbm90IHNldClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgd2lubmVyOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEdldCBlc2Nyb3cgYmFsYW5jZVxuICBwdWJsaWMgYXN5bmMgZ2V0RXNjcm93QmFsYW5jZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9OjpjaGVzc19lc2Nyb3c6OmVzY3Jvdzo6Z2V0X2VzY3Jvd19iYWxhbmNlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDb252ZXJ0IG9jdGFzIHRvIEFQVFxuICAgICAgICByZXR1cm4gTnVtYmVyKHJlc3VsdFswXSkgLyAxMDAwMDAwMDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBlc2Nyb3cgYmFsYW5jZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDaGVjayBpZiBib3RoIGRlcG9zaXRzIGFyZSBjb21wbGV0ZVxuICBwdWJsaWMgYXN5bmMgYXJlQm90aERlcG9zaXRzQ29tcGxldGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjphcmVfYm90aF9kZXBvc2l0c19jb21wbGV0ZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocmVzdWx0WzBdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgZGVwb3NpdHMgY29tcGxldGlvbjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgbWluaW11bSBiZXRcbiAgcHVibGljIGFzeW5jIGdldE1pbmltdW1CZXQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnZpZXcoe1xuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6Y2hlc3NfZXNjcm93Ojplc2Nyb3c6OmdldF9taW5pbXVtX2JldGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHRbMF0pIC8gMTAwMDAwMDAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgbWluaW11bSBiZXQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHBsYXllciBpbmZvXG4gIHB1YmxpYyBhc3luYyBnZXRQbGF5ZXJJbmZvKHBsYXllckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGhhc0RlcG9zaXRlZDogYm9vbGVhbjtcbiAgICBkZXBvc2l0QW1vdW50OiBudW1iZXI7XG4gICAgc2lnbmVkR2FtZVN0YXJ0OiBib29sZWFuO1xuICB9PiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpnZXRfcGxheWVyX2luZm9gLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzcywgcGxheWVyQWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPj0gMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0RlcG9zaXRlZDogQm9vbGVhbihyZXN1bHRbMF0pLFxuICAgICAgICAgIGRlcG9zaXRBbW91bnQ6IE51bWJlcihyZXN1bHRbMV0pIC8gMTAwMDAwMDAwLCAvLyBDb252ZXJ0IG9jdGFzIHRvIEFQVFxuICAgICAgICAgIHNpZ25lZEdhbWVTdGFydDogQm9vbGVhbihyZXN1bHRbMl0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGxheWVyIGluZm8gcmVzdWx0XCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBwbGF5ZXIgaW5mbzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgdG90YWwgZXNjcm93ZWQgYW1vdW50XG4gIHB1YmxpYyBhc3luYyBnZXRUb3RhbEVzY3Jvd2VkQW1vdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmNoZXNzX2VzY3Jvdzo6ZXNjcm93OjpnZXRfdG90YWxfZXNjcm93ZWRfYW1vdW50YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDb252ZXJ0IG9jdGFzIHRvIEFQVFxuICAgICAgICByZXR1cm4gTnVtYmVyKHJlc3VsdFswXSkgLyAxMDAwMDAwMDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyB0b3RhbCBlc2Nyb3dlZCBhbW91bnQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IGdhbWUgdGltZSByZW1haW5pbmdcbiAgcHVibGljIGFzeW5jIGdldEdhbWVUaW1lUmVtYWluaW5nKCk6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9OjpjaGVzc19lc2Nyb3c6OmVzY3Jvdzo6Z2V0X2dhbWVfdGltZV9yZW1haW5pbmdgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgd2l0aCB0aGUgT3B0aW9uPHU2ND5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0WzBdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vbmUgY2FzZSAoZ2FtZSBub3Qgc3RhcnRlZCBvciBub3QgaW4gcGxheWluZyBzdGF0ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZ2FtZSB0aW1lIHJlbWFpbmluZzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIHN1Ym1pdCBhIHRyYW5zYWN0aW9uXG4gIHByaXZhdGUgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24oXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHBheWxvYWQ6IGFueVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3IgUGV0cmEgYW5kIHNpbWlsYXIgd2FsbGV0c1xuICAgICAgaWYgKHNlbmRlci5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmRlci5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBkaXJlY3Qgd2FsbGV0IEFQSSAod2luZG93LmFwdG9zKVxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hcHRvcykge1xuICAgICAgICByZXR1cm4gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tcGF0aWJsZSB3YWxsZXQgZm91bmRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcmFuc2FjdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBhbiBlbnVtIGZvciBkaXNwdXRlIHJlc29sdXRpb24gY29kZXNcbmV4cG9ydCBlbnVtIERpc3B1dGVSZXNvbHV0aW9uIHtcbiAgRFJBVyA9IDAsXG4gIFBMQVlFUjFfV0lOUyA9IDEsXG4gIFBMQVlFUjJfV0lOUyA9IDIsXG4gIENBTkNFTCA9IDNcbn0gIl0sIm5hbWVzIjpbIkFwdG9zQ2xpZW50IiwiRXNjcm93U3RhdHVzIiwiRXNjcm93Q29udHJhY3RBZGFwdGVyIiwic2V0RXNjcm93QWRkcmVzcyIsImFkZHJlc3MiLCJlc2Nyb3dBZGRyZXNzIiwiZ2V0RXNjcm93QWRkcmVzcyIsImNyZWF0ZUVzY3JvdyIsInNlbmRlciIsInBsYXllcjFBZGRyZXNzIiwicGxheWVyMkFkZHJlc3MiLCJtaW5pbXVtQmV0IiwiYXJiaXRlckFkZHJlc3MiLCJ0aW1lb3V0U2Vjb25kcyIsIm1pbmltdW1CZXRPY3RhcyIsInRvU3RyaW5nIiwicGF5bG9hZCIsInR5cGUiLCJmdW5jdGlvbiIsIm1vZHVsZUFkZHJlc3MiLCJ0eXBlX2FyZ3VtZW50cyIsImFyZ3VtZW50cyIsInJlc3BvbnNlIiwic3VibWl0VHJhbnNhY3Rpb24iLCJoYXNoIiwiZXJyb3IiLCJjb25zb2xlIiwiZGVwb3NpdCIsImFtb3VudCIsIkVycm9yIiwiYW1vdW50SW5PY3RhcyIsInNpZ25Ub1N0YXJ0R2FtZSIsImNvbXBsZXRlR2FtZSIsIndpbm5lckFkZHJlc3MiLCJjb21wbGV0ZUdhbWVBc0RyYXciLCJyZWxlYXNlRnVuZHMiLCJyYWlzZURpc3B1dGUiLCJyZWFzb24iLCJyZXNvbHZlRGlzcHV0ZSIsInJlc29sdXRpb24iLCJyZXNvbHV0aW9uTm90ZXMiLCJjaGVja1RpbWVvdXQiLCJjYW5jZWxFc2Nyb3ciLCJyZWZ1bmRBZnRlckNhbmNlbGxhdGlvbiIsImdldEVzY3Jvd1N0YXR1cyIsInJlc291cmNlIiwiY2xpZW50IiwiZ2V0QWNjb3VudFJlc291cmNlIiwiZGF0YSIsInN0YXR1cyIsImdldFdpbm5lciIsInJlc3VsdCIsInZpZXciLCJsZW5ndGgiLCJnZXRFc2Nyb3dCYWxhbmNlIiwiTnVtYmVyIiwiYXJlQm90aERlcG9zaXRzQ29tcGxldGUiLCJCb29sZWFuIiwiZ2V0TWluaW11bUJldCIsImdldFBsYXllckluZm8iLCJwbGF5ZXJBZGRyZXNzIiwiaGFzRGVwb3NpdGVkIiwiZGVwb3NpdEFtb3VudCIsInNpZ25lZEdhbWVTdGFydCIsImdldFRvdGFsRXNjcm93ZWRBbW91bnQiLCJnZXRHYW1lVGltZVJlbWFpbmluZyIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsIndpbmRvdyIsImFwdG9zIiwiY29uc3RydWN0b3IiLCJub2RlVXJsIiwiRGlzcHV0ZVJlc29sdXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/contracts/EscrowContractAdapter.ts\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_chessboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-chessboard */ \"./node_modules/react-chessboard/dist/index.esm.js\");\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n/* harmony import */ var _components_GameDashboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/GameDashboard */ \"./src/components/GameDashboard.tsx\");\n/* harmony import */ var _aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @aptos-labs/wallet-adapter-react */ \"./node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs\");\n/* harmony import */ var aptos__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aptos */ \"./node_modules/aptos/dist/index.mjs\");\n/* harmony import */ var _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../contracts/EscrowContractAdapter */ \"./src/contracts/EscrowContractAdapter.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nfunction Home() {\n    _s();\n    // Game state\n    const [game, setGame] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new chess_js__WEBPACK_IMPORTED_MODULE_4__.Chess());\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"waiting\");\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Aptos client for blockchain interactions\n    const [client] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new aptos__WEBPACK_IMPORTED_MODULE_7__.AptosClient(\"https://fullnode.testnet.aptoslabs.com/v1\"));\n    // Player wallets and bets\n    const [player1Wallet, setPlayer1Wallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [player2Wallet, setPlayer2Wallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [player1Bet, setPlayer1Bet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [player2Bet, setPlayer2Bet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [finalBetAmount, setFinalBetAmount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Game management\n    const [aiEnabled, setAiEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Escrow adapter for blockchain interactions\n    const escrowAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowContractAdapter(\"https://fullnode.testnet.aptoslabs.com/v1\", \"0x1\" // Default module address, would be replaced with actual deployed address\n        ), []);\n    // Add escrow tracking properties \n    const [useSimulationMode, setUseSimulationMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true); // Default to true since we're not really deploying\n    const [escrowLocked, setEscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [player1EscrowLocked, setPlayer1EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [player2EscrowLocked, setPlayer2EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentPlayer, setCurrentPlayer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"white\");\n    const [activePlayerWallet, setActivePlayerWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1); // Which player is connecting wallet\n    // New state for escrow contract data\n    const [escrowAddress, setEscrowAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [escrowStatus, setEscrowStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus.PENDING);\n    const [escrowBalance, setEscrowBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Wallet adapter\n    const { connect, disconnect, account, connected, signAndSubmitTransaction } = (0,_aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_6__.useWallet)();\n    // Add the winner state to the Home component\n    const [winner, setWinner] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Get wallet balance\n    const getAccountBalance = async (address)=>{\n        try {\n            const resources = await client.getAccountResources(address);\n            const aptosCoinResource = resources.find((r)=>r.type === \"0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>\");\n            if (aptosCoinResource) {\n                const balance = aptosCoinResource.data.coin.value;\n                // Convert from octas (10^8) to APT\n                return Number(balance) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting account balance:\", error);\n            return 0;\n        }\n    };\n    // Initialize escrow when both wallets are connected\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (player1Wallet && player2Wallet && !escrowAddress && !isLoading) {\n            console.log(\"Both wallets connected, initializing escrow\");\n            // In simulation mode, create a simulated escrow automatically\n            if (useSimulationMode) {\n                createSimulatedEscrow();\n            }\n        // In real mode, don't auto-initialize to avoid unexpected reconnection prompts\n        // User will need to click the Initialize Escrow button\n        }\n    }, [\n        player1Wallet,\n        player2Wallet,\n        escrowAddress,\n        isLoading,\n        useSimulationMode\n    ]);\n    // Function to reset wallet connections - moved to the top to fix reference error\n    const resetWalletConnections = async ()=>{\n        try {\n            setIsLoading(true);\n            console.log(\"Resetting wallet connections...\");\n            // Disconnect only if connected\n            if (connected) {\n                await disconnect();\n            }\n            // Reset state\n            setPlayer1Wallet(null);\n            setPlayer2Wallet(null);\n            setPlayer1Bet(0);\n            setPlayer2Bet(0);\n            setFinalBetAmount(0);\n            setEscrowLocked(false);\n            setPlayer1EscrowLocked(false);\n            setPlayer2EscrowLocked(false);\n            setEscrowAddress(null);\n            console.log(\"Wallet connections reset successfully\");\n        } catch (error) {\n            console.error(\"Error resetting wallet connections:\", error);\n            setError(\"Failed to reset wallet connections. Please refresh the page.\");\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Function to initialize the escrow contract\n    const initializeEscrow = async ()=>{\n        if (!player1Wallet || !player2Wallet) {\n            console.error(\"Cannot initialize escrow: both players must be connected\");\n            setError(\"Both players must be connected to initialize the escrow\");\n            return;\n        }\n        try {\n            setIsLoading(true);\n            console.log(\"Initializing escrow contract\");\n            // In simulation mode, just set a fake address\n            if (useSimulationMode) {\n                try {\n                    const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                    console.log(\"Creating simulated escrow with address:\", simulatedAddress);\n                    // Set the address in the adapter\n                    escrowAdapter.setEscrowAddress(simulatedAddress);\n                    // Set the address in our component state\n                    setEscrowAddress(simulatedAddress);\n                    console.log(\"Simulated escrow initialized with address:\", simulatedAddress);\n                    // Add a small delay to ensure state updates\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                    // Double check that the address was set\n                    if (!escrowAddress) {\n                        console.log(\"Escrow address state not updated yet, but continuing...\");\n                    }\n                    setIsLoading(false);\n                    return;\n                } catch (simError) {\n                    console.error(\"Error in simulation mode:\", simError);\n                // Continue to try real mode, but log the error\n                }\n            }\n            // Try connecting to Player 1's wallet\n            console.log(\"Attempting to connect to Player 1's wallet for escrow initialization\");\n            // If Player 1 is connected through wallet adapter, make sure we're using that\n            if (account && account.address && account.address.toString() === player1Wallet.address) {\n                console.log(\"Using connected wallet adapter for escrow creation\");\n                const createEscrowResult = await escrowAdapter.createEscrow({\n                    signAndSubmitTransaction: signAndSubmitTransaction\n                }, player1Wallet.address, player2Wallet.address, 0.1, player1Wallet.address, 24 * 60 * 60 // 24 hour timeout\n                );\n                if (createEscrowResult) {\n                    setEscrowAddress(createEscrowResult);\n                    console.log(\"Escrow contract created with address:\", createEscrowResult);\n                    setIsLoading(false);\n                    return;\n                }\n            }\n            // If adapter didn't work, try the direct window.aptos method\n            if (window.aptos) {\n                try {\n                    console.log(\"Connecting to wallet via window.aptos for escrow creation\");\n                    // Check if already connected to the right wallet\n                    let currentAccount = null;\n                    try {\n                        currentAccount = await window.aptos.account();\n                    } catch (e) {\n                        console.log(\"No account currently connected, will need to connect\");\n                    }\n                    // Only show prompt and connect if not already connected to Player 1's wallet\n                    if (!currentAccount || currentAccount.address !== player1Wallet.address) {\n                        console.log(\"Not connected to Player 1's wallet, requesting connection\");\n                        window.alert(\"Please make sure Player 1's wallet is selected in your Petra extension to initialize the escrow.\");\n                        await window.aptos.connect();\n                    } else {\n                        console.log(\"Already connected to Player 1's wallet, proceeding without reconnection\");\n                    }\n                    // Ensure it's Player 1's wallet\n                    const account = await window.aptos.account();\n                    if (account && account.address === player1Wallet.address) {\n                        console.log(\"Connected to correct wallet, creating escrow\");\n                        const createEscrowResult = await escrowAdapter.createEscrow(window.aptos, player1Wallet.address, player2Wallet.address, 0.1, player1Wallet.address, 24 * 60 * 60 // 24 hour timeout\n                        );\n                        if (createEscrowResult) {\n                            setEscrowAddress(createEscrowResult);\n                            console.log(\"Escrow contract created with address:\", createEscrowResult);\n                            setIsLoading(false);\n                            return;\n                        }\n                    } else {\n                        console.warn(\"Connected to wrong wallet address:\", account === null || account === void 0 ? void 0 : account.address);\n                        throw new Error(\"Wrong wallet connected. Expected \".concat(player1Wallet.address, \" but got \").concat(account === null || account === void 0 ? void 0 : account.address, \". Please make sure Player 1's wallet is selected.\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error with direct Petra connection:\", error);\n                    throw error;\n                }\n            } else {\n                throw new Error(\"Petra wallet extension not found. Please install Petra and reload the page.\");\n            }\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            setError(error.message || \"Failed to initialize escrow\");\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Remove the complex wallet address checking and replace ensureCorrectWalletConnected with a simpler version\n    async function ensureCorrectWalletConnected(playerNumber) {\n        console.log(\"Ensuring wallet for Player \".concat(playerNumber, \" is connected\"));\n        // If in simulation mode, just return true\n        if (useSimulationMode) {\n            console.log(\"Simulation mode: Assuming wallet is connected\");\n            return true;\n        }\n        // For Player 1 or Player 2, simply try to connect via window.aptos\n        try {\n            console.log(\"Attempting to connect to Player \".concat(playerNumber, \"'s wallet\"));\n            // Prompt user to switch to the correct wallet\n            window.alert(\"Please make sure Player \".concat(playerNumber, \"'s wallet is selected in your Petra extension.\"));\n            const response = await window.aptos.connect();\n            if (response && response.address) {\n                console.log(\"Connected to wallet with address: \".concat(response.address));\n                return true;\n            } else {\n                console.error(\"Failed to get wallet address\");\n                return false;\n            }\n        } catch (error) {\n            console.error(\"Error connecting to Player \".concat(playerNumber, \"'s wallet:\"), error);\n            return false;\n        }\n    }\n    // Update the connectPlayerWallet function to show correct prompts based on player number\n    const connectPlayerWallet = async (playerNumber)=>{\n        // Prevent multiple connection attempts\n        if (isLoading) {\n            console.log(\"Connection already in progress, ignoring duplicate request\");\n            return;\n        }\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting wallet for Player \".concat(playerNumber, \"...\"));\n            // Make sure there's a global aptos object\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension from https://petra.app/ and refresh the page.\");\n                setIsLoading(false);\n                return;\n            }\n            // Check if this player's wallet is already connected\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (playerWallet) {\n                console.log(\"Player \".concat(playerNumber, \"'s wallet is already connected:\"), playerWallet.address);\n                setIsLoading(false);\n                return;\n            }\n            // Show the correct prompt based on player number\n            window.alert(\"Please make sure Player \".concat(playerNumber, \"'s wallet is selected in your Petra extension.\"));\n            // Direct connection approach - simplest and most reliable\n            try {\n                const response = await window.aptos.connect();\n                console.log(\"Wallet connection response for Player \".concat(playerNumber, \":\"), response);\n                if (response && response.address) {\n                    console.log(\"Connected to wallet for Player \".concat(playerNumber, \":\"), response.address);\n                    // Check if this wallet is already connected as the other player\n                    const otherPlayerWallet = playerNumber === 1 ? player2Wallet : player1Wallet;\n                    if (otherPlayerWallet && otherPlayerWallet.address === response.address) {\n                        const confirmUse = window.confirm(\"WARNING: This wallet (\".concat(response.address.substring(0, 6), \"...\").concat(response.address.substring(response.address.length - 4), \") is already connected as Player \").concat(playerNumber === 1 ? \"2\" : \"1\", \".\\n\\n\") + \"Using the same wallet for both players is NOT recommended for real games.\\n\\n\" + \"Do you want to continue using this wallet for both players?\");\n                        if (!confirmUse) {\n                            throw new Error(\"Please connect a different wallet for Player \".concat(playerNumber, \". Go to your Petra extension and switch accounts first.\"));\n                        }\n                        console.log(\"User confirmed using the same wallet for both players: \".concat(response.address));\n                    }\n                    // Get wallet balance\n                    const balance = await getAccountBalance(response.address);\n                    // Set the wallet in state\n                    const walletInfo = {\n                        address: response.address,\n                        balance: balance\n                    };\n                    if (playerNumber === 1) {\n                        setPlayer1Wallet(walletInfo);\n                    } else {\n                        setPlayer2Wallet(walletInfo);\n                    }\n                    console.log(\"Successfully set Player \".concat(playerNumber, \"'s wallet\"));\n                } else {\n                    throw new Error(\"Failed to get wallet address\");\n                }\n            } catch (error) {\n                console.error(\"Error connecting wallet for Player \".concat(playerNumber, \":\"), error);\n                throw new Error(\"Failed to connect wallet: \".concat(error.message || \"Unknown error\"));\n            }\n        } catch (error) {\n            console.error(\"Error in wallet connection for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to connect wallet for Player \".concat(playerNumber));\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Add a function to set the escrow wallet - this would be a third wallet\n    const connectEscrowWallet = async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting escrow wallet...\");\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension.\");\n                setIsLoading(false);\n                return;\n            }\n            // Prompt to select the escrow wallet\n            window.alert(\"Please make sure your ESCROW wallet is selected in your Petra extension.\");\n            const response = await window.aptos.connect();\n            console.log(\"Escrow wallet connection response:\", response);\n            if (response && response.address) {\n                console.log(\"Connected to escrow wallet:\", response.address);\n                // Set the escrow address in the adapter\n                escrowAdapter.setEscrowAddress(response.address);\n                // Set the address in component state\n                setEscrowAddress(response.address);\n                console.log(\"Escrow wallet set successfully:\", response.address);\n            } else {\n                throw new Error(\"Failed to get escrow wallet address\");\n            }\n        } catch (error) {\n            console.error(\"Error connecting escrow wallet:\", error);\n            setError(error.message || \"Failed to connect escrow wallet\");\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Update payWinner function to use the escrow wallet to pay the winner\n    async function payWinner(winner) {\n        try {\n            console.log(\"Paying winner: \".concat(winner));\n            // Only proceed if not in simulation mode and escrow is locked\n            if (!useSimulationMode && escrowLocked && escrowAddress) {\n                // Handle draw case\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - returning funds to both players\");\n                    // For a draw, return original bet amounts to each player\n                    // Connect to escrow wallet first\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to return funds.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Return funds to Player 1\n                    if (player1Wallet) {\n                        console.log(\"Returning \".concat(player1Bet, \" APT to Player 1 from escrow\"));\n                        const payload1 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player1Wallet.address,\n                                Math.floor(player1Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse1 = await window.aptos.signAndSubmitTransaction(payload1);\n                        console.log(\"Player 1 refund transaction:\", txResponse1);\n                    }\n                    // Return funds to Player 2\n                    if (player2Wallet) {\n                        console.log(\"Returning \".concat(player2Bet, \" APT to Player 2 from escrow\"));\n                        const payload2 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player2Wallet.address,\n                                Math.floor(player2Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse2 = await window.aptos.signAndSubmitTransaction(payload2);\n                        console.log(\"Player 2 refund transaction:\", txResponse2);\n                    }\n                } else {\n                    const winnerWallet = winner === \"player1\" ? player1Wallet : player2Wallet;\n                    if (!winnerWallet) {\n                        throw new Error(\"Winner wallet not found\");\n                    }\n                    console.log(\"Transferring \".concat(finalBetAmount, \" APT to winner (\").concat(winnerWallet.address, \")\"));\n                    // Connect to escrow wallet\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to pay the winner.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Transfer all funds from escrow to winner\n                    const payload = {\n                        type: \"entry_function_payload\",\n                        function: \"0x1::coin::transfer\",\n                        type_arguments: [\n                            \"0x1::aptos_coin::AptosCoin\"\n                        ],\n                        arguments: [\n                            winnerWallet.address,\n                            Math.floor(finalBetAmount * 100000000).toString()\n                        ]\n                    };\n                    const txResponse = await window.aptos.signAndSubmitTransaction(payload);\n                    console.log(\"Winner payment transaction:\", txResponse);\n                }\n                // Update player balances after transfers\n                if (player1Wallet) {\n                    const newBalance1 = await getAccountBalance(player1Wallet.address);\n                    setPlayer1Wallet({\n                        ...player1Wallet,\n                        balance: newBalance1\n                    });\n                }\n                if (player2Wallet) {\n                    const newBalance2 = await getAccountBalance(player2Wallet.address);\n                    setPlayer2Wallet({\n                        ...player2Wallet,\n                        balance: newBalance2\n                    });\n                }\n            } else if (useSimulationMode) {\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - both players receive their bets back (simulation)\");\n                    if (player1Wallet) {\n                        setPlayer1Wallet({\n                            ...player1Wallet,\n                            balance: player1Wallet.balance + player1Bet\n                        });\n                    }\n                    if (player2Wallet) {\n                        setPlayer2Wallet({\n                            ...player2Wallet,\n                            balance: player2Wallet.balance + player2Bet\n                        });\n                    }\n                } else {\n                    const payoutAmount = finalBetAmount;\n                    if (winner === \"player1\" && player1Wallet) {\n                        console.log(\"Updating Player 1 wallet balance: +\".concat(payoutAmount, \" APT (simulation)\"));\n                        setPlayer1Wallet({\n                            ...player1Wallet,\n                            balance: player1Wallet.balance + payoutAmount\n                        });\n                    } else if (winner === \"player2\" && player2Wallet) {\n                        console.log(\"Updating Player 2 wallet balance: +\".concat(payoutAmount, \" APT (simulation)\"));\n                        setPlayer2Wallet({\n                            ...player2Wallet,\n                            balance: player2Wallet.balance + payoutAmount\n                        });\n                    }\n                }\n            }\n            console.log(\"Winner payment completed successfully\");\n        } catch (error) {\n            console.error(\"Error paying winner:\", error);\n            setError(error.message || \"Failed to pay winner\");\n        }\n    }\n    // Reset game state\n    function resetGameState() {\n        console.log(\"Resetting game state\");\n        setGameState(\"waiting\");\n        setPlayer1Bet(0);\n        setPlayer2Bet(0);\n        setPlayer1EscrowLocked(false);\n        setPlayer2EscrowLocked(false);\n        setEscrowLocked(false);\n        setFinalBetAmount(0);\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus.PENDING);\n        setEscrowBalance(0);\n        setWinner(null);\n        // Reset the game board\n        setGame(new chess_js__WEBPACK_IMPORTED_MODULE_4__.Chess());\n        // Reset current player\n        setCurrentPlayer(\"white\");\n        console.log(\"Game state reset complete\");\n    }\n    // Check if both wallets are connected\n    const bothWalletsConnected = player1Wallet && player2Wallet;\n    // Check if it's the betting phase and which player needs to bet\n    const needsPlayer1Bet = gameState === \"betting\" && player1Bet === 0 && player2Bet > 0;\n    const needsPlayer2Bet = gameState === \"betting\" && player2Bet === 0 && player1Bet > 0;\n    // Add helper function to explain wallet connection steps\n    const getWalletConnectionInstructions = (playerNumber)=>{\n        if (playerNumber === 1) {\n            return \"Connect your first wallet by clicking the button below.\";\n        } else {\n            return \"To connect Player 2's wallet:\\n1. Open your Petra wallet extension\\n2. Switch to a DIFFERENT wallet account (important!)\\n3. Click 'Connect Player 2 Wallet'\\n\\nUsing the same wallet for both players is not recommended for real games.\";\n        }\n    };\n    // Force disconnect before connecting Player 2\n    const connectPlayer2Wallet = async ()=>{\n        // First try to disconnect any connected wallet\n        if (connected) {\n            console.log(\"Force disconnecting before connecting Player 2's wallet\");\n            try {\n                await disconnect();\n                // Wait for disconnection to complete\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n            } catch (e) {\n                console.warn(\"Error during forced disconnection:\", e);\n            }\n        }\n        // Check if Player 1 wallet is connected and provide specific instructions\n        if (player1Wallet) {\n            const walletPreface = player1Wallet.address.substring(0, 6) + \"...\" + player1Wallet.address.substring(player1Wallet.address.length - 4);\n            // Show detailed instructions for switching wallets\n            window.alert(\"IMPORTANT: Before connecting Player 2's wallet\\n\\n\" + \"1. Open your Petra wallet extension\\n\" + \"2. Currently, Player 1 is using wallet: \".concat(walletPreface, \"\\n\") + \"3. Switch to a DIFFERENT account in your Petra wallet\\n\" + \"4. Then click OK to continue connecting\");\n        }\n        // Now try to connect Player 2's wallet\n        connectPlayerWallet(2);\n    };\n    // Early return for error state\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container mx-auto px-4 py-8\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 bg-red-50 border border-red-200 rounded-lg max-w-lg mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-bold text-red-800 mb-2\",\n                        children: \"Error\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 644,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-red-600 mb-4\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 645,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setError(null),\n                                className: \"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\",\n                                children: \"Dismiss\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 647,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: resetWalletConnections,\n                                className: \"px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700\",\n                                children: \"Reset Wallet Connections\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 653,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 646,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 643,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n            lineNumber: 642,\n            columnNumber: 7\n        }, this);\n    }\n    // Add function to announce bets for both players and calculate minimum\n    const announceUnifiedBet = async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Announcing unified bet - Player 1: \".concat(player1Bet, \" APT, Player 2: \").concat(player2Bet, \" APT\"));\n            // Validate both players have wallets connected\n            if (!player1Wallet || !player2Wallet) {\n                throw new Error(\"Both players must connect their wallets before announcing bets\");\n            }\n            // Validate bet amounts\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must enter valid bet amounts (greater than 0)\");\n            }\n            // Check sufficient funds\n            if (player1Wallet.balance < player1Bet) {\n                throw new Error(\"Player 1 has insufficient funds. Available: \".concat(player1Wallet.balance, \" APT, Bet: \").concat(player1Bet, \" APT\"));\n            }\n            if (player2Wallet.balance < player2Bet) {\n                throw new Error(\"Player 2 has insufficient funds. Available: \".concat(player2Wallet.balance, \" APT, Bet: \").concat(player2Bet, \" APT\"));\n            }\n            // Calculate minimum bet\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Calculated minimum bet: \".concat(minimumBet, \" APT\"));\n            // Set final bet amount (pot)\n            setFinalBetAmount(minimumBet * 2);\n            // Update game state\n            setGameState(\"betting\");\n            console.log(\"Unified bet announcement successful\");\n        } catch (error) {\n            console.error(\"Error announcing unified bet:\", error);\n            setError(error.message || \"Failed to announce unified bet\");\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Lock the escrow by transferring the minimum bet amount from a specific player\n    async function lockEscrow(playerNumber) {\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Starting escrow locking process for Player \".concat(playerNumber));\n            console.log(\"Current escrow lock status: Player 1: \".concat(player1EscrowLocked, \", Player 2: \").concat(player2EscrowLocked));\n            // Verify both players have placed bets\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must announce bets before locking escrow\");\n            }\n            // Determine the minimum bet amount (this is what will be deducted)\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Minimum bet amount between players: \".concat(minimumBet, \" APT\"));\n            // Get player wallet\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (!playerWallet) {\n                throw new Error(\"Player \".concat(playerNumber, \" wallet not connected\"));\n            }\n            // In simulation mode, create an escrow if not yet initialized\n            if (useSimulationMode && !escrowAddress) {\n                console.log(\"No escrow initialized yet, but in simulation mode. Creating escrow now...\");\n                const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                escrowAdapter.setEscrowAddress(simulatedAddress);\n                setEscrowAddress(simulatedAddress);\n                console.log(\"Auto-created simulated escrow with address:\", simulatedAddress);\n                // Brief pause to let state update\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            // Make sure an escrow address is set\n            if (!escrowAddress) {\n                throw new Error(\"No escrow wallet connected. Please connect the escrow wallet first.\");\n            }\n            console.log(\"Depositing \".concat(minimumBet, \" APT to escrow contract from Player \").concat(playerNumber));\n            // Use simulation mode if enabled\n            if (useSimulationMode) {\n                console.log(\"Using simulation mode - no actual transfer will occur\");\n                // Simulate deposit\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                    setPlayer1Wallet({\n                        ...playerWallet,\n                        balance: playerWallet.balance - minimumBet\n                    });\n                } else {\n                    setPlayer2EscrowLocked(true);\n                    setPlayer2Wallet({\n                        ...playerWallet,\n                        balance: playerWallet.balance - minimumBet\n                    });\n                }\n                console.log(\"Simulated escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance in simulation mode\n                setEscrowBalance((prevBalance)=>prevBalance + minimumBet);\n            } else {\n                // Real deposit by transferring funds to the escrow address\n                // Make sure the player's wallet is connected\n                const isWalletConnected = await ensureCorrectWalletConnected(playerNumber);\n                if (!isWalletConnected) {\n                    throw new Error(\"Please connect the wallet for Player \".concat(playerNumber, \" to continue\"));\n                }\n                // Direct transfer to escrow address - using minimumBet instead of player's full bet\n                const transferSuccess = await transferToEscrow(playerNumber, minimumBet, escrowAddress);\n                if (!transferSuccess) {\n                    throw new Error(\"Failed to transfer funds to escrow for Player \".concat(playerNumber));\n                }\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                    // Refresh balance\n                    const newBalance = await getAccountBalance(playerWallet.address);\n                    setPlayer1Wallet({\n                        ...playerWallet,\n                        balance: newBalance\n                    });\n                } else {\n                    setPlayer2EscrowLocked(true);\n                    // Refresh balance\n                    const newBalance = await getAccountBalance(playerWallet.address);\n                    setPlayer2Wallet({\n                        ...playerWallet,\n                        balance: newBalance\n                    });\n                }\n                console.log(\"Escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance - in real mode, we'd query the contract\n                const escrowBalanceResult = await getAccountBalance(escrowAddress);\n                setEscrowBalance(escrowBalanceResult);\n            }\n            // Now check if both players have locked their escrow\n            if (playerNumber === 1 ? player2EscrowLocked : player1EscrowLocked) {\n                console.log(\"Both players have deposited funds to escrow. Starting game...\");\n                // Final pool amount is minimum bet  2\n                const finalPoolAmount = minimumBet * 2;\n                console.log(\"Setting final bet amount to \".concat(finalPoolAmount, \" APT (\").concat(minimumBet, \" \\xd7 2)\"));\n                setFinalBetAmount(finalPoolAmount);\n                setEscrowLocked(true);\n                // Start the game with a slight delay to ensure UI updates\n                setTimeout(()=>{\n                    console.log(\"Transitioning game state to 'playing'\");\n                    setGameState(\"playing\");\n                    setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus.PLAYING);\n                }, 500);\n            } else {\n                console.log(\"Waiting for the other player to lock their escrow\");\n            }\n        } catch (error) {\n            console.error(\"Error locking escrow for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to lock escrow for Player \".concat(playerNumber));\n        } finally{\n            setIsLoading(false);\n        }\n    }\n    // Check if both players have locked their escrow and start the game if they have\n    function checkAndStartGame() {\n        console.log(\"Checking escrow lock status:\", {\n            player1Locked: player1EscrowLocked,\n            player2Locked: player2EscrowLocked,\n            currentGameState: gameState\n        });\n        if (player1EscrowLocked && player2EscrowLocked) {\n            console.log(\"Both players have locked their escrow. Starting game...\");\n            // Set final bet amount (the pool)\n            const minBetAmount = Math.min(player1Bet, player2Bet);\n            console.log(\"Setting final bet amount to \".concat(minBetAmount * 2, \" APT (min of \").concat(player1Bet, \" and \").concat(player2Bet, \")\"));\n            setFinalBetAmount(minBetAmount * 2);\n            setEscrowLocked(true);\n            setGameState(\"playing\");\n            console.log(\"Game state set to 'playing'\");\n        }\n    }\n    // Helper function to transfer funds from a player to the escrow\n    async function transferToEscrow(playerNumber, amount, targetAddress) {\n        console.log(\"Transferring \".concat(amount, \" APT from Player \").concat(playerNumber, \" to \").concat(targetAddress));\n        const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n        if (!playerWallet) {\n            throw new Error(\"Player \".concat(playerNumber, \" wallet not connected\"));\n        }\n        // For testing only - simulation mode doesn't do actual transfers\n        if (useSimulationMode) {\n            console.log(\"Using simulation mode for escrow transfer (no actual funds will be moved)\");\n            await new Promise((resolve)=>setTimeout(resolve, 1000)); // Mock transaction delay\n            return true;\n        }\n        // Need to make sure the correct wallet is connected\n        console.log(\"Ensuring correct wallet is connected for Player \".concat(playerNumber));\n        const isCorrectWalletConnected = await ensureCorrectWalletConnected(playerNumber);\n        if (!isCorrectWalletConnected) {\n            throw new Error(\"Please connect the wallet for Player \".concat(playerNumber, \" to continue\"));\n        }\n        console.log(\"Wallet correctly connected, preparing transaction\");\n        // Validate target address\n        if (!targetAddress || targetAddress.trim() === \"\") {\n            console.error(\"Invalid target address:\", targetAddress);\n            throw new Error(\"Invalid recipient address. Unable to process transfer.\");\n        }\n        // Convert amount to octas\n        const amountInOctas = Math.floor(amount * 100000000).toString();\n        console.log(\"Amount in Octas: \".concat(amountInOctas));\n        // Create payload\n        const payload = {\n            type: \"entry_function_payload\",\n            function: \"0x1::coin::transfer\",\n            type_arguments: [\n                \"0x1::aptos_coin::AptosCoin\"\n            ],\n            arguments: [\n                targetAddress,\n                amountInOctas\n            ]\n        };\n        console.log(\"Transaction payload created:\", JSON.stringify(payload));\n        // Submit the transaction - try direct method first for more reliable popup display\n        try {\n            let txHash = \"\";\n            // Try direct Petra method first - often more reliable for showing the popup\n            if (window.aptos && typeof window.aptos.signAndSubmitTransaction === \"function\") {\n                console.log(\"Using direct Petra wallet for transaction - this should trigger the popup\");\n                try {\n                    // Force focus on current window to help popup appear\n                    window.focus();\n                    const response = await window.aptos.signAndSubmitTransaction(payload);\n                    console.log(\"Direct transaction response:\", response);\n                    if (response && response.hash) {\n                        txHash = response.hash;\n                        console.log(\"Transaction hash received:\", txHash);\n                    } else {\n                        console.error(\"Direct transaction response missing hash:\", response);\n                    }\n                } catch (directError) {\n                    console.error(\"Direct transaction error:\", directError);\n                    if (directError.message) {\n                        throw new Error(\"Transaction failed: \".concat(directError.message));\n                    }\n                }\n            }\n            // Fall back to adapter if direct method didn't work\n            if (!txHash && connected && account && typeof signAndSubmitTransaction === \"function\") {\n                console.log(\"Falling back to wallet adapter for transaction\");\n                try {\n                    const response = await signAndSubmitTransaction(payload);\n                    console.log(\"Adapter transaction response:\", response);\n                    if (response && response.hash) {\n                        txHash = response.hash;\n                        console.log(\"Transaction hash received from adapter:\", txHash);\n                    } else {\n                        console.error(\"Adapter transaction response missing hash:\", response);\n                    }\n                } catch (adapterError) {\n                    console.error(\"Adapter transaction error:\", adapterError);\n                    if (adapterError.message) {\n                        throw new Error(\"Transaction failed: \".concat(adapterError.message));\n                    }\n                }\n            }\n            // If we still don't have a hash, the transaction failed\n            if (!txHash) {\n                throw new Error(\"Transaction failed. Make sure your wallet is unlocked and has sufficient funds.\");\n            }\n            // Wait for transaction confirmation\n            console.log(\"Transaction submitted with hash: \".concat(txHash));\n            try {\n                console.log(\"Waiting for transaction confirmation...\");\n                const txResult = await client.waitForTransactionWithResult(txHash);\n                console.log(\"Transfer for Player \".concat(playerNumber, \" confirmed:\"), txResult);\n                return true;\n            } catch (confirmError) {\n                console.warn(\"Error confirming transaction:\", confirmError);\n                // Transaction might still go through, so we'll consider this a success\n                console.log(\"Continuing despite confirmation error (transaction may still be processing)\");\n                return true;\n            }\n        } catch (txError) {\n            console.error(\"Error in transfer for Player \".concat(playerNumber, \":\"), txError);\n            if (txError.message) {\n                throw new Error(\"Failed to transfer funds: \".concat(txError.message));\n            } else {\n                throw new Error(\"Failed to transfer funds. Please check your wallet and try again.\");\n            }\n        }\n    }\n    // Restore startNewGame function\n    function startNewGame() {\n        setGame(new chess_js__WEBPACK_IMPORTED_MODULE_4__.Chess());\n        resetGameState();\n        setCurrentPlayer(\"white\");\n    }\n    // Restore forfeitGame function\n    async function forfeitGame(playerNumber) {\n        if (gameState !== \"playing\") {\n            console.log(\"Can only forfeit during an active game\");\n            return;\n        }\n        setGameState(\"completed\");\n        // Determine the winner (opposite of the player who forfeited)\n        const winner = playerNumber === 1 ? \"player2\" : \"player1\";\n        console.log(\"Player \".concat(playerNumber, \" forfeited. \").concat(winner === \"player1\" ? \"Player 1\" : \"Player 2\", \" wins!\"));\n        // Handle the game end with the determined winner\n        await handleGameEnd(winner);\n    }\n    // Add connect/disconnect wallet functions\n    const connectWallet = (playerNumber)=>{\n        connectPlayerWallet(playerNumber);\n    };\n    const disconnectWallet = (playerNumber)=>{\n        if (playerNumber === 1) {\n            setPlayer1Wallet(null);\n        } else {\n            setPlayer2Wallet(null);\n        }\n        disconnect();\n    };\n    // Add a manual wallet address setter function\n    const setManualWalletAddress = (playerNumber)=>{\n        // Prompt user for wallet address\n        const address = window.prompt(\"Enter wallet address for Player \".concat(playerNumber, \":\"));\n        if (!address || address.trim() === \"\") {\n            console.log(\"No address provided, cancelling manual wallet setup\");\n            return;\n        }\n        try {\n            console.log(\"Setting manual wallet address for Player \".concat(playerNumber, \": \").concat(address));\n            // Create wallet info with the provided address\n            // We'll assume a balance of 10 APT for testing purposes\n            const walletInfo = {\n                address: address.trim(),\n                balance: 10 // Default balance for testing\n            };\n            // Set the wallet for the appropriate player\n            if (playerNumber === 1) {\n                setPlayer1Wallet(walletInfo);\n            } else {\n                setPlayer2Wallet(walletInfo);\n            }\n            // If this is being done in simulation mode, update the corresponding escrow setup\n            if (useSimulationMode && playerNumber === 1 && player2Wallet) {\n                console.log(\"Both players now have wallets, attempting to initialize escrow\");\n                // Use a timeout to allow state to update\n                setTimeout(()=>{\n                    initializeEscrow();\n                }, 500);\n            }\n        } catch (error) {\n            console.error(\"Error setting manual wallet for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to set manual wallet for Player \".concat(playerNumber));\n        }\n    };\n    // Function to create a simulated escrow (for debugging/testing)\n    const createSimulatedEscrow = ()=>{\n        if (!useSimulationMode) {\n            setError(\"Please enable simulation mode first\");\n            return;\n        }\n        console.log(\"Creating a simulated escrow for testing\");\n        const simulatedAddress = \"simulated_escrow_\" + Date.now();\n        escrowAdapter.setEscrowAddress(simulatedAddress);\n        setEscrowAddress(simulatedAddress);\n        console.log(\"Created simulated escrow with address:\", simulatedAddress);\n        // Also set escrow status to PENDING\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus.PENDING);\n    };\n    // Add missing chess functions\n    function makeAMove(move) {\n        const gameCopy = new chess_js__WEBPACK_IMPORTED_MODULE_4__.Chess(game.fen());\n        try {\n            const result = gameCopy.move(move);\n            setGame(gameCopy);\n            // Switch turns\n            setCurrentPlayer(gameCopy.turn() === \"w\" ? \"white\" : \"black\");\n            return result;\n        } catch (error) {\n            return null;\n        }\n    }\n    function onDrop(sourceSquare, targetSquare) {\n        // Only allow moves if the game is active\n        if (gameState !== \"playing\") return false;\n        // Enforce turn-based gameplay\n        const currentTurn = game.turn() === \"w\" ? \"white\" : \"black\";\n        // Player 1 is white, Player 2 is black\n        const isCorrectPlayerTurn = currentTurn === \"white\" && player1Wallet || currentTurn === \"black\" && player2Wallet;\n        if (!isCorrectPlayerTurn) {\n            console.log(\"Not your turn. Current turn: \".concat(currentTurn));\n            return false;\n        }\n        const move = makeAMove({\n            from: sourceSquare,\n            to: targetSquare,\n            promotion: \"q\"\n        });\n        // If the move is illegal, return false\n        if (move === null) return false;\n        // Check for game over conditions\n        if (game.isGameOver()) {\n            handleGameEnd();\n        }\n        return true;\n    }\n    // Handle game end function\n    async function handleGameEnd(winnerParam) {\n        setGameState(\"completed\");\n        // Determine the winner if not provided\n        let currentWinner = winnerParam;\n        if (!currentWinner) {\n            // Determine winner based on the chess game state\n            if (game.isDraw()) {\n                currentWinner = \"draw\";\n            } else {\n                // White wins if it's not black's turn (checkmate)\n                currentWinner = game.turn() === \"b\" ? \"player1\" : \"player2\";\n            }\n        }\n        setWinner(currentWinner);\n        console.log(\"Game ended with winner: \".concat(currentWinner));\n        // Only update escrow and pay winner if escrow was locked (real game played)\n        if (escrowLocked) {\n            try {\n                // Update UI state\n                setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus.COMPLETED);\n                // Pay winner\n                await payWinner(currentWinner);\n            } catch (error) {\n                console.error(\"Error handling game end with escrow:\", error);\n                setError(error.message || \"Failed to complete game settlement\");\n            }\n        }\n        // Reset game state after a delay to allow any animations to complete\n        setTimeout(()=>{\n            resetGameState();\n        }, 3000);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container mx-auto px-4 py-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Chess Game with Aptos\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1187,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Play chess with Aptos blockchain integration\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1188,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1189,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1186,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-3xl font-bold text-center mb-8\",\n                children: \"Chess Game with Aptos\"\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1192,\n                columnNumber: 7\n            }, this),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        children: \"Error: \"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1197,\n                        columnNumber: 11\n                    }, this),\n                    \" \",\n                    error,\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>setError(null),\n                        className: \"ml-4 px-2 py-1 bg-red-600 text-white rounded hover:bg-red-700 text-xs\",\n                        children: \"Dismiss\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1198,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1196,\n                columnNumber: 9\n            }, this),\n            isLoading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex justify-center items-center p-8\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"bg-white p-6 rounded shadow-lg\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-lg font-semibold\",\n                            children: \"Processing...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                            lineNumber: 1210,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-gray-600\",\n                            children: \"Please wait while your transaction is being processed.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                            lineNumber: 1211,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                    lineNumber: 1209,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1208,\n                columnNumber: 9\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 md:grid-cols-3 gap-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-gray-100 p-4 rounded shadow\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-xl font-bold mb-4\",\n                                children: \"Player 1 (White)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1218,\n                                columnNumber: 13\n                            }, this),\n                            player1Wallet ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Address:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1223,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                title: player1Wallet.address,\n                                                className: \"cursor-help\",\n                                                children: [\n                                                    player1Wallet.address.substring(0, 6),\n                                                    \"...\",\n                                                    player1Wallet.address.substring(player1Wallet.address.length - 4)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1224,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1222,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Balance:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1227,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            player1Wallet.balance,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1226,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex space-x-2 mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded\",\n                                                onClick: ()=>disconnectWallet(1),\n                                                children: \"Disconnect\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1230,\n                                                columnNumber: 19\n                                            }, this),\n                                            useSimulationMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded\",\n                                                onClick: ()=>setManualWalletAddress(1),\n                                                children: \"Edit Address\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1237,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1229,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1221,\n                                columnNumber: 15\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-gray-600 mb-2\",\n                                        children: getWalletConnectionInstructions(1)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1248,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded block w-full\",\n                                        onClick: ()=>connectWallet(1),\n                                        children: \"Connect Player 1 Wallet\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1249,\n                                        columnNumber: 17\n                                    }, this),\n                                    useSimulationMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded block w-full\",\n                                        onClick: ()=>setManualWalletAddress(1),\n                                        children: \"Set Manual Address\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1256,\n                                        columnNumber: 19\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1247,\n                                columnNumber: 15\n                            }, this),\n                            gameState === \"betting\" && player1Bet > 0 && !player1EscrowLocked && player2Bet > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Your Bet:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1269,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            player1Bet,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1268,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2 text-blue-700\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Minimum Bet:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1272,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            Math.min(player1Bet, player2Bet),\n                                            \" APT\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-xs ml-1\",\n                                                children: \"(this amount will be deducted)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1273,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1271,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded\",\n                                        onClick: ()=>lockEscrow(1),\n                                        disabled: !player1Wallet || player1EscrowLocked,\n                                        children: \"Lock Your Escrow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1275,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-gray-600 mt-2\",\n                                        children: player1EscrowLocked ? \"Your escrow is locked!\" : \"Lock your escrow to proceed with the game\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1282,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1267,\n                                columnNumber: 15\n                            }, this),\n                            player1EscrowLocked && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-2 bg-green-100 p-2 rounded\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-green-700\",\n                                    children: \"Escrow locked successfully!\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                    lineNumber: 1290,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1289,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1217,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-white p-4 rounded shadow\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-4\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_GameDashboard__WEBPACK_IMPORTED_MODULE_5__.GameDashboard, {\n                                    gameState: gameState,\n                                    player1Wallet: player1Wallet,\n                                    player2Wallet: player2Wallet,\n                                    player1Bet: player1Bet,\n                                    player2Bet: player2Bet,\n                                    player1EscrowLocked: player1EscrowLocked,\n                                    player2EscrowLocked: player2EscrowLocked,\n                                    escrowLocked: escrowLocked,\n                                    finalBetAmount: finalBetAmount,\n                                    winner: winner\n                                }, void 0, false, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                    lineNumber: 1298,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1297,\n                                columnNumber: 13\n                            }, this),\n                            gameState === \"waiting\" && player1Wallet && player2Wallet && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-6 p-4 border border-yellow-200 bg-yellow-50 rounded\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold text-center mb-3\",\n                                        children: \"Announce Bets\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1315,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"grid grid-cols-2 gap-4 mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"font-medium text-center mb-1\",\n                                                        children: \"Player 1 Bet\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1318,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center justify-center\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"number\",\n                                                                min: \"0.1\",\n                                                                step: \"0.1\",\n                                                                value: player1Bet,\n                                                                onChange: (e)=>setPlayer1Bet(parseFloat(e.target.value) || 0),\n                                                                className: \"p-2 border rounded w-full text-center\",\n                                                                placeholder: \"Enter amount\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                                lineNumber: 1320,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"ml-2\",\n                                                                children: \"APT\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                                lineNumber: 1329,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1319,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1317,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"font-medium text-center mb-1\",\n                                                        children: \"Player 2 Bet\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1333,\n                                                        columnNumber: 21\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        className: \"flex items-center justify-center\",\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"number\",\n                                                                min: \"0.1\",\n                                                                step: \"0.1\",\n                                                                value: player2Bet,\n                                                                onChange: (e)=>setPlayer2Bet(parseFloat(e.target.value) || 0),\n                                                                className: \"p-2 border rounded w-full text-center\",\n                                                                placeholder: \"Enter amount\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                                lineNumber: 1335,\n                                                                columnNumber: 23\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                className: \"ml-2\",\n                                                                children: \"APT\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                                lineNumber: 1344,\n                                                                columnNumber: 23\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1334,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1332,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1316,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: announceUnifiedBet,\n                                        disabled: !player1Wallet || !player2Wallet || player1Bet <= 0 || player2Bet <= 0,\n                                        className: \"w-full bg-green-600 hover:bg-green-700 text-white py-3 px-4 rounded-lg font-bold text-lg\",\n                                        children: \"Announce Bets & Calculate Minimum\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1349,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-xs text-center text-gray-600 mt-2\",\n                                        children: \"This will calculate the minimum bet amount from both players\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1356,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1314,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mb-4 aspect-square max-w-md mx-auto\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_chessboard__WEBPACK_IMPORTED_MODULE_3__.Chessboard, {\n                                    position: game.fen(),\n                                    onPieceDrop: onDrop,\n                                    boardOrientation: \"white\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                    lineNumber: 1363,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1362,\n                                columnNumber: 13\n                            }, this),\n                            gameState === \"playing\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2 text-lg font-semibold\",\n                                        children: [\n                                            \"Current Player: \",\n                                            currentPlayer === \"white\" ? \"White (Player 1)\" : \"Black (Player 2)\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1372,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-4 text-gray-600\",\n                                        children: [\n                                            \"Total Pool: \",\n                                            finalBetAmount,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1375,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded mr-2\",\n                                        onClick: ()=>forfeitGame(currentPlayer === \"white\" ? 1 : 2),\n                                        children: \"Forfeit\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1378,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1371,\n                                columnNumber: 15\n                            }, this),\n                            gameState === \"completed\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-center mt-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-xl font-bold mb-2\",\n                                        children: winner === \"draw\" ? \"Game Ended in a Draw\" : \"\".concat(winner === \"player1\" ? \"Player 1\" : \"Player 2\", \" Wins!\")\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1389,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-4\",\n                                        children: winner === \"draw\" ? \"Both players receive their bets back\" : \"\".concat(winner === \"player1\" ? \"Player 1\" : \"Player 2\", \" receives \").concat(finalBetAmount, \" APT\")\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1392,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded\",\n                                        onClick: startNewGame,\n                                        children: \"Start New Game\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1397,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1388,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1296,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-gray-100 p-4 rounded shadow\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-xl font-bold mb-4\",\n                                children: \"Player 2 (Black)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1409,\n                                columnNumber: 13\n                            }, this),\n                            player2Wallet ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Address:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1414,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                title: player2Wallet.address,\n                                                className: \"cursor-help\",\n                                                children: [\n                                                    player2Wallet.address.substring(0, 6),\n                                                    \"...\",\n                                                    player2Wallet.address.substring(player2Wallet.address.length - 4)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1415,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1413,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Balance:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1418,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            player2Wallet.balance,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1417,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex space-x-2 mb-4\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded\",\n                                                onClick: ()=>disconnectWallet(2),\n                                                children: \"Disconnect\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1421,\n                                                columnNumber: 19\n                                            }, this),\n                                            useSimulationMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded\",\n                                                onClick: ()=>setManualWalletAddress(2),\n                                                children: \"Edit Address\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1428,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1420,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1412,\n                                columnNumber: 15\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-3\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"bg-yellow-50 border border-yellow-200 p-3 rounded text-sm\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-yellow-800 whitespace-pre-line font-medium\",\n                                            children: getWalletConnectionInstructions(2)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                            lineNumber: 1440,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1439,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded block w-full font-bold\",\n                                        onClick: connectPlayer2Wallet,\n                                        children: \"Connect Player 2 Wallet\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1442,\n                                        columnNumber: 17\n                                    }, this),\n                                    useSimulationMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded block w-full\",\n                                        onClick: ()=>setManualWalletAddress(2),\n                                        children: \"Set Manual Address\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1449,\n                                        columnNumber: 19\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1438,\n                                columnNumber: 15\n                            }, this),\n                            gameState === \"betting\" && player2Bet > 0 && !player2EscrowLocked && player1Bet > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Your Bet:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1462,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            player2Bet,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1461,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mb-2 text-blue-700\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-semibold\",\n                                                children: \"Minimum Bet:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1465,\n                                                columnNumber: 19\n                                            }, this),\n                                            \" \",\n                                            Math.min(player1Bet, player2Bet),\n                                            \" APT\",\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-xs ml-1\",\n                                                children: \"(this amount will be deducted)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1466,\n                                                columnNumber: 19\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1464,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded\",\n                                        onClick: ()=>lockEscrow(2),\n                                        disabled: !player2Wallet || player2EscrowLocked,\n                                        children: \"Lock Your Escrow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1468,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-gray-600 mt-2\",\n                                        children: player2EscrowLocked ? \"Your escrow is locked!\" : \"Lock your escrow to proceed with the game\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1475,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1460,\n                                columnNumber: 15\n                            }, this),\n                            player2EscrowLocked && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-2 bg-green-100 p-2 rounded\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-green-700\",\n                                    children: \"Escrow locked successfully!\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                    lineNumber: 1483,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1482,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1408,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1215,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-8 p-4 bg-gray-200 rounded\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-lg font-bold mb-2\",\n                        children: \"Contract Status\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1492,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                children: \"Escrow Address:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1495,\n                                                columnNumber: 16\n                                            }, this),\n                                            \" \",\n                                            escrowAddress || \"Not connected\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1495,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                children: \"Status:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1496,\n                                                columnNumber: 16\n                                            }, this),\n                                            \" \",\n                                            _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_8__.EscrowStatus[escrowStatus]\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1496,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                                children: \"Escrow Balance:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1497,\n                                                columnNumber: 16\n                                            }, this),\n                                            \" \",\n                                            escrowBalance,\n                                            \" APT\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1497,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                className: \"font-bold text-indigo-800\",\n                                                children: \"Escrow Wallet\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1501,\n                                                columnNumber: 15\n                                            }, this),\n                                            escrowAddress ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"mt-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-indigo-700\",\n                                                        children: \"Escrow wallet connected:\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1504,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"font-mono text-sm mt-1\",\n                                                        children: escrowAddress\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1505,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"mt-2 bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm\",\n                                                        onClick: ()=>setEscrowAddress(null),\n                                                        children: \"Disconnect Escrow\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1506,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1503,\n                                                columnNumber: 17\n                                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"mt-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-indigo-700 mb-2\",\n                                                        children: \"Connect your escrow wallet:\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1515,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        className: \"bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded w-full\",\n                                                        onClick: connectEscrowWallet,\n                                                        disabled: useSimulationMode,\n                                                        children: \"Connect Escrow Wallet\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1516,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                        className: \"text-xs text-indigo-600 mt-1\",\n                                                        children: \"The escrow wallet will hold funds during the game and distribute to the winner.\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1523,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1514,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1500,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-4 p-2 bg-blue-50 border border-blue-200 rounded\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-blue-800 font-medium\",\n                                                children: \"3-Wallet Setup Instructions:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1532,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                                className: \"list-decimal list-inside text-blue-700 pl-2 text-sm space-y-1 mt-1\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Connect Player 1 wallet first\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1534,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Connect Player 2 wallet second (make sure to switch to a different wallet in Petra)\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1535,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Connect the Escrow wallet third (should be a separate wallet from both players)\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1536,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Place bets and lock escrow to start the game\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1537,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"After game completes, the escrow wallet will pay the winner\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                        lineNumber: 1538,\n                                                        columnNumber: 17\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1533,\n                                                columnNumber: 15\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1531,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1494,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                id: \"simulationMode\",\n                                                checked: useSimulationMode,\n                                                onChange: (e)=>setUseSimulationMode(e.target.checked),\n                                                className: \"mr-2\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1544,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                htmlFor: \"simulationMode\",\n                                                children: \"Simulation Mode (No real transactions)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1551,\n                                                columnNumber: 15\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1543,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-sm text-gray-600 mt-1\",\n                                        children: \"Enable simulation mode to test the game flow without actual blockchain transactions.\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1553,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded mr-2\",\n                                                onClick: initializeEscrow,\n                                                disabled: useSimulationMode || !escrowAddress || !player1Wallet || !player2Wallet,\n                                                children: \"Initialize Escrow\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1557,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded mr-2\",\n                                                onClick: createSimulatedEscrow,\n                                                disabled: !useSimulationMode,\n                                                children: \"Create Simulated Escrow\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1564,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded mr-2\",\n                                                onClick: resetGameState,\n                                                children: \"Reset Game\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1571,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded\",\n                                                onClick: resetWalletConnections,\n                                                children: \"Reset All Wallets\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                                lineNumber: 1577,\n                                                columnNumber: 15\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                        lineNumber: 1556,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 1542,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 1493,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 1491,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n        lineNumber: 1185,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"lhStiPhfxpkJaPIoO5VOGyoQWEI=\", false, function() {\n    return [\n        _aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_6__.useWallet\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM0RTtnREFDQzlJLE1BQUs7Z0RBQ0wwSixJQUFHO2dEQUNIQyxTQUFTNUw7Z0RBQ1RpTCxVQUFVLENBQUN4SCxJQUFNeEQscUJBQXFCd0QsRUFBRTBILE1BQU0sQ0FBQ1MsT0FBTztnREFDdER6RixXQUFVOzs7Ozs7MERBRVosOERBQUMwRjtnREFBTUMsU0FBUTswREFBaUI7Ozs7Ozs7Ozs7OztrREFFbEMsOERBQUN6Rjt3Q0FBRUYsV0FBVTtrREFBNkI7Ozs7OztrREFHMUMsOERBQUNEO3dDQUFJQyxXQUFVOzswREFDYiw4REFBQ0c7Z0RBQ0NILFdBQVU7Z0RBQ1ZJLFNBQVM1RDtnREFDVGtJLFVBQVU3SyxxQkFBcUIsQ0FBQ1ksaUJBQWlCLENBQUN6QixpQkFBaUIsQ0FBQ0U7MERBQ3JFOzs7Ozs7MERBR0QsOERBQUNpSDtnREFDQ0gsV0FBVTtnREFDVkksU0FBUzlEO2dEQUNUb0ksVUFBVSxDQUFDN0s7MERBQ1o7Ozs7OzswREFHRCw4REFBQ3NHO2dEQUNDSCxXQUFVO2dEQUNWSSxTQUFTWjswREFDVjs7Ozs7OzBEQUdELDhEQUFDVztnREFDQ0gsV0FBVTtnREFDVkksU0FBUzdEOzBEQUNWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTZjtHQTloRHdCakU7O1FBK0NsQkosdUVBQVNBOzs7S0EvQ1NJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9pbmRleC50c3g/MTlhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCB7IENoZXNzYm9hcmQgfSBmcm9tICdyZWFjdC1jaGVzc2JvYXJkJztcbmltcG9ydCB7IENoZXNzIH0gZnJvbSAnY2hlc3MuanMnO1xuaW1wb3J0IHsgR2FtZURhc2hib2FyZCB9IGZyb20gJy4uL2NvbXBvbmVudHMvR2FtZURhc2hib2FyZCc7XG5pbXBvcnQgQmV0dGluZ0ludGVyZmFjZSBmcm9tICcuLi9jb21wb25lbnRzL0JldHRpbmdJbnRlcmZhY2UnO1xuaW1wb3J0IEFJQWdlbnRQYW5lbCBmcm9tICcuLi9jb21wb25lbnRzL0FJQWdlbnRQYW5lbCc7XG5pbXBvcnQgTG9hZGluZ0NvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL0xvYWRpbmdDb21wb25lbnQnO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSAnQGFwdG9zLWxhYnMvd2FsbGV0LWFkYXB0ZXItcmVhY3QnO1xuaW1wb3J0IHsgVHlwZXMsIEFwdG9zQ2xpZW50IH0gZnJvbSAnYXB0b3MnO1xuaW1wb3J0IHsgRXNjcm93Q29udHJhY3RBZGFwdGVyLCBFc2Nyb3dTdGF0dXMsIERpc3B1dGVSZXNvbHV0aW9uIH0gZnJvbSAnLi4vY29udHJhY3RzL0VzY3Jvd0NvbnRyYWN0QWRhcHRlcic7XG5cbi8vIERlZmluZSB0eXBlcyBhdCB0aGUgdG9wIG9mIHRoZSBmaWxlXG50eXBlIFdpbm5lciA9ICdwbGF5ZXIxJyB8ICdwbGF5ZXIyJyB8ICdkcmF3JyB8IG51bGw7XG50eXBlIEdhbWVTdGF0ZSA9ICd3YWl0aW5nJyB8ICdiZXR0aW5nJyB8ICdiZXRfYW5ub3VuY2VkJyB8ICdlc2Nyb3dfbG9ja2VkJyB8ICdwbGF5aW5nJyB8ICdjb21wbGV0ZWQnO1xuXG4vLyBEZWZpbmUgcGxheWVyIHdhbGxldCBpbmZvIHR5cGVcbmludGVyZmFjZSBQbGF5ZXJXYWxsZXRJbmZvIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBiYWxhbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIC8vIEdhbWUgc3RhdGVcbiAgY29uc3QgW2dhbWUsIHNldEdhbWVdID0gdXNlU3RhdGU8YW55PihuZXcgQ2hlc3MoKSk7XG4gIGNvbnN0IFtnYW1lU3RhdGUsIHNldEdhbWVTdGF0ZV0gPSB1c2VTdGF0ZTxHYW1lU3RhdGU+KCd3YWl0aW5nJyk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBBcHRvcyBjbGllbnQgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gIGNvbnN0IFtjbGllbnRdID0gdXNlU3RhdGU8QXB0b3NDbGllbnQ+KG5ldyBBcHRvc0NsaWVudCgnaHR0cHM6Ly9mdWxsbm9kZS50ZXN0bmV0LmFwdG9zbGFicy5jb20vdjEnKSk7XG4gIFxuICAvLyBQbGF5ZXIgd2FsbGV0cyBhbmQgYmV0c1xuICBjb25zdCBbcGxheWVyMVdhbGxldCwgc2V0UGxheWVyMVdhbGxldF0gPSB1c2VTdGF0ZTxQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwbGF5ZXIyV2FsbGV0LCBzZXRQbGF5ZXIyV2FsbGV0XSA9IHVzZVN0YXRlPFBsYXllcldhbGxldEluZm8gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BsYXllcjFCZXQsIHNldFBsYXllcjFCZXRdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW3BsYXllcjJCZXQsIHNldFBsYXllcjJCZXRdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2ZpbmFsQmV0QW1vdW50LCBzZXRGaW5hbEJldEFtb3VudF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBcbiAgLy8gR2FtZSBtYW5hZ2VtZW50XG4gIGNvbnN0IFthaUVuYWJsZWQsIHNldEFpRW5hYmxlZF0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgXG4gIC8vIEVzY3JvdyBhZGFwdGVyIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9uc1xuICBjb25zdCBlc2Nyb3dBZGFwdGVyID0gdXNlTWVtbygoKSA9PiBuZXcgRXNjcm93Q29udHJhY3RBZGFwdGVyKFxuICAgICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgJzB4MScgLy8gRGVmYXVsdCBtb2R1bGUgYWRkcmVzcywgd291bGQgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgZGVwbG95ZWQgYWRkcmVzc1xuICApLCBbXSk7XG4gIFxuICAvLyBBZGQgZXNjcm93IHRyYWNraW5nIHByb3BlcnRpZXMgXG4gIGNvbnN0IFt1c2VTaW11bGF0aW9uTW9kZSwgc2V0VXNlU2ltdWxhdGlvbk1vZGVdID0gdXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7IC8vIERlZmF1bHQgdG8gdHJ1ZSBzaW5jZSB3ZSdyZSBub3QgcmVhbGx5IGRlcGxveWluZ1xuICBjb25zdCBbZXNjcm93TG9ja2VkLCBzZXRFc2Nyb3dMb2NrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbcGxheWVyMUVzY3Jvd0xvY2tlZCwgc2V0UGxheWVyMUVzY3Jvd0xvY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtwbGF5ZXIyRXNjcm93TG9ja2VkLCBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgXG4gIGNvbnN0IFtjdXJyZW50UGxheWVyLCBzZXRDdXJyZW50UGxheWVyXSA9IHVzZVN0YXRlPCd3aGl0ZScgfCAnYmxhY2snPignd2hpdGUnKTtcbiAgY29uc3QgW2FjdGl2ZVBsYXllcldhbGxldCwgc2V0QWN0aXZlUGxheWVyV2FsbGV0XSA9IHVzZVN0YXRlPDEgfCAyPigxKTsgLy8gV2hpY2ggcGxheWVyIGlzIGNvbm5lY3Rpbmcgd2FsbGV0XG4gIFxuICAvLyBOZXcgc3RhdGUgZm9yIGVzY3JvdyBjb250cmFjdCBkYXRhXG4gIGNvbnN0IFtlc2Nyb3dBZGRyZXNzLCBzZXRFc2Nyb3dBZGRyZXNzXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXNjcm93U3RhdHVzLCBzZXRFc2Nyb3dTdGF0dXNdID0gdXNlU3RhdGU8RXNjcm93U3RhdHVzPihFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gIGNvbnN0IFtlc2Nyb3dCYWxhbmNlLCBzZXRFc2Nyb3dCYWxhbmNlXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIFxuICAvLyBXYWxsZXQgYWRhcHRlclxuICBjb25zdCB7IFxuICAgIGNvbm5lY3QsIFxuICAgIGRpc2Nvbm5lY3QsIFxuICAgIGFjY291bnQsIFxuICAgIGNvbm5lY3RlZCwgXG4gICAgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uIFxuICB9ID0gdXNlV2FsbGV0KCk7XG5cbiAgLy8gQWRkIHRoZSB3aW5uZXIgc3RhdGUgdG8gdGhlIEhvbWUgY29tcG9uZW50XG4gIGNvbnN0IFt3aW5uZXIsIHNldFdpbm5lcl0gPSB1c2VTdGF0ZTxXaW5uZXI+KG51bGwpO1xuXG4gIC8vIEdldCB3YWxsZXQgYmFsYW5jZVxuICBjb25zdCBnZXRBY2NvdW50QmFsYW5jZSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvdXJjZXMgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudFJlc291cmNlcyhhZGRyZXNzKTtcbiAgICAgIGNvbnN0IGFwdG9zQ29pblJlc291cmNlID0gcmVzb3VyY2VzLmZpbmQoXG4gICAgICAgIChyKSA9PiByLnR5cGUgPT09ICcweDE6OmNvaW46OkNvaW5TdG9yZTwweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pbj4nXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoYXB0b3NDb2luUmVzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IChhcHRvc0NvaW5SZXNvdXJjZS5kYXRhIGFzIGFueSkuY29pbi52YWx1ZTtcbiAgICAgICAgLy8gQ29udmVydCBmcm9tIG9jdGFzICgxMF44KSB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihiYWxhbmNlKSAvIDEwMDAwMDAwMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGFjY291bnQgYmFsYW5jZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBlc2Nyb3cgd2hlbiBib3RoIHdhbGxldHMgYXJlIGNvbm5lY3RlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwbGF5ZXIxV2FsbGV0ICYmIHBsYXllcjJXYWxsZXQgJiYgIWVzY3Jvd0FkZHJlc3MgJiYgIWlzTG9hZGluZykge1xuICAgICAgY29uc29sZS5sb2coXCJCb3RoIHdhbGxldHMgY29ubmVjdGVkLCBpbml0aWFsaXppbmcgZXNjcm93XCIpO1xuICAgICAgXG4gICAgICAvLyBJbiBzaW11bGF0aW9uIG1vZGUsIGNyZWF0ZSBhIHNpbXVsYXRlZCBlc2Nyb3cgYXV0b21hdGljYWxseVxuICAgICAgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGNyZWF0ZVNpbXVsYXRlZEVzY3JvdygpO1xuICAgICAgfVxuICAgICAgLy8gSW4gcmVhbCBtb2RlLCBkb24ndCBhdXRvLWluaXRpYWxpemUgdG8gYXZvaWQgdW5leHBlY3RlZCByZWNvbm5lY3Rpb24gcHJvbXB0c1xuICAgICAgLy8gVXNlciB3aWxsIG5lZWQgdG8gY2xpY2sgdGhlIEluaXRpYWxpemUgRXNjcm93IGJ1dHRvblxuICAgIH1cbiAgfSwgW3BsYXllcjFXYWxsZXQsIHBsYXllcjJXYWxsZXQsIGVzY3Jvd0FkZHJlc3MsIGlzTG9hZGluZywgdXNlU2ltdWxhdGlvbk1vZGVdKTtcblxuICAvLyBGdW5jdGlvbiB0byByZXNldCB3YWxsZXQgY29ubmVjdGlvbnMgLSBtb3ZlZCB0byB0aGUgdG9wIHRvIGZpeCByZWZlcmVuY2UgZXJyb3JcbiAgY29uc3QgcmVzZXRXYWxsZXRDb25uZWN0aW9ucyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc29sZS5sb2coXCJSZXNldHRpbmcgd2FsbGV0IGNvbm5lY3Rpb25zLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBEaXNjb25uZWN0IG9ubHkgaWYgY29ubmVjdGVkXG4gICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IGRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVzZXQgc3RhdGVcbiAgICAgIHNldFBsYXllcjFXYWxsZXQobnVsbCk7XG4gICAgICBzZXRQbGF5ZXIyV2FsbGV0KG51bGwpO1xuICAgICAgc2V0UGxheWVyMUJldCgwKTtcbiAgICAgIHNldFBsYXllcjJCZXQoMCk7XG4gICAgICBzZXRGaW5hbEJldEFtb3VudCgwKTtcbiAgICAgIHNldEVzY3Jvd0xvY2tlZChmYWxzZSk7XG4gICAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICAgIHNldFBsYXllcjJFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgICAgc2V0RXNjcm93QWRkcmVzcyhudWxsKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCJXYWxsZXQgY29ubmVjdGlvbnMgcmVzZXQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzZXR0aW5nIHdhbGxldCBjb25uZWN0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gcmVzZXQgd2FsbGV0IGNvbm5lY3Rpb25zLiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS5cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGluaXRpYWxpemUgdGhlIGVzY3JvdyBjb250cmFjdFxuICBjb25zdCBpbml0aWFsaXplRXNjcm93ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghcGxheWVyMVdhbGxldCB8fCAhcGxheWVyMldhbGxldCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIGVzY3JvdzogYm90aCBwbGF5ZXJzIG11c3QgYmUgY29ubmVjdGVkXCIpO1xuICAgICAgc2V0RXJyb3IoXCJCb3RoIHBsYXllcnMgbXVzdCBiZSBjb25uZWN0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZXNjcm93XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBlc2Nyb3cgY29udHJhY3RcIik7XG5cbiAgICAgIC8vIEluIHNpbXVsYXRpb24gbW9kZSwganVzdCBzZXQgYSBmYWtlIGFkZHJlc3NcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHNpbXVsYXRlZCBlc2Nyb3cgd2l0aCBhZGRyZXNzOlwiLCBzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdGhlIGFkZHJlc3MgaW4gdGhlIGFkYXB0ZXJcbiAgICAgICAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IHRoZSBhZGRyZXNzIGluIG91ciBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2ltdWxhdGVkIGVzY3JvdyBpbml0aWFsaXplZCB3aXRoIGFkZHJlc3M6XCIsIHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzdGF0ZSB1cGRhdGVzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSBhZGRyZXNzIHdhcyBzZXRcbiAgICAgICAgICBpZiAoIWVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXNjcm93IGFkZHJlc3Mgc3RhdGUgbm90IHVwZGF0ZWQgeWV0LCBidXQgY29udGludWluZy4uLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKHNpbUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNpbXVsYXRpb24gbW9kZTpcIiwgc2ltRXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRvIHRyeSByZWFsIG1vZGUsIGJ1dCBsb2cgdGhlIGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IGNvbm5lY3RpbmcgdG8gUGxheWVyIDEncyB3YWxsZXRcbiAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIFBsYXllciAxJ3Mgd2FsbGV0IGZvciBlc2Nyb3cgaW5pdGlhbGl6YXRpb25cIik7XG4gICAgICAvLyBJZiBQbGF5ZXIgMSBpcyBjb25uZWN0ZWQgdGhyb3VnaCB3YWxsZXQgYWRhcHRlciwgbWFrZSBzdXJlIHdlJ3JlIHVzaW5nIHRoYXRcbiAgICAgIGlmIChhY2NvdW50ICYmIGFjY291bnQuYWRkcmVzcyAmJiBhY2NvdW50LmFkZHJlc3MudG9TdHJpbmcoKSA9PT0gcGxheWVyMVdhbGxldC5hZGRyZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgY29ubmVjdGVkIHdhbGxldCBhZGFwdGVyIGZvciBlc2Nyb3cgY3JlYXRpb25cIik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjcmVhdGVFc2Nyb3dSZXN1bHQgPSBhd2FpdCBlc2Nyb3dBZGFwdGVyLmNyZWF0ZUVzY3JvdyhcbiAgICAgICAgICB7IHNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbjogc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uIH0sIC8vIFVzZSB0aGUgYWRhcHRlclxuICAgICAgICAgIHBsYXllcjFXYWxsZXQuYWRkcmVzcyxcbiAgICAgICAgICBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgMC4xLCAvLyBNaW5pbXVtIGJldCBvZiAwLjEgQVBUXG4gICAgICAgICAgcGxheWVyMVdhbGxldC5hZGRyZXNzLCAvLyBVc2UgcGxheWVyIDEgYXMgYXJiaXRlciAoaW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhIG5ldXRyYWwgdGhpcmQgcGFydHkpXG4gICAgICAgICAgMjQgKiA2MCAqIDYwIC8vIDI0IGhvdXIgdGltZW91dFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNyZWF0ZUVzY3Jvd1Jlc3VsdCkge1xuICAgICAgICAgIHNldEVzY3Jvd0FkZHJlc3MoY3JlYXRlRXNjcm93UmVzdWx0KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVzY3JvdyBjb250cmFjdCBjcmVhdGVkIHdpdGggYWRkcmVzczpcIiwgY3JlYXRlRXNjcm93UmVzdWx0KTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBhZGFwdGVyIGRpZG4ndCB3b3JrLCB0cnkgdGhlIGRpcmVjdCB3aW5kb3cuYXB0b3MgbWV0aG9kXG4gICAgICBpZiAod2luZG93LmFwdG9zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW5nIHRvIHdhbGxldCB2aWEgd2luZG93LmFwdG9zIGZvciBlc2Nyb3cgY3JlYXRpb25cIik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBjb25uZWN0ZWQgdG8gdGhlIHJpZ2h0IHdhbGxldFxuICAgICAgICAgIGxldCBjdXJyZW50QWNjb3VudCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN1cnJlbnRBY2NvdW50ID0gYXdhaXQgd2luZG93LmFwdG9zLmFjY291bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGFjY291bnQgY3VycmVudGx5IGNvbm5lY3RlZCwgd2lsbCBuZWVkIHRvIGNvbm5lY3RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE9ubHkgc2hvdyBwcm9tcHQgYW5kIGNvbm5lY3QgaWYgbm90IGFscmVhZHkgY29ubmVjdGVkIHRvIFBsYXllciAxJ3Mgd2FsbGV0XG4gICAgICAgICAgaWYgKCFjdXJyZW50QWNjb3VudCB8fCBjdXJyZW50QWNjb3VudC5hZGRyZXNzICE9PSBwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm90IGNvbm5lY3RlZCB0byBQbGF5ZXIgMSdzIHdhbGxldCwgcmVxdWVzdGluZyBjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIG1ha2Ugc3VyZSBQbGF5ZXIgMSdzIHdhbGxldCBpcyBzZWxlY3RlZCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byBpbml0aWFsaXplIHRoZSBlc2Nyb3cuXCIpO1xuICAgICAgICAgICAgYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBbHJlYWR5IGNvbm5lY3RlZCB0byBQbGF5ZXIgMSdzIHdhbGxldCwgcHJvY2VlZGluZyB3aXRob3V0IHJlY29ubmVjdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRW5zdXJlIGl0J3MgUGxheWVyIDEncyB3YWxsZXRcbiAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgd2luZG93LmFwdG9zLmFjY291bnQoKTtcbiAgICAgICAgICBpZiAoYWNjb3VudCAmJiBhY2NvdW50LmFkZHJlc3MgPT09IHBsYXllcjFXYWxsZXQuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gY29ycmVjdCB3YWxsZXQsIGNyZWF0aW5nIGVzY3Jvd1wiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY3JlYXRlRXNjcm93UmVzdWx0ID0gYXdhaXQgZXNjcm93QWRhcHRlci5jcmVhdGVFc2Nyb3coXG4gICAgICAgICAgICAgIHdpbmRvdy5hcHRvcyxcbiAgICAgICAgICAgICAgcGxheWVyMVdhbGxldC5hZGRyZXNzLFxuICAgICAgICAgICAgICBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICAgIDAuMSwgLy8gTWluaW11bSBiZXQgb2YgMC4xIEFQVFxuICAgICAgICAgICAgICBwbGF5ZXIxV2FsbGV0LmFkZHJlc3MsIC8vIFVzZSBwbGF5ZXIgMSBhcyBhcmJpdGVyXG4gICAgICAgICAgICAgIDI0ICogNjAgKiA2MCAvLyAyNCBob3VyIHRpbWVvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjcmVhdGVFc2Nyb3dSZXN1bHQpIHtcbiAgICAgICAgICAgICAgc2V0RXNjcm93QWRkcmVzcyhjcmVhdGVFc2Nyb3dSZXN1bHQpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVzY3JvdyBjb250cmFjdCBjcmVhdGVkIHdpdGggYWRkcmVzczpcIiwgY3JlYXRlRXNjcm93UmVzdWx0KTtcbiAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb25uZWN0ZWQgdG8gd3Jvbmcgd2FsbGV0IGFkZHJlc3M6XCIsIGFjY291bnQ/LmFkZHJlc3MpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyB3YWxsZXQgY29ubmVjdGVkLiBFeHBlY3RlZCAke3BsYXllcjFXYWxsZXQuYWRkcmVzc30gYnV0IGdvdCAke2FjY291bnQ/LmFkZHJlc3N9LiBQbGVhc2UgbWFrZSBzdXJlIFBsYXllciAxJ3Mgd2FsbGV0IGlzIHNlbGVjdGVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2l0aCBkaXJlY3QgUGV0cmEgY29ubmVjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgUGV0cmEgYW5kIHJlbG9hZCB0aGUgcGFnZS5cIik7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBpbml0aWFsaXplIGVzY3Jvd1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlIHRoZSBjb21wbGV4IHdhbGxldCBhZGRyZXNzIGNoZWNraW5nIGFuZCByZXBsYWNlIGVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQgd2l0aCBhIHNpbXBsZXIgdmVyc2lvblxuICBhc3luYyBmdW5jdGlvbiBlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkKHBsYXllck51bWJlcjogMSB8IDIpIHtcbiAgICBjb25zb2xlLmxvZyhgRW5zdXJpbmcgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IGlzIGNvbm5lY3RlZGApO1xuICAgIFxuICAgIC8vIElmIGluIHNpbXVsYXRpb24gbW9kZSwganVzdCByZXR1cm4gdHJ1ZVxuICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgY29uc29sZS5sb2coXCJTaW11bGF0aW9uIG1vZGU6IEFzc3VtaW5nIHdhbGxldCBpcyBjb25uZWN0ZWRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIFBsYXllciAxIG9yIFBsYXllciAyLCBzaW1wbHkgdHJ5IHRvIGNvbm5lY3QgdmlhIHdpbmRvdy5hcHRvc1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIFBsYXllciAke3BsYXllck51bWJlcn0ncyB3YWxsZXRgKTtcbiAgICAgIFxuICAgICAgLy8gUHJvbXB0IHVzZXIgdG8gc3dpdGNoIHRvIHRoZSBjb3JyZWN0IHdhbGxldFxuICAgICAgd2luZG93LmFsZXJ0KGBQbGVhc2UgbWFrZSBzdXJlIFBsYXllciAke3BsYXllck51bWJlcn0ncyB3YWxsZXQgaXMgc2VsZWN0ZWQgaW4geW91ciBQZXRyYSBleHRlbnNpb24uYCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5hZGRyZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDb25uZWN0ZWQgdG8gd2FsbGV0IHdpdGggYWRkcmVzczogJHtyZXNwb25zZS5hZGRyZXNzfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHdhbGxldCBhZGRyZXNzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNvbm5lY3RpbmcgdG8gUGxheWVyICR7cGxheWVyTnVtYmVyfSdzIHdhbGxldDpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBjb25uZWN0UGxheWVyV2FsbGV0IGZ1bmN0aW9uIHRvIHNob3cgY29ycmVjdCBwcm9tcHRzIGJhc2VkIG9uIHBsYXllciBudW1iZXJcbiAgY29uc3QgY29ubmVjdFBsYXllcldhbGxldCA9IGFzeW5jIChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgaWYgKGlzTG9hZGluZykge1xuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGlnbm9yaW5nIGR1cGxpY2F0ZSByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBDb25uZWN0aW5nIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfS4uLmApO1xuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlcmUncyBhIGdsb2JhbCBhcHRvcyBvYmplY3RcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LmFwdG9zKSB7XG4gICAgICAgIHNldEVycm9yKFwiUGV0cmEgd2FsbGV0IGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIHRoZSBQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uIGZyb20gaHR0cHM6Ly9wZXRyYS5hcHAvIGFuZCByZWZyZXNoIHRoZSBwYWdlLlwiKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHBsYXllcidzIHdhbGxldCBpcyBhbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgY29uc3QgcGxheWVyV2FsbGV0ID0gcGxheWVyTnVtYmVyID09PSAxID8gcGxheWVyMVdhbGxldCA6IHBsYXllcjJXYWxsZXQ7XG4gICAgICBpZiAocGxheWVyV2FsbGV0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9J3Mgd2FsbGV0IGlzIGFscmVhZHkgY29ubmVjdGVkOmAsIHBsYXllcldhbGxldC5hZGRyZXNzKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IHRoZSBjb3JyZWN0IHByb21wdCBiYXNlZCBvbiBwbGF5ZXIgbnVtYmVyXG4gICAgICB3aW5kb3cuYWxlcnQoYFBsZWFzZSBtYWtlIHN1cmUgUGxheWVyICR7cGxheWVyTnVtYmVyfSdzIHdhbGxldCBpcyBzZWxlY3RlZCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbi5gKTtcbiAgICAgIFxuICAgICAgLy8gRGlyZWN0IGNvbm5lY3Rpb24gYXBwcm9hY2ggLSBzaW1wbGVzdCBhbmQgbW9zdCByZWxpYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgV2FsbGV0IGNvbm5lY3Rpb24gcmVzcG9uc2UgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgcmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHRvIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfTpgLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHdhbGxldCBpcyBhbHJlYWR5IGNvbm5lY3RlZCBhcyB0aGUgb3RoZXIgcGxheWVyXG4gICAgICAgICAgY29uc3Qgb3RoZXJQbGF5ZXJXYWxsZXQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIyV2FsbGV0IDogcGxheWVyMVdhbGxldDtcbiAgICAgICAgICBpZiAob3RoZXJQbGF5ZXJXYWxsZXQgJiYgb3RoZXJQbGF5ZXJXYWxsZXQuYWRkcmVzcyA9PT0gcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlybVVzZSA9IHdpbmRvdy5jb25maXJtKFxuICAgICAgICAgICAgICBgV0FSTklORzogVGhpcyB3YWxsZXQgKCR7cmVzcG9uc2UuYWRkcmVzcy5zdWJzdHJpbmcoMCwgNil9Li4uJHtyZXNwb25zZS5hZGRyZXNzLnN1YnN0cmluZyhyZXNwb25zZS5hZGRyZXNzLmxlbmd0aCAtIDQpfSkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgYXMgUGxheWVyICR7cGxheWVyTnVtYmVyID09PSAxID8gJzInIDogJzEnfS5cXG5cXG5gICtcbiAgICAgICAgICAgICAgYFVzaW5nIHRoZSBzYW1lIHdhbGxldCBmb3IgYm90aCBwbGF5ZXJzIGlzIE5PVCByZWNvbW1lbmRlZCBmb3IgcmVhbCBnYW1lcy5cXG5cXG5gICtcbiAgICAgICAgICAgICAgYERvIHlvdSB3YW50IHRvIGNvbnRpbnVlIHVzaW5nIHRoaXMgd2FsbGV0IGZvciBib3RoIHBsYXllcnM/YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFjb25maXJtVXNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGNvbm5lY3QgYSBkaWZmZXJlbnQgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9LiBHbyB0byB5b3VyIFBldHJhIGV4dGVuc2lvbiBhbmQgc3dpdGNoIGFjY291bnRzIGZpcnN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNlciBjb25maXJtZWQgdXNpbmcgdGhlIHNhbWUgd2FsbGV0IGZvciBib3RoIHBsYXllcnM6ICR7cmVzcG9uc2UuYWRkcmVzc31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHdhbGxldCBiYWxhbmNlXG4gICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0aGUgd2FsbGV0IGluIHN0YXRlXG4gICAgICAgICAgY29uc3Qgd2FsbGV0SW5mbzogUGxheWVyV2FsbGV0SW5mbyA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlc3BvbnNlLmFkZHJlc3MsXG4gICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGxheWVyTnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgICBzZXRQbGF5ZXIxV2FsbGV0KHdhbGxldEluZm8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRQbGF5ZXIyV2FsbGV0KHdhbGxldEluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHNldCBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9J3Mgd2FsbGV0YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCB3YWxsZXQgYWRkcmVzc1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb25uZWN0aW5nIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfTpgLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3Qgd2FsbGV0OiAke2Vycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gd2FsbGV0IGNvbm5lY3Rpb24gZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGNvbm5lY3Qgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBhIGZ1bmN0aW9uIHRvIHNldCB0aGUgZXNjcm93IHdhbGxldCAtIHRoaXMgd291bGQgYmUgYSB0aGlyZCB3YWxsZXRcbiAgY29uc3QgY29ubmVjdEVzY3Jvd1dhbGxldCA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGluZyBlc2Nyb3cgd2FsbGV0Li4uXCIpO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5hcHRvcykge1xuICAgICAgICBzZXRFcnJvcihcIlBldHJhIHdhbGxldCBpcyBub3QgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCB0aGUgUGV0cmEgd2FsbGV0IGV4dGVuc2lvbi5cIik7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvbXB0IHRvIHNlbGVjdCB0aGUgZXNjcm93IHdhbGxldFxuICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIEVTQ1JPVyB3YWxsZXQgaXMgc2VsZWN0ZWQgaW4geW91ciBQZXRyYSBleHRlbnNpb24uXCIpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIkVzY3JvdyB3YWxsZXQgY29ubmVjdGlvbiByZXNwb25zZTpcIiwgcmVzcG9uc2UpO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byBlc2Nyb3cgd2FsbGV0OlwiLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgZXNjcm93IGFkZHJlc3MgaW4gdGhlIGFkYXB0ZXJcbiAgICAgICAgZXNjcm93QWRhcHRlci5zZXRFc2Nyb3dBZGRyZXNzKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBhZGRyZXNzIGluIGNvbXBvbmVudCBzdGF0ZVxuICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coXCJFc2Nyb3cgd2FsbGV0IHNldCBzdWNjZXNzZnVsbHk6XCIsIHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBlc2Nyb3cgd2FsbGV0IGFkZHJlc3NcIik7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyBlc2Nyb3cgd2FsbGV0OlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGNvbm5lY3QgZXNjcm93IHdhbGxldFwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBkYXRlIHBheVdpbm5lciBmdW5jdGlvbiB0byB1c2UgdGhlIGVzY3JvdyB3YWxsZXQgdG8gcGF5IHRoZSB3aW5uZXJcbiAgYXN5bmMgZnVuY3Rpb24gcGF5V2lubmVyKHdpbm5lcjogV2lubmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBQYXlpbmcgd2lubmVyOiAke3dpbm5lcn1gKTtcbiAgICAgIFxuICAgICAgLy8gT25seSBwcm9jZWVkIGlmIG5vdCBpbiBzaW11bGF0aW9uIG1vZGUgYW5kIGVzY3JvdyBpcyBsb2NrZWRcbiAgICAgIGlmICghdXNlU2ltdWxhdGlvbk1vZGUgJiYgZXNjcm93TG9ja2VkICYmIGVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgLy8gSGFuZGxlIGRyYXcgY2FzZVxuICAgICAgICBpZiAod2lubmVyID09PSAnZHJhdycpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkRyYXcgZ2FtZSAtIHJldHVybmluZyBmdW5kcyB0byBib3RoIHBsYXllcnNcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIGEgZHJhdywgcmV0dXJuIG9yaWdpbmFsIGJldCBhbW91bnRzIHRvIGVhY2ggcGxheWVyXG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBlc2Nyb3cgd2FsbGV0IGZpcnN0XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIHNlbGVjdCB0aGUgRVNDUk9XIHdhbGxldCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byByZXR1cm4gZnVuZHMuXCIpO1xuICAgICAgICAgIGNvbnN0IGVzY3Jvd1dhbGxldENvbm5lY3RlZCA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFlc2Nyb3dXYWxsZXRDb25uZWN0ZWQgfHwgZXNjcm93V2FsbGV0Q29ubmVjdGVkLmFkZHJlc3MgIT09IGVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIGVzY3JvdyB3YWxsZXQuIFBsZWFzZSBlbnN1cmUgdGhlIGNvcnJlY3Qgd2FsbGV0IGlzIHNlbGVjdGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIGZ1bmRzIHRvIFBsYXllciAxXG4gICAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgJHtwbGF5ZXIxQmV0fSBBUFQgdG8gUGxheWVyIDEgZnJvbSBlc2Nyb3dgKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQxID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgICB0eXBlX2FyZ3VtZW50czogW1wiMHgxOjphcHRvc19jb2luOjpBcHRvc0NvaW5cIl0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogW3BsYXllcjFXYWxsZXQuYWRkcmVzcywgTWF0aC5mbG9vcihwbGF5ZXIxQmV0ICogMTAwMDAwMDAwKS50b1N0cmluZygpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdHhSZXNwb25zZTEgPSBhd2FpdCB3aW5kb3cuYXB0b3Muc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQxKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGxheWVyIDEgcmVmdW5kIHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJldHVybiBmdW5kcyB0byBQbGF5ZXIgMlxuICAgICAgICAgIGlmIChwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nICR7cGxheWVyMkJldH0gQVBUIHRvIFBsYXllciAyIGZyb20gZXNjcm93YCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkMiA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiBcIjB4MTo6Y29pbjo6dHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtcIjB4MTo6YXB0b3NfY29pbjo6QXB0b3NDb2luXCJdLFxuICAgICAgICAgICAgICBhcmd1bWVudHM6IFtwbGF5ZXIyV2FsbGV0LmFkZHJlc3MsIE1hdGguZmxvb3IocGxheWVyMkJldCAqIDEwMDAwMDAwMCkudG9TdHJpbmcoKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHR4UmVzcG9uc2UyID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkMik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBsYXllciAyIHJlZnVuZCB0cmFuc2FjdGlvbjpcIiwgdHhSZXNwb25zZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgLy8gSGFuZGxlIHdpbm5lciBjYXNlXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHdpbm5lcldhbGxldCA9IHdpbm5lciA9PT0gJ3BsYXllcjEnID8gcGxheWVyMVdhbGxldCA6IHBsYXllcjJXYWxsZXQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCF3aW5uZXJXYWxsZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpbm5lciB3YWxsZXQgbm90IGZvdW5kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVHJhbnNmZXJyaW5nICR7ZmluYWxCZXRBbW91bnR9IEFQVCB0byB3aW5uZXIgKCR7d2lubmVyV2FsbGV0LmFkZHJlc3N9KWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXNjcm93IHdhbGxldFxuICAgICAgICAgIHdpbmRvdy5hbGVydChcIlBsZWFzZSBzZWxlY3QgdGhlIEVTQ1JPVyB3YWxsZXQgaW4geW91ciBQZXRyYSBleHRlbnNpb24gdG8gcGF5IHRoZSB3aW5uZXIuXCIpO1xuICAgICAgICAgIGNvbnN0IGVzY3Jvd1dhbGxldENvbm5lY3RlZCA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFlc2Nyb3dXYWxsZXRDb25uZWN0ZWQgfHwgZXNjcm93V2FsbGV0Q29ubmVjdGVkLmFkZHJlc3MgIT09IGVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIGVzY3JvdyB3YWxsZXQuIFBsZWFzZSBlbnN1cmUgdGhlIGNvcnJlY3Qgd2FsbGV0IGlzIHNlbGVjdGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJhbnNmZXIgYWxsIGZ1bmRzIGZyb20gZXNjcm93IHRvIHdpbm5lclxuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBcIjB4MTo6Y29pbjo6dHJhbnNmZXJcIixcbiAgICAgICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXCIweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pblwiXSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW3dpbm5lcldhbGxldC5hZGRyZXNzLCBNYXRoLmZsb29yKGZpbmFsQmV0QW1vdW50ICogMTAwMDAwMDAwKS50b1N0cmluZygpXVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdHhSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJXaW5uZXIgcGF5bWVudCB0cmFuc2FjdGlvbjpcIiwgdHhSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwbGF5ZXIgYmFsYW5jZXMgYWZ0ZXIgdHJhbnNmZXJzXG4gICAgICAgIGlmIChwbGF5ZXIxV2FsbGV0KSB7XG4gICAgICAgICAgY29uc3QgbmV3QmFsYW5jZTEgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICAgIHNldFBsYXllcjFXYWxsZXQoe1xuICAgICAgICAgICAgLi4ucGxheWVyMVdhbGxldCxcbiAgICAgICAgICAgIGJhbGFuY2U6IG5ld0JhbGFuY2UxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICAgICAgY29uc3QgbmV3QmFsYW5jZTIgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIyV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICAgIHNldFBsYXllcjJXYWxsZXQoe1xuICAgICAgICAgICAgLi4ucGxheWVyMldhbGxldCxcbiAgICAgICAgICAgIGJhbGFuY2U6IG5ld0JhbGFuY2UyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICAvLyBTaW11bGF0aW9uIG1vZGUgaGFuZGxpbmdcbiAgICAgIGVsc2UgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gYm90aCBwbGF5ZXJzIHJlY2VpdmUgdGhlaXIgYmV0cyBiYWNrIChzaW11bGF0aW9uKVwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGxheWVyMVdhbGxldCkge1xuICAgICAgICAgICAgc2V0UGxheWVyMVdhbGxldCh7XG4gICAgICAgICAgICAgIC4uLnBsYXllcjFXYWxsZXQsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IHBsYXllcjFXYWxsZXQuYmFsYW5jZSArIHBsYXllcjFCZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGxheWVyMldhbGxldCkge1xuICAgICAgICAgICAgc2V0UGxheWVyMldhbGxldCh7XG4gICAgICAgICAgICAgIC4uLnBsYXllcjJXYWxsZXQsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IHBsYXllcjJXYWxsZXQuYmFsYW5jZSArIHBsYXllcjJCZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXlvdXRBbW91bnQgPSBmaW5hbEJldEFtb3VudDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAod2lubmVyID09PSAncGxheWVyMScgJiYgcGxheWVyMVdhbGxldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0aW5nIFBsYXllciAxIHdhbGxldCBiYWxhbmNlOiArJHtwYXlvdXRBbW91bnR9IEFQVCAoc2ltdWxhdGlvbilgKTtcbiAgICAgICAgICAgIHNldFBsYXllcjFXYWxsZXQoe1xuICAgICAgICAgICAgICAuLi5wbGF5ZXIxV2FsbGV0LFxuICAgICAgICAgICAgICBiYWxhbmNlOiBwbGF5ZXIxV2FsbGV0LmJhbGFuY2UgKyBwYXlvdXRBbW91bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lubmVyID09PSAncGxheWVyMicgJiYgcGxheWVyMldhbGxldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0aW5nIFBsYXllciAyIHdhbGxldCBiYWxhbmNlOiArJHtwYXlvdXRBbW91bnR9IEFQVCAoc2ltdWxhdGlvbilgKTtcbiAgICAgICAgICAgIHNldFBsYXllcjJXYWxsZXQoe1xuICAgICAgICAgICAgICAuLi5wbGF5ZXIyV2FsbGV0LFxuICAgICAgICAgICAgICBiYWxhbmNlOiBwbGF5ZXIyV2FsbGV0LmJhbGFuY2UgKyBwYXlvdXRBbW91bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIldpbm5lciBwYXltZW50IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBheWluZyB3aW5uZXI6XCIsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gcGF5IHdpbm5lclwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCBnYW1lIHN0YXRlXG4gIGZ1bmN0aW9uIHJlc2V0R2FtZVN0YXRlKCkge1xuICAgIGNvbnNvbGUubG9nKFwiUmVzZXR0aW5nIGdhbWUgc3RhdGVcIik7XG4gICAgc2V0R2FtZVN0YXRlKCd3YWl0aW5nJyk7XG4gICAgc2V0UGxheWVyMUJldCgwKTtcbiAgICBzZXRQbGF5ZXIyQmV0KDApO1xuICAgIHNldFBsYXllcjFFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgIHNldFBsYXllcjJFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgIHNldEVzY3Jvd0xvY2tlZChmYWxzZSk7XG4gICAgc2V0RmluYWxCZXRBbW91bnQoMCk7XG4gICAgc2V0RXNjcm93U3RhdHVzKEVzY3Jvd1N0YXR1cy5QRU5ESU5HKTtcbiAgICBzZXRFc2Nyb3dCYWxhbmNlKDApO1xuICAgIHNldFdpbm5lcihudWxsKTtcbiAgICBcbiAgICAvLyBSZXNldCB0aGUgZ2FtZSBib2FyZFxuICAgIHNldEdhbWUobmV3IENoZXNzKCkpO1xuICAgIFxuICAgIC8vIFJlc2V0IGN1cnJlbnQgcGxheWVyXG4gICAgc2V0Q3VycmVudFBsYXllcignd2hpdGUnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIkdhbWUgc3RhdGUgcmVzZXQgY29tcGxldGVcIik7XG4gIH1cblxuICAvLyBDaGVjayBpZiBib3RoIHdhbGxldHMgYXJlIGNvbm5lY3RlZFxuICBjb25zdCBib3RoV2FsbGV0c0Nvbm5lY3RlZCA9IHBsYXllcjFXYWxsZXQgJiYgcGxheWVyMldhbGxldDtcbiAgXG4gIC8vIENoZWNrIGlmIGl0J3MgdGhlIGJldHRpbmcgcGhhc2UgYW5kIHdoaWNoIHBsYXllciBuZWVkcyB0byBiZXRcbiAgY29uc3QgbmVlZHNQbGF5ZXIxQmV0ID0gZ2FtZVN0YXRlID09PSAnYmV0dGluZycgJiYgcGxheWVyMUJldCA9PT0gMCAmJiBwbGF5ZXIyQmV0ID4gMDtcbiAgY29uc3QgbmVlZHNQbGF5ZXIyQmV0ID0gZ2FtZVN0YXRlID09PSAnYmV0dGluZycgJiYgcGxheWVyMkJldCA9PT0gMCAmJiBwbGF5ZXIxQmV0ID4gMDtcblxuICAvLyBBZGQgaGVscGVyIGZ1bmN0aW9uIHRvIGV4cGxhaW4gd2FsbGV0IGNvbm5lY3Rpb24gc3RlcHNcbiAgY29uc3QgZ2V0V2FsbGV0Q29ubmVjdGlvbkluc3RydWN0aW9ucyA9IChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgaWYgKHBsYXllck51bWJlciA9PT0gMSkge1xuICAgICAgcmV0dXJuIFwiQ29ubmVjdCB5b3VyIGZpcnN0IHdhbGxldCBieSBjbGlja2luZyB0aGUgYnV0dG9uIGJlbG93LlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJUbyBjb25uZWN0IFBsYXllciAyJ3Mgd2FsbGV0OlxcbjEuIE9wZW4geW91ciBQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uXFxuMi4gU3dpdGNoIHRvIGEgRElGRkVSRU5UIHdhbGxldCBhY2NvdW50IChpbXBvcnRhbnQhKVxcbjMuIENsaWNrICdDb25uZWN0IFBsYXllciAyIFdhbGxldCdcXG5cXG5Vc2luZyB0aGUgc2FtZSB3YWxsZXQgZm9yIGJvdGggcGxheWVycyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHJlYWwgZ2FtZXMuXCI7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZvcmNlIGRpc2Nvbm5lY3QgYmVmb3JlIGNvbm5lY3RpbmcgUGxheWVyIDJcbiAgY29uc3QgY29ubmVjdFBsYXllcjJXYWxsZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gRmlyc3QgdHJ5IHRvIGRpc2Nvbm5lY3QgYW55IGNvbm5lY3RlZCB3YWxsZXRcbiAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZvcmNlIGRpc2Nvbm5lY3RpbmcgYmVmb3JlIGNvbm5lY3RpbmcgUGxheWVyIDIncyB3YWxsZXRcIik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBkaXNjb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGRpc2Nvbm5lY3Rpb24gdG8gY29tcGxldGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBkdXJpbmcgZm9yY2VkIGRpc2Nvbm5lY3Rpb246XCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBQbGF5ZXIgMSB3YWxsZXQgaXMgY29ubmVjdGVkIGFuZCBwcm92aWRlIHNwZWNpZmljIGluc3RydWN0aW9uc1xuICAgIGlmIChwbGF5ZXIxV2FsbGV0KSB7XG4gICAgICBjb25zdCB3YWxsZXRQcmVmYWNlID0gcGxheWVyMVdhbGxldC5hZGRyZXNzLnN1YnN0cmluZygwLCA2KSArIFwiLi4uXCIgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcjFXYWxsZXQuYWRkcmVzcy5zdWJzdHJpbmcocGxheWVyMVdhbGxldC5hZGRyZXNzLmxlbmd0aCAtIDQpO1xuICAgICAgXG4gICAgICAvLyBTaG93IGRldGFpbGVkIGluc3RydWN0aW9ucyBmb3Igc3dpdGNoaW5nIHdhbGxldHNcbiAgICAgIHdpbmRvdy5hbGVydChcbiAgICAgICAgYElNUE9SVEFOVDogQmVmb3JlIGNvbm5lY3RpbmcgUGxheWVyIDIncyB3YWxsZXRcXG5cXG5gICtcbiAgICAgICAgYDEuIE9wZW4geW91ciBQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uXFxuYCArXG4gICAgICAgIGAyLiBDdXJyZW50bHksIFBsYXllciAxIGlzIHVzaW5nIHdhbGxldDogJHt3YWxsZXRQcmVmYWNlfVxcbmAgK1xuICAgICAgICBgMy4gU3dpdGNoIHRvIGEgRElGRkVSRU5UIGFjY291bnQgaW4geW91ciBQZXRyYSB3YWxsZXRcXG5gICtcbiAgICAgICAgYDQuIFRoZW4gY2xpY2sgT0sgdG8gY29udGludWUgY29ubmVjdGluZ2BcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdyB0cnkgdG8gY29ubmVjdCBQbGF5ZXIgMidzIHdhbGxldFxuICAgIGNvbm5lY3RQbGF5ZXJXYWxsZXQoMik7XG4gIH07XG5cbiAgLy8gRWFybHkgcmV0dXJuIGZvciBlcnJvciBzdGF0ZVxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00IHB5LThcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTYgYmctcmVkLTUwIGJvcmRlciBib3JkZXItcmVkLTIwMCByb3VuZGVkLWxnIG1heC13LWxnIG14LWF1dG9cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGQgdGV4dC1yZWQtODAwIG1iLTJcIj5FcnJvcjwvaDI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtNjAwIG1iLTRcIj57ZXJyb3J9PC9wPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtM1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RXJyb3IobnVsbCl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1yZWQtNjAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1yZWQtNzAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgRGlzbWlzc1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICBvbkNsaWNrPXtyZXNldFdhbGxldENvbm5lY3Rpb25zfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctZ3JheS02MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWdyYXktNzAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgUmVzZXQgV2FsbGV0IENvbm5lY3Rpb25zXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLy8gQWRkIGZ1bmN0aW9uIHRvIGFubm91bmNlIGJldHMgZm9yIGJvdGggcGxheWVycyBhbmQgY2FsY3VsYXRlIG1pbmltdW1cbiAgY29uc3QgYW5ub3VuY2VVbmlmaWVkQmV0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEFubm91bmNpbmcgdW5pZmllZCBiZXQgLSBQbGF5ZXIgMTogJHtwbGF5ZXIxQmV0fSBBUFQsIFBsYXllciAyOiAke3BsYXllcjJCZXR9IEFQVGApO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBib3RoIHBsYXllcnMgaGF2ZSB3YWxsZXRzIGNvbm5lY3RlZFxuICAgICAgaWYgKCFwbGF5ZXIxV2FsbGV0IHx8ICFwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBwbGF5ZXJzIG11c3QgY29ubmVjdCB0aGVpciB3YWxsZXRzIGJlZm9yZSBhbm5vdW5jaW5nIGJldHMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgYmV0IGFtb3VudHNcbiAgICAgIGlmIChwbGF5ZXIxQmV0IDw9IDAgfHwgcGxheWVyMkJldCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBwbGF5ZXJzIG11c3QgZW50ZXIgdmFsaWQgYmV0IGFtb3VudHMgKGdyZWF0ZXIgdGhhbiAwKScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBzdWZmaWNpZW50IGZ1bmRzXG4gICAgICBpZiAocGxheWVyMVdhbGxldC5iYWxhbmNlIDwgcGxheWVyMUJldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXllciAxIGhhcyBpbnN1ZmZpY2llbnQgZnVuZHMuIEF2YWlsYWJsZTogJHtwbGF5ZXIxV2FsbGV0LmJhbGFuY2V9IEFQVCwgQmV0OiAke3BsYXllcjFCZXR9IEFQVGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocGxheWVyMldhbGxldC5iYWxhbmNlIDwgcGxheWVyMkJldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXllciAyIGhhcyBpbnN1ZmZpY2llbnQgZnVuZHMuIEF2YWlsYWJsZTogJHtwbGF5ZXIyV2FsbGV0LmJhbGFuY2V9IEFQVCwgQmV0OiAke3BsYXllcjJCZXR9IEFQVGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgbWluaW11bSBiZXRcbiAgICAgIGNvbnN0IG1pbmltdW1CZXQgPSBNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KTtcbiAgICAgIGNvbnNvbGUubG9nKGBDYWxjdWxhdGVkIG1pbmltdW0gYmV0OiAke21pbmltdW1CZXR9IEFQVGApO1xuICAgICAgXG4gICAgICAvLyBTZXQgZmluYWwgYmV0IGFtb3VudCAocG90KVxuICAgICAgc2V0RmluYWxCZXRBbW91bnQobWluaW11bUJldCAqIDIpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZ2FtZSBzdGF0ZVxuICAgICAgc2V0R2FtZVN0YXRlKCdiZXR0aW5nJyk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdVbmlmaWVkIGJldCBhbm5vdW5jZW1lbnQgc3VjY2Vzc2Z1bCcpO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYW5ub3VuY2luZyB1bmlmaWVkIGJldDonLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gYW5ub3VuY2UgdW5pZmllZCBiZXQnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTG9jayB0aGUgZXNjcm93IGJ5IHRyYW5zZmVycmluZyB0aGUgbWluaW11bSBiZXQgYW1vdW50IGZyb20gYSBzcGVjaWZpYyBwbGF5ZXJcbiAgYXN5bmMgZnVuY3Rpb24gbG9ja0VzY3JvdyhwbGF5ZXJOdW1iZXI6IDEgfCAyKSB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgZXNjcm93IGxvY2tpbmcgcHJvY2VzcyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgZXNjcm93IGxvY2sgc3RhdHVzOiBQbGF5ZXIgMTogJHtwbGF5ZXIxRXNjcm93TG9ja2VkfSwgUGxheWVyIDI6ICR7cGxheWVyMkVzY3Jvd0xvY2tlZH1gKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGJvdGggcGxheWVycyBoYXZlIHBsYWNlZCBiZXRzXG4gICAgICBpZiAocGxheWVyMUJldCA8PSAwIHx8IHBsYXllcjJCZXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIHBsYXllcnMgbXVzdCBhbm5vdW5jZSBiZXRzIGJlZm9yZSBsb2NraW5nIGVzY3Jvd1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGJldCBhbW91bnQgKHRoaXMgaXMgd2hhdCB3aWxsIGJlIGRlZHVjdGVkKVxuICAgICAgY29uc3QgbWluaW11bUJldCA9IE1hdGgubWluKHBsYXllcjFCZXQsIHBsYXllcjJCZXQpO1xuICAgICAgY29uc29sZS5sb2coYE1pbmltdW0gYmV0IGFtb3VudCBiZXR3ZWVuIHBsYXllcnM6ICR7bWluaW11bUJldH0gQVBUYCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwbGF5ZXIgd2FsbGV0XG4gICAgICBjb25zdCBwbGF5ZXJXYWxsZXQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIxV2FsbGV0IDogcGxheWVyMldhbGxldDtcbiAgICAgIGlmICghcGxheWVyV2FsbGV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxheWVyICR7cGxheWVyTnVtYmVyfSB3YWxsZXQgbm90IGNvbm5lY3RlZGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbiBzaW11bGF0aW9uIG1vZGUsIGNyZWF0ZSBhbiBlc2Nyb3cgaWYgbm90IHlldCBpbml0aWFsaXplZFxuICAgICAgaWYgKHVzZVNpbXVsYXRpb25Nb2RlICYmICFlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZXNjcm93IGluaXRpYWxpemVkIHlldCwgYnV0IGluIHNpbXVsYXRpb24gbW9kZS4gQ3JlYXRpbmcgZXNjcm93IG5vdy4uLlwiKTtcbiAgICAgICAgY29uc3Qgc2ltdWxhdGVkQWRkcmVzcyA9ICdzaW11bGF0ZWRfZXNjcm93XycgKyBEYXRlLm5vdygpO1xuICAgICAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIHNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXV0by1jcmVhdGVkIHNpbXVsYXRlZCBlc2Nyb3cgd2l0aCBhZGRyZXNzOlwiLCBzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJyaWVmIHBhdXNlIHRvIGxldCBzdGF0ZSB1cGRhdGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgYW4gZXNjcm93IGFkZHJlc3MgaXMgc2V0XG4gICAgICBpZiAoIWVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXNjcm93IHdhbGxldCBjb25uZWN0ZWQuIFBsZWFzZSBjb25uZWN0IHRoZSBlc2Nyb3cgd2FsbGV0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYERlcG9zaXRpbmcgJHttaW5pbXVtQmV0fSBBUFQgdG8gZXNjcm93IGNvbnRyYWN0IGZyb20gUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgXG4gICAgICAvLyBVc2Ugc2ltdWxhdGlvbiBtb2RlIGlmIGVuYWJsZWRcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHNpbXVsYXRpb24gbW9kZSAtIG5vIGFjdHVhbCB0cmFuc2ZlciB3aWxsIG9jY3VyXCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltdWxhdGUgZGVwb3NpdFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIFVJIHN0YXRlXG4gICAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICAgIHNldFBsYXllcjFXYWxsZXQoe1xuICAgICAgICAgICAgLi4ucGxheWVyV2FsbGV0LFxuICAgICAgICAgICAgYmFsYW5jZTogcGxheWVyV2FsbGV0LmJhbGFuY2UgLSBtaW5pbXVtQmV0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0UGxheWVyMkVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgICAgICBzZXRQbGF5ZXIyV2FsbGV0KHtcbiAgICAgICAgICAgIC4uLnBsYXllcldhbGxldCxcbiAgICAgICAgICAgIGJhbGFuY2U6IHBsYXllcldhbGxldC5iYWxhbmNlIC0gbWluaW11bUJldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU2ltdWxhdGVkIGVzY3JvdyBsb2NrIHN1Y2Nlc3NmdWwgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBlc2Nyb3cgYmFsYW5jZSBpbiBzaW11bGF0aW9uIG1vZGVcbiAgICAgICAgc2V0RXNjcm93QmFsYW5jZShwcmV2QmFsYW5jZSA9PiBwcmV2QmFsYW5jZSArIG1pbmltdW1CZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVhbCBkZXBvc2l0IGJ5IHRyYW5zZmVycmluZyBmdW5kcyB0byB0aGUgZXNjcm93IGFkZHJlc3NcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwbGF5ZXIncyB3YWxsZXQgaXMgY29ubmVjdGVkXG4gICAgICAgIGNvbnN0IGlzV2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZChwbGF5ZXJOdW1iZXIpO1xuICAgICAgICBpZiAoIWlzV2FsbGV0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgY29ubmVjdCB0aGUgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IHRvIGNvbnRpbnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERpcmVjdCB0cmFuc2ZlciB0byBlc2Nyb3cgYWRkcmVzcyAtIHVzaW5nIG1pbmltdW1CZXQgaW5zdGVhZCBvZiBwbGF5ZXIncyBmdWxsIGJldFxuICAgICAgICBjb25zdCB0cmFuc2ZlclN1Y2Nlc3MgPSBhd2FpdCB0cmFuc2ZlclRvRXNjcm93KHBsYXllck51bWJlciwgbWluaW11bUJldCwgZXNjcm93QWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRyYW5zZmVyU3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHRyYW5zZmVyIGZ1bmRzIHRvIGVzY3JvdyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVUkgc3RhdGVcbiAgICAgICAgaWYgKHBsYXllck51bWJlciA9PT0gMSkge1xuICAgICAgICAgIHNldFBsYXllcjFFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVmcmVzaCBiYWxhbmNlXG4gICAgICAgICAgY29uc3QgbmV3QmFsYW5jZSA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHBsYXllcldhbGxldC5hZGRyZXNzKTtcbiAgICAgICAgICBzZXRQbGF5ZXIxV2FsbGV0KHtcbiAgICAgICAgICAgIC4uLnBsYXllcldhbGxldCxcbiAgICAgICAgICAgIGJhbGFuY2U6IG5ld0JhbGFuY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZnJlc2ggYmFsYW5jZVxuICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXJXYWxsZXQuYWRkcmVzcyk7XG4gICAgICAgICAgc2V0UGxheWVyMldhbGxldCh7XG4gICAgICAgICAgICAuLi5wbGF5ZXJXYWxsZXQsXG4gICAgICAgICAgICBiYWxhbmNlOiBuZXdCYWxhbmNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc2Nyb3cgbG9jayBzdWNjZXNzZnVsIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZXNjcm93IGJhbGFuY2UgLSBpbiByZWFsIG1vZGUsIHdlJ2QgcXVlcnkgdGhlIGNvbnRyYWN0XG4gICAgICAgIGNvbnN0IGVzY3Jvd0JhbGFuY2VSZXN1bHQgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShlc2Nyb3dBZGRyZXNzKTtcbiAgICAgICAgc2V0RXNjcm93QmFsYW5jZShlc2Nyb3dCYWxhbmNlUmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTm93IGNoZWNrIGlmIGJvdGggcGxheWVycyBoYXZlIGxvY2tlZCB0aGVpciBlc2Nyb3dcbiAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIyRXNjcm93TG9ja2VkIDogcGxheWVyMUVzY3Jvd0xvY2tlZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkJvdGggcGxheWVycyBoYXZlIGRlcG9zaXRlZCBmdW5kcyB0byBlc2Nyb3cuIFN0YXJ0aW5nIGdhbWUuLi5cIik7XG4gICAgICAgIFxuICAgICAgICAvLyBGaW5hbCBwb29sIGFtb3VudCBpcyBtaW5pbXVtIGJldCDDlyAyXG4gICAgICAgIGNvbnN0IGZpbmFsUG9vbEFtb3VudCA9IG1pbmltdW1CZXQgKiAyO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFNldHRpbmcgZmluYWwgYmV0IGFtb3VudCB0byAke2ZpbmFsUG9vbEFtb3VudH0gQVBUICgke21pbmltdW1CZXR9IMOXIDIpYCk7XG4gICAgICAgIHNldEZpbmFsQmV0QW1vdW50KGZpbmFsUG9vbEFtb3VudCk7XG4gICAgICAgIHNldEVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHRoZSBnYW1lIHdpdGggYSBzbGlnaHQgZGVsYXkgdG8gZW5zdXJlIFVJIHVwZGF0ZXNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2l0aW9uaW5nIGdhbWUgc3RhdGUgdG8gJ3BsYXlpbmcnXCIpO1xuICAgICAgICAgIHNldEdhbWVTdGF0ZSgncGxheWluZycpO1xuICAgICAgICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUExBWUlORyk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyBmb3IgdGhlIG90aGVyIHBsYXllciB0byBsb2NrIHRoZWlyIGVzY3Jvd2ApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvY2tpbmcgZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OmAsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBsb2NrIGVzY3JvdyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgYm90aCBwbGF5ZXJzIGhhdmUgbG9ja2VkIHRoZWlyIGVzY3JvdyBhbmQgc3RhcnQgdGhlIGdhbWUgaWYgdGhleSBoYXZlXG4gIGZ1bmN0aW9uIGNoZWNrQW5kU3RhcnRHYW1lKCkge1xuICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tpbmcgZXNjcm93IGxvY2sgc3RhdHVzOlwiLCB7IFxuICAgICAgcGxheWVyMUxvY2tlZDogcGxheWVyMUVzY3Jvd0xvY2tlZCwgXG4gICAgICBwbGF5ZXIyTG9ja2VkOiBwbGF5ZXIyRXNjcm93TG9ja2VkLFxuICAgICAgY3VycmVudEdhbWVTdGF0ZTogZ2FtZVN0YXRlXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHBsYXllcjFFc2Nyb3dMb2NrZWQgJiYgcGxheWVyMkVzY3Jvd0xvY2tlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJCb3RoIHBsYXllcnMgaGF2ZSBsb2NrZWQgdGhlaXIgZXNjcm93LiBTdGFydGluZyBnYW1lLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBTZXQgZmluYWwgYmV0IGFtb3VudCAodGhlIHBvb2wpXG4gICAgICBjb25zdCBtaW5CZXRBbW91bnQgPSBNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KTtcbiAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGZpbmFsIGJldCBhbW91bnQgdG8gJHttaW5CZXRBbW91bnQgKiAyfSBBUFQgKG1pbiBvZiAke3BsYXllcjFCZXR9IGFuZCAke3BsYXllcjJCZXR9KWApO1xuICAgICAgXG4gICAgICBzZXRGaW5hbEJldEFtb3VudChtaW5CZXRBbW91bnQgKiAyKTtcbiAgICAgIHNldEVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgIHNldEdhbWVTdGF0ZSgncGxheWluZycpO1xuICAgICAgY29uc29sZS5sb2coXCJHYW1lIHN0YXRlIHNldCB0byAncGxheWluZydcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHRyYW5zZmVyIGZ1bmRzIGZyb20gYSBwbGF5ZXIgdG8gdGhlIGVzY3Jvd1xuICBhc3luYyBmdW5jdGlvbiB0cmFuc2ZlclRvRXNjcm93KHBsYXllck51bWJlcjogMSB8IDIsIGFtb3VudDogbnVtYmVyLCB0YXJnZXRBZGRyZXNzOiBzdHJpbmcpIHtcbiAgICBjb25zb2xlLmxvZyhgVHJhbnNmZXJyaW5nICR7YW1vdW50fSBBUFQgZnJvbSBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IHRvICR7dGFyZ2V0QWRkcmVzc31gKTtcbiAgICBcbiAgICBjb25zdCBwbGF5ZXJXYWxsZXQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIxV2FsbGV0IDogcGxheWVyMldhbGxldDtcbiAgICBpZiAoIXBsYXllcldhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IHdhbGxldCBub3QgY29ubmVjdGVkYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciB0ZXN0aW5nIG9ubHkgLSBzaW11bGF0aW9uIG1vZGUgZG9lc24ndCBkbyBhY3R1YWwgdHJhbnNmZXJzXG4gICAgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHNpbXVsYXRpb24gbW9kZSBmb3IgZXNjcm93IHRyYW5zZmVyIChubyBhY3R1YWwgZnVuZHMgd2lsbCBiZSBtb3ZlZClcIik7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpOyAvLyBNb2NrIHRyYW5zYWN0aW9uIGRlbGF5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gTmVlZCB0byBtYWtlIHN1cmUgdGhlIGNvcnJlY3Qgd2FsbGV0IGlzIGNvbm5lY3RlZFxuICAgIGNvbnNvbGUubG9nKGBFbnN1cmluZyBjb3JyZWN0IHdhbGxldCBpcyBjb25uZWN0ZWQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICBjb25zdCBpc0NvcnJlY3RXYWxsZXRDb25uZWN0ZWQgPSBhd2FpdCBlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkKHBsYXllck51bWJlcik7XG4gICAgaWYgKCFpc0NvcnJlY3RXYWxsZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGNvbm5lY3QgdGhlIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfSB0byBjb250aW51ZWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIldhbGxldCBjb3JyZWN0bHkgY29ubmVjdGVkLCBwcmVwYXJpbmcgdHJhbnNhY3Rpb25cIik7XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGFyZ2V0IGFkZHJlc3NcbiAgICBpZiAoIXRhcmdldEFkZHJlc3MgfHwgdGFyZ2V0QWRkcmVzcy50cmltKCkgPT09ICcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCB0YXJnZXQgYWRkcmVzczpcIiwgdGFyZ2V0QWRkcmVzcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlY2lwaWVudCBhZGRyZXNzLiBVbmFibGUgdG8gcHJvY2VzcyB0cmFuc2Zlci5cIik7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgYW1vdW50IHRvIG9jdGFzXG4gICAgY29uc3QgYW1vdW50SW5PY3RhcyA9IE1hdGguZmxvb3IoYW1vdW50ICogMTAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgIGNvbnNvbGUubG9nKGBBbW91bnQgaW4gT2N0YXM6ICR7YW1vdW50SW5PY3Rhc31gKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgcGF5bG9hZFxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgIGZ1bmN0aW9uOiBcIjB4MTo6Y29pbjo6dHJhbnNmZXJcIixcbiAgICAgIHR5cGVfYXJndW1lbnRzOiBbXCIweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pblwiXSxcbiAgICAgIGFyZ3VtZW50czogW3RhcmdldEFkZHJlc3MsIGFtb3VudEluT2N0YXNdXG4gICAgfTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIlRyYW5zYWN0aW9uIHBheWxvYWQgY3JlYXRlZDpcIiwgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgIFxuICAgIC8vIFN1Ym1pdCB0aGUgdHJhbnNhY3Rpb24gLSB0cnkgZGlyZWN0IG1ldGhvZCBmaXJzdCBmb3IgbW9yZSByZWxpYWJsZSBwb3B1cCBkaXNwbGF5XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0eEhhc2ggPSBcIlwiO1xuICAgICAgXG4gICAgICAvLyBUcnkgZGlyZWN0IFBldHJhIG1ldGhvZCBmaXJzdCAtIG9mdGVuIG1vcmUgcmVsaWFibGUgZm9yIHNob3dpbmcgdGhlIHBvcHVwXG4gICAgICBpZiAod2luZG93LmFwdG9zICYmIHR5cGVvZiB3aW5kb3cuYXB0b3Muc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZGlyZWN0IFBldHJhIHdhbGxldCBmb3IgdHJhbnNhY3Rpb24gLSB0aGlzIHNob3VsZCB0cmlnZ2VyIHRoZSBwb3B1cFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBGb3JjZSBmb2N1cyBvbiBjdXJyZW50IHdpbmRvdyB0byBoZWxwIHBvcHVwIGFwcGVhclxuICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkRpcmVjdCB0cmFuc2FjdGlvbiByZXNwb25zZTpcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5oYXNoKSB7XG4gICAgICAgICAgICB0eEhhc2ggPSByZXNwb25zZS5oYXNoO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvbiBoYXNoIHJlY2VpdmVkOlwiLCB0eEhhc2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGlyZWN0IHRyYW5zYWN0aW9uIHJlc3BvbnNlIG1pc3NpbmcgaGFzaDpcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZGlyZWN0RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGlyZWN0IHRyYW5zYWN0aW9uIGVycm9yOlwiLCBkaXJlY3RFcnJvcik7XG4gICAgICAgICAgaWYgKGRpcmVjdEVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZmFpbGVkOiAke2RpcmVjdEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGwgYmFjayB0byBhZGFwdGVyIGlmIGRpcmVjdCBtZXRob2QgZGlkbid0IHdvcmtcbiAgICAgIGlmICghdHhIYXNoICYmIGNvbm5lY3RlZCAmJiBhY2NvdW50ICYmIHR5cGVvZiBzaWduQW5kU3VibWl0VHJhbnNhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGYWxsaW5nIGJhY2sgdG8gd2FsbGV0IGFkYXB0ZXIgZm9yIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQgYXMgYW55KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkYXB0ZXIgdHJhbnNhY3Rpb24gcmVzcG9uc2U6XCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuaGFzaCkge1xuICAgICAgICAgICAgdHhIYXNoID0gcmVzcG9uc2UuaGFzaDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNhY3Rpb24gaGFzaCByZWNlaXZlZCBmcm9tIGFkYXB0ZXI6XCIsIHR4SGFzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBZGFwdGVyIHRyYW5zYWN0aW9uIHJlc3BvbnNlIG1pc3NpbmcgaGFzaDpcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoYWRhcHRlckVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkFkYXB0ZXIgdHJhbnNhY3Rpb24gZXJyb3I6XCIsIGFkYXB0ZXJFcnJvcik7XG4gICAgICAgICAgaWYgKGFkYXB0ZXJFcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGZhaWxlZDogJHthZGFwdGVyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIGhhc2gsIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWRcbiAgICAgIGlmICghdHhIYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZC4gTWFrZSBzdXJlIHlvdXIgd2FsbGV0IGlzIHVubG9ja2VkIGFuZCBoYXMgc3VmZmljaWVudCBmdW5kcy5cIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAgY29uc29sZS5sb2coYFRyYW5zYWN0aW9uIHN1Ym1pdHRlZCB3aXRoIGhhc2g6ICR7dHhIYXNofWApO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIldhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbi4uLlwiKTtcbiAgICAgICAgY29uc3QgdHhSZXN1bHQgPSBhd2FpdCBjbGllbnQud2FpdEZvclRyYW5zYWN0aW9uV2l0aFJlc3VsdCh0eEhhc2gpO1xuICAgICAgICBjb25zb2xlLmxvZyhgVHJhbnNmZXIgZm9yIFBsYXllciAke3BsYXllck51bWJlcn0gY29uZmlybWVkOmAsIHR4UmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChjb25maXJtRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbjpcIiwgY29uZmlybUVycm9yKTtcbiAgICAgICAgLy8gVHJhbnNhY3Rpb24gbWlnaHQgc3RpbGwgZ28gdGhyb3VnaCwgc28gd2UnbGwgY29uc2lkZXIgdGhpcyBhIHN1Y2Nlc3NcbiAgICAgICAgY29uc29sZS5sb2coXCJDb250aW51aW5nIGRlc3BpdGUgY29uZmlybWF0aW9uIGVycm9yICh0cmFuc2FjdGlvbiBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZylcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKHR4RXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gdHJhbnNmZXIgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgdHhFcnJvcik7XG4gICAgICBpZiAodHhFcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHRyYW5zZmVyIGZ1bmRzOiAke3R4RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB0cmFuc2ZlciBmdW5kcy4gUGxlYXNlIGNoZWNrIHlvdXIgd2FsbGV0IGFuZCB0cnkgYWdhaW4uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc3RvcmUgc3RhcnROZXdHYW1lIGZ1bmN0aW9uXG4gIGZ1bmN0aW9uIHN0YXJ0TmV3R2FtZSgpIHtcbiAgICBzZXRHYW1lKG5ldyBDaGVzcygpKTtcbiAgICByZXNldEdhbWVTdGF0ZSgpO1xuICAgIHNldEN1cnJlbnRQbGF5ZXIoJ3doaXRlJyk7XG4gIH1cblxuICAvLyBSZXN0b3JlIGZvcmZlaXRHYW1lIGZ1bmN0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGZvcmZlaXRHYW1lKHBsYXllck51bWJlcjogMSB8IDIpIHtcbiAgICBpZiAoZ2FtZVN0YXRlICE9PSAncGxheWluZycpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2FuIG9ubHkgZm9yZmVpdCBkdXJpbmcgYW4gYWN0aXZlIGdhbWVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldEdhbWVTdGF0ZSgnY29tcGxldGVkJyk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB3aW5uZXIgKG9wcG9zaXRlIG9mIHRoZSBwbGF5ZXIgd2hvIGZvcmZlaXRlZClcbiAgICBjb25zdCB3aW5uZXIgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyAncGxheWVyMicgOiAncGxheWVyMSc7XG4gICAgY29uc29sZS5sb2coYFBsYXllciAke3BsYXllck51bWJlcn0gZm9yZmVpdGVkLiAke3dpbm5lciA9PT0gJ3BsYXllcjEnID8gJ1BsYXllciAxJyA6ICdQbGF5ZXIgMid9IHdpbnMhYCk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHRoZSBnYW1lIGVuZCB3aXRoIHRoZSBkZXRlcm1pbmVkIHdpbm5lclxuICAgIGF3YWl0IGhhbmRsZUdhbWVFbmQod2lubmVyKTtcbiAgfVxuXG4gIC8vIEFkZCBjb25uZWN0L2Rpc2Nvbm5lY3Qgd2FsbGV0IGZ1bmN0aW9uc1xuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gKHBsYXllck51bWJlcjogMSB8IDIpID0+IHtcbiAgICBjb25uZWN0UGxheWVyV2FsbGV0KHBsYXllck51bWJlcik7XG4gIH07XG5cbiAgY29uc3QgZGlzY29ubmVjdFdhbGxldCA9IChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgaWYgKHBsYXllck51bWJlciA9PT0gMSkge1xuICAgICAgc2V0UGxheWVyMVdhbGxldChudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UGxheWVyMldhbGxldChudWxsKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpO1xuICB9O1xuXG4gIC8vIEFkZCBhIG1hbnVhbCB3YWxsZXQgYWRkcmVzcyBzZXR0ZXIgZnVuY3Rpb25cbiAgY29uc3Qgc2V0TWFudWFsV2FsbGV0QWRkcmVzcyA9IChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgLy8gUHJvbXB0IHVzZXIgZm9yIHdhbGxldCBhZGRyZXNzXG4gICAgY29uc3QgYWRkcmVzcyA9IHdpbmRvdy5wcm9tcHQoYEVudGVyIHdhbGxldCBhZGRyZXNzIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OmApO1xuICAgIFxuICAgIGlmICghYWRkcmVzcyB8fCBhZGRyZXNzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWRkcmVzcyBwcm92aWRlZCwgY2FuY2VsbGluZyBtYW51YWwgd2FsbGV0IHNldHVwXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFNldHRpbmcgbWFudWFsIHdhbGxldCBhZGRyZXNzIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OiAke2FkZHJlc3N9YCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB3YWxsZXQgaW5mbyB3aXRoIHRoZSBwcm92aWRlZCBhZGRyZXNzXG4gICAgICAvLyBXZSdsbCBhc3N1bWUgYSBiYWxhbmNlIG9mIDEwIEFQVCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgICAgY29uc3Qgd2FsbGV0SW5mbzogUGxheWVyV2FsbGV0SW5mbyA9IHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcy50cmltKCksXG4gICAgICAgIGJhbGFuY2U6IDEwIC8vIERlZmF1bHQgYmFsYW5jZSBmb3IgdGVzdGluZ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHRoZSB3YWxsZXQgZm9yIHRoZSBhcHByb3ByaWF0ZSBwbGF5ZXJcbiAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgc2V0UGxheWVyMVdhbGxldCh3YWxsZXRJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBsYXllcjJXYWxsZXQod2FsbGV0SW5mbyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgZG9uZSBpbiBzaW11bGF0aW9uIG1vZGUsIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBlc2Nyb3cgc2V0dXBcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSAmJiBwbGF5ZXJOdW1iZXIgPT09IDEgJiYgcGxheWVyMldhbGxldCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkJvdGggcGxheWVycyBub3cgaGF2ZSB3YWxsZXRzLCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgZXNjcm93XCIpO1xuICAgICAgICAvLyBVc2UgYSB0aW1lb3V0IHRvIGFsbG93IHN0YXRlIHRvIHVwZGF0ZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXplRXNjcm93KCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIG1hbnVhbCB3YWxsZXQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHNldCBtYW51YWwgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNpbXVsYXRlZCBlc2Nyb3cgKGZvciBkZWJ1Z2dpbmcvdGVzdGluZylcbiAgY29uc3QgY3JlYXRlU2ltdWxhdGVkRXNjcm93ID0gKCkgPT4ge1xuICAgIGlmICghdXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgIHNldEVycm9yKFwiUGxlYXNlIGVuYWJsZSBzaW11bGF0aW9uIG1vZGUgZmlyc3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgYSBzaW11bGF0ZWQgZXNjcm93IGZvciB0ZXN0aW5nXCIpO1xuICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZWQgc2ltdWxhdGVkIGVzY3JvdyB3aXRoIGFkZHJlc3M6XCIsIHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgIFxuICAgIC8vIEFsc28gc2V0IGVzY3JvdyBzdGF0dXMgdG8gUEVORElOR1xuICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gIH07XG5cbiAgLy8gQWRkIG1pc3NpbmcgY2hlc3MgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIG1ha2VBTW92ZShtb3ZlOiBhbnkpIHtcbiAgICBjb25zdCBnYW1lQ29weSA9IG5ldyBDaGVzcyhnYW1lLmZlbigpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2FtZUNvcHkubW92ZShtb3ZlKTtcbiAgICAgIHNldEdhbWUoZ2FtZUNvcHkpO1xuICAgICAgXG4gICAgICAvLyBTd2l0Y2ggdHVybnNcbiAgICAgIHNldEN1cnJlbnRQbGF5ZXIoZ2FtZUNvcHkudHVybigpID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJyk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJvcChzb3VyY2VTcXVhcmU6IHN0cmluZywgdGFyZ2V0U3F1YXJlOiBzdHJpbmcpIHtcbiAgICAvLyBPbmx5IGFsbG93IG1vdmVzIGlmIHRoZSBnYW1lIGlzIGFjdGl2ZVxuICAgIGlmIChnYW1lU3RhdGUgIT09ICdwbGF5aW5nJykgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIEVuZm9yY2UgdHVybi1iYXNlZCBnYW1lcGxheVxuICAgIGNvbnN0IGN1cnJlbnRUdXJuID0gZ2FtZS50dXJuKCkgPT09ICd3JyA/ICd3aGl0ZScgOiAnYmxhY2snO1xuICAgIFxuICAgIC8vIFBsYXllciAxIGlzIHdoaXRlLCBQbGF5ZXIgMiBpcyBibGFja1xuICAgIGNvbnN0IGlzQ29ycmVjdFBsYXllclR1cm4gPSBcbiAgICAgIChjdXJyZW50VHVybiA9PT0gJ3doaXRlJyAmJiBwbGF5ZXIxV2FsbGV0KSB8fCBcbiAgICAgIChjdXJyZW50VHVybiA9PT0gJ2JsYWNrJyAmJiBwbGF5ZXIyV2FsbGV0KTtcbiAgICBcbiAgICBpZiAoIWlzQ29ycmVjdFBsYXllclR1cm4pIHtcbiAgICAgIGNvbnNvbGUubG9nKGBOb3QgeW91ciB0dXJuLiBDdXJyZW50IHR1cm46ICR7Y3VycmVudFR1cm59YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG1vdmUgPSBtYWtlQU1vdmUoe1xuICAgICAgZnJvbTogc291cmNlU3F1YXJlLFxuICAgICAgdG86IHRhcmdldFNxdWFyZSxcbiAgICAgIHByb21vdGlvbjogJ3EnLCAvLyBEZWZhdWx0IHByb21vdGlvbiB0byBxdWVlblxuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIG1vdmUgaXMgaWxsZWdhbCwgcmV0dXJuIGZhbHNlXG4gICAgaWYgKG1vdmUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciBnYW1lIG92ZXIgY29uZGl0aW9uc1xuICAgIGlmIChnYW1lLmlzR2FtZU92ZXIoKSkge1xuICAgICAgaGFuZGxlR2FtZUVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSGFuZGxlIGdhbWUgZW5kIGZ1bmN0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUdhbWVFbmQod2lubmVyUGFyYW0/OiBXaW5uZXIpIHtcbiAgICBzZXRHYW1lU3RhdGUoJ2NvbXBsZXRlZCcpO1xuICAgIFxuICAgIC8vIERldGVybWluZSB0aGUgd2lubmVyIGlmIG5vdCBwcm92aWRlZFxuICAgIGxldCBjdXJyZW50V2lubmVyID0gd2lubmVyUGFyYW07XG4gICAgXG4gICAgaWYgKCFjdXJyZW50V2lubmVyKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgd2lubmVyIGJhc2VkIG9uIHRoZSBjaGVzcyBnYW1lIHN0YXRlXG4gICAgICBpZiAoZ2FtZS5pc0RyYXcoKSkge1xuICAgICAgICBjdXJyZW50V2lubmVyID0gJ2RyYXcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hpdGUgd2lucyBpZiBpdCdzIG5vdCBibGFjaydzIHR1cm4gKGNoZWNrbWF0ZSlcbiAgICAgICAgY3VycmVudFdpbm5lciA9IGdhbWUudHVybigpID09PSAnYicgPyAncGxheWVyMScgOiAncGxheWVyMic7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHNldFdpbm5lcihjdXJyZW50V2lubmVyKTtcbiAgICBjb25zb2xlLmxvZyhgR2FtZSBlbmRlZCB3aXRoIHdpbm5lcjogJHtjdXJyZW50V2lubmVyfWApO1xuXG4gICAgLy8gT25seSB1cGRhdGUgZXNjcm93IGFuZCBwYXkgd2lubmVyIGlmIGVzY3JvdyB3YXMgbG9ja2VkIChyZWFsIGdhbWUgcGxheWVkKVxuICAgIGlmIChlc2Nyb3dMb2NrZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFVwZGF0ZSBVSSBzdGF0ZVxuICAgICAgICBzZXRFc2Nyb3dTdGF0dXMoRXNjcm93U3RhdHVzLkNPTVBMRVRFRCk7XG4gICAgICAgIFxuICAgICAgICAvLyBQYXkgd2lubmVyXG4gICAgICAgIGF3YWl0IHBheVdpbm5lcihjdXJyZW50V2lubmVyKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBnYW1lIGVuZCB3aXRoIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGNvbXBsZXRlIGdhbWUgc2V0dGxlbWVudFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBnYW1lIHN0YXRlIGFmdGVyIGEgZGVsYXkgdG8gYWxsb3cgYW55IGFuaW1hdGlvbnMgdG8gY29tcGxldGVcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc2V0R2FtZVN0YXRlKCk7XG4gICAgfSwgMzAwMCk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG14LWF1dG8gcHgtNCBweS04XCI+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPkNoZXNzIEdhbWUgd2l0aCBBcHRvczwvdGl0bGU+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJQbGF5IGNoZXNzIHdpdGggQXB0b3MgYmxvY2tjaGFpbiBpbnRlZ3JhdGlvblwiIC8+XG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cblxuICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCB0ZXh0LWNlbnRlciBtYi04XCI+Q2hlc3MgR2FtZSB3aXRoIEFwdG9zPC9oMT5cblxuICAgICAgey8qIEVycm9yIG1lc3NhZ2UgKi99XG4gICAgICB7ZXJyb3IgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXJlZC0xMDAgYm9yZGVyIGJvcmRlci1yZWQtNDAwIHRleHQtcmVkLTcwMCBweC00IHB5LTMgcm91bmRlZCBtYi00XCI+XG4gICAgICAgICAgPHN0cm9uZz5FcnJvcjogPC9zdHJvbmc+IHtlcnJvcn1cbiAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RXJyb3IobnVsbCl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtbC00IHB4LTIgcHktMSBiZy1yZWQtNjAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1yZWQtNzAwIHRleHQteHNcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIERpc21pc3NcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7aXNMb2FkaW5nID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHAtOFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgcC02IHJvdW5kZWQgc2hhZG93LWxnXCI+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGRcIj5Qcm9jZXNzaW5nLi4uPC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPlBsZWFzZSB3YWl0IHdoaWxlIHlvdXIgdHJhbnNhY3Rpb24gaXMgYmVpbmcgcHJvY2Vzc2VkLjwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbWQ6Z3JpZC1jb2xzLTMgZ2FwLTZcIj5cbiAgICAgICAgICB7LyogTGVmdCBwYW5lbCAtIFBsYXllciAxICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS0xMDAgcC00IHJvdW5kZWQgc2hhZG93XCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGQgbWItNFwiPlBsYXllciAxIChXaGl0ZSk8L2gyPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICB7cGxheWVyMVdhbGxldCA/IChcbiAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi0yXCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+QWRkcmVzczo8L3NwYW4+eycgJ31cbiAgICAgICAgICAgICAgICAgIDxzcGFuIHRpdGxlPXtwbGF5ZXIxV2FsbGV0LmFkZHJlc3N9IGNsYXNzTmFtZT1cImN1cnNvci1oZWxwXCI+e3BsYXllcjFXYWxsZXQuYWRkcmVzcy5zdWJzdHJpbmcoMCwgNil9Li4ue3BsYXllcjFXYWxsZXQuYWRkcmVzcy5zdWJzdHJpbmcocGxheWVyMVdhbGxldC5hZGRyZXNzLmxlbmd0aCAtIDQpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItNFwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkJhbGFuY2U6PC9zcGFuPiB7cGxheWVyMVdhbGxldC5iYWxhbmNlfSBBUFRcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IHNwYWNlLXgtMiBtYi00XCI+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXJlZC01MDAgaG92ZXI6YmctcmVkLTYwMCB0ZXh0LXdoaXRlIHB4LTMgcHktMSByb3VuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZGlzY29ubmVjdFdhbGxldCgxKX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgRGlzY29ubmVjdFxuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICB7dXNlU2ltdWxhdGlvbk1vZGUgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JheS01MDAgaG92ZXI6YmctZ3JheS02MDAgdGV4dC13aGl0ZSBweC0zIHB5LTEgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0TWFudWFsV2FsbGV0QWRkcmVzcygxKX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIEVkaXQgQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDAgbWItMlwiPntnZXRXYWxsZXRDb25uZWN0aW9uSW5zdHJ1Y3Rpb25zKDEpfTwvcD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCBob3ZlcjpiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlIHB4LTQgcHktMiByb3VuZGVkIGJsb2NrIHctZnVsbFwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBjb25uZWN0V2FsbGV0KDEpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENvbm5lY3QgUGxheWVyIDEgV2FsbGV0XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge3VzZVNpbXVsYXRpb25Nb2RlICYmIChcbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JheS01MDAgaG92ZXI6YmctZ3JheS02MDAgdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZCBibG9jayB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNYW51YWxXYWxsZXRBZGRyZXNzKDEpfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBTZXQgTWFudWFsIEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge2dhbWVTdGF0ZSA9PT0gJ2JldHRpbmcnICYmIHBsYXllcjFCZXQgPiAwICYmICFwbGF5ZXIxRXNjcm93TG9ja2VkICYmIHBsYXllcjJCZXQgPiAwICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00XCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItMlwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPllvdXIgQmV0Ojwvc3Bhbj4ge3BsYXllcjFCZXR9IEFQVFxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi0yIHRleHQtYmx1ZS03MDBcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5NaW5pbXVtIEJldDo8L3NwYW4+IHtNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KX0gQVBUXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIG1sLTFcIj4odGhpcyBhbW91bnQgd2lsbCBiZSBkZWR1Y3RlZCk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXllbGxvdy01MDAgaG92ZXI6YmcteWVsbG93LTYwMCB0ZXh0LXdoaXRlIHB4LTQgcHktMiByb3VuZGVkXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGxvY2tFc2Nyb3coMSl9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXBsYXllcjFXYWxsZXQgfHwgcGxheWVyMUVzY3Jvd0xvY2tlZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBMb2NrIFlvdXIgRXNjcm93XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgIHtwbGF5ZXIxRXNjcm93TG9ja2VkID8gJ1lvdXIgZXNjcm93IGlzIGxvY2tlZCEnIDogJ0xvY2sgeW91ciBlc2Nyb3cgdG8gcHJvY2VlZCB3aXRoIHRoZSBnYW1lJ31cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge3BsYXllcjFFc2Nyb3dMb2NrZWQgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTIgYmctZ3JlZW4tMTAwIHAtMiByb3VuZGVkXCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmVlbi03MDBcIj5Fc2Nyb3cgbG9ja2VkIHN1Y2Nlc3NmdWxseSE8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBNaWRkbGUgcGFuZWwgLSBHYW1lICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgcC00IHJvdW5kZWQgc2hhZG93XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTRcIj5cbiAgICAgICAgICAgICAgPEdhbWVEYXNoYm9hcmRcbiAgICAgICAgICAgICAgICBnYW1lU3RhdGU9e2dhbWVTdGF0ZX1cbiAgICAgICAgICAgICAgICBwbGF5ZXIxV2FsbGV0PXtwbGF5ZXIxV2FsbGV0fVxuICAgICAgICAgICAgICAgIHBsYXllcjJXYWxsZXQ9e3BsYXllcjJXYWxsZXR9XG4gICAgICAgICAgICAgICAgcGxheWVyMUJldD17cGxheWVyMUJldH1cbiAgICAgICAgICAgICAgICBwbGF5ZXIyQmV0PXtwbGF5ZXIyQmV0fVxuICAgICAgICAgICAgICAgIHBsYXllcjFFc2Nyb3dMb2NrZWQ9e3BsYXllcjFFc2Nyb3dMb2NrZWR9XG4gICAgICAgICAgICAgICAgcGxheWVyMkVzY3Jvd0xvY2tlZD17cGxheWVyMkVzY3Jvd0xvY2tlZH1cbiAgICAgICAgICAgICAgICBlc2Nyb3dMb2NrZWQ9e2VzY3Jvd0xvY2tlZH1cbiAgICAgICAgICAgICAgICBmaW5hbEJldEFtb3VudD17ZmluYWxCZXRBbW91bnR9XG4gICAgICAgICAgICAgICAgd2lubmVyPXt3aW5uZXJ9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgey8qIFVuaWZpZWQgQmV0dGluZyBJbnRlcmZhY2UgLSBTaG93IHdoZW4gYm90aCB3YWxsZXRzIGFyZSBjb25uZWN0ZWQgYW5kIGluIHdhaXRpbmcgc3RhdGUgKi99XG4gICAgICAgICAgICB7Z2FtZVN0YXRlID09PSAnd2FpdGluZycgJiYgcGxheWVyMVdhbGxldCAmJiBwbGF5ZXIyV2FsbGV0ICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02IHAtNCBib3JkZXIgYm9yZGVyLXllbGxvdy0yMDAgYmcteWVsbG93LTUwIHJvdW5kZWRcIj5cbiAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgdGV4dC1jZW50ZXIgbWItM1wiPkFubm91bmNlIEJldHM8L2gzPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtNCBtYi00XCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWNlbnRlciBtYi0xXCI+UGxheWVyIDEgQmV0PC9wPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjAuMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMC4xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtwbGF5ZXIxQmV0fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRQbGF5ZXIxQmV0KHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpIHx8IDApfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJvcmRlciByb3VuZGVkIHctZnVsbCB0ZXh0LWNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIGFtb3VudFwiXG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC0yXCI+QVBUPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1jZW50ZXIgbWItMVwiPlBsYXllciAyIEJldDwvcD5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIwLjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjAuMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17cGxheWVyMkJldH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UGxheWVyMkJldChwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKSB8fCAwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMiBib3JkZXIgcm91bmRlZCB3LWZ1bGwgdGV4dC1jZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciBhbW91bnRcIlxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtMlwiPkFQVDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXthbm5vdW5jZVVuaWZpZWRCZXR9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXBsYXllcjFXYWxsZXQgfHwgIXBsYXllcjJXYWxsZXQgfHwgcGxheWVyMUJldCA8PSAwIHx8IHBsYXllcjJCZXQgPD0gMH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBiZy1ncmVlbi02MDAgaG92ZXI6YmctZ3JlZW4tNzAwIHRleHQtd2hpdGUgcHktMyBweC00IHJvdW5kZWQtbGcgZm9udC1ib2xkIHRleHQtbGdcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIEFubm91bmNlIEJldHMgJiBDYWxjdWxhdGUgTWluaW11bVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTYwMCBtdC0yXCI+XG4gICAgICAgICAgICAgICAgICBUaGlzIHdpbGwgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJldCBhbW91bnQgZnJvbSBib3RoIHBsYXllcnNcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi00IGFzcGVjdC1zcXVhcmUgbWF4LXctbWQgbXgtYXV0b1wiPlxuICAgICAgICAgICAgICA8Q2hlc3Nib2FyZFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uPXtnYW1lLmZlbigpfVxuICAgICAgICAgICAgICAgIG9uUGllY2VEcm9wPXtvbkRyb3B9XG4gICAgICAgICAgICAgICAgYm9hcmRPcmllbnRhdGlvbj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7Z2FtZVN0YXRlID09PSAncGxheWluZycgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItMiB0ZXh0LWxnIGZvbnQtc2VtaWJvbGRcIj5cbiAgICAgICAgICAgICAgICAgIEN1cnJlbnQgUGxheWVyOiB7Y3VycmVudFBsYXllciA9PT0gJ3doaXRlJyA/ICdXaGl0ZSAoUGxheWVyIDEpJyA6ICdCbGFjayAoUGxheWVyIDIpJ31cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItNCB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgICBUb3RhbCBQb29sOiB7ZmluYWxCZXRBbW91bnR9IEFQVFxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1yZWQtNTAwIGhvdmVyOmJnLXJlZC02MDAgdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZCBtci0yXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGZvcmZlaXRHYW1lKGN1cnJlbnRQbGF5ZXIgPT09ICd3aGl0ZScgPyAxIDogMil9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgRm9yZmVpdFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHtnYW1lU3RhdGUgPT09ICdjb21wbGV0ZWQnICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBtdC00XCI+XG4gICAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1ib2xkIG1iLTJcIj5cbiAgICAgICAgICAgICAgICAgIHt3aW5uZXIgPT09ICdkcmF3JyA/ICdHYW1lIEVuZGVkIGluIGEgRHJhdycgOiBgJHt3aW5uZXIgPT09ICdwbGF5ZXIxJyA/ICdQbGF5ZXIgMScgOiAnUGxheWVyIDInfSBXaW5zIWB9XG4gICAgICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgICB7d2lubmVyID09PSAnZHJhdycgXG4gICAgICAgICAgICAgICAgICAgID8gJ0JvdGggcGxheWVycyByZWNlaXZlIHRoZWlyIGJldHMgYmFjaycgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7d2lubmVyID09PSAncGxheWVyMScgPyAnUGxheWVyIDEnIDogJ1BsYXllciAyJ30gcmVjZWl2ZXMgJHtmaW5hbEJldEFtb3VudH0gQVBUYH1cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgaG92ZXI6YmctYmx1ZS02MDAgdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtzdGFydE5ld0dhbWV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgU3RhcnQgTmV3IEdhbWVcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFJpZ2h0IHBhbmVsIC0gUGxheWVyIDIgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTEwMCBwLTQgcm91bmRlZCBzaGFkb3dcIj5cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCBtYi00XCI+UGxheWVyIDIgKEJsYWNrKTwvaDI+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHtwbGF5ZXIyV2FsbGV0ID8gKFxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm1iLTJcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5BZGRyZXNzOjwvc3Bhbj57JyAnfVxuICAgICAgICAgICAgICAgICAgPHNwYW4gdGl0bGU9e3BsYXllcjJXYWxsZXQuYWRkcmVzc30gY2xhc3NOYW1lPVwiY3Vyc29yLWhlbHBcIj57cGxheWVyMldhbGxldC5hZGRyZXNzLnN1YnN0cmluZygwLCA2KX0uLi57cGxheWVyMldhbGxldC5hZGRyZXNzLnN1YnN0cmluZyhwbGF5ZXIyV2FsbGV0LmFkZHJlc3MubGVuZ3RoIC0gNCl9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+QmFsYW5jZTo8L3NwYW4+IHtwbGF5ZXIyV2FsbGV0LmJhbGFuY2V9IEFQVFxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC0yIG1iLTRcIj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBkaXNjb25uZWN0V2FsbGV0KDIpfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBEaXNjb25uZWN0XG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIHt1c2VTaW11bGF0aW9uTW9kZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmF5LTUwMCBob3ZlcjpiZy1ncmF5LTYwMCB0ZXh0LXdoaXRlIHB4LTMgcHktMSByb3VuZGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNYW51YWxXYWxsZXRBZGRyZXNzKDIpfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgRWRpdCBBZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktM1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmcteWVsbG93LTUwIGJvcmRlciBib3JkZXIteWVsbG93LTIwMCBwLTMgcm91bmRlZCB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXllbGxvdy04MDAgd2hpdGVzcGFjZS1wcmUtbGluZSBmb250LW1lZGl1bVwiPntnZXRXYWxsZXRDb25uZWN0aW9uSW5zdHJ1Y3Rpb25zKDIpfTwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1wdXJwbGUtNTAwIGhvdmVyOmJnLXB1cnBsZS02MDAgdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZCBibG9jayB3LWZ1bGwgZm9udC1ib2xkXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2Nvbm5lY3RQbGF5ZXIyV2FsbGV0fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENvbm5lY3QgUGxheWVyIDIgV2FsbGV0XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAge3VzZVNpbXVsYXRpb25Nb2RlICYmIChcbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JheS01MDAgaG92ZXI6YmctZ3JheS02MDAgdGV4dC13aGl0ZSBweC00IHB5LTIgcm91bmRlZCBibG9jayB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRNYW51YWxXYWxsZXRBZGRyZXNzKDIpfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBTZXQgTWFudWFsIEFkZHJlc3NcbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge2dhbWVTdGF0ZSA9PT0gJ2JldHRpbmcnICYmIHBsYXllcjJCZXQgPiAwICYmICFwbGF5ZXIyRXNjcm93TG9ja2VkICYmIHBsYXllcjFCZXQgPiAwICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00XCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItMlwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPllvdXIgQmV0Ojwvc3Bhbj4ge3BsYXllcjJCZXR9IEFQVFxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi0yIHRleHQtYmx1ZS03MDBcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5NaW5pbXVtIEJldDo8L3NwYW4+IHtNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KX0gQVBUXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIG1sLTFcIj4odGhpcyBhbW91bnQgd2lsbCBiZSBkZWR1Y3RlZCk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXllbGxvdy01MDAgaG92ZXI6YmcteWVsbG93LTYwMCB0ZXh0LXdoaXRlIHB4LTQgcHktMiByb3VuZGVkXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGxvY2tFc2Nyb3coMil9XG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXBsYXllcjJXYWxsZXQgfHwgcGxheWVyMkVzY3Jvd0xvY2tlZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBMb2NrIFlvdXIgRXNjcm93XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgIHtwbGF5ZXIyRXNjcm93TG9ja2VkID8gJ1lvdXIgZXNjcm93IGlzIGxvY2tlZCEnIDogJ0xvY2sgeW91ciBlc2Nyb3cgdG8gcHJvY2VlZCB3aXRoIHRoZSBnYW1lJ31cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge3BsYXllcjJFc2Nyb3dMb2NrZWQgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTIgYmctZ3JlZW4tMTAwIHAtMiByb3VuZGVkXCI+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmVlbi03MDBcIj5Fc2Nyb3cgbG9ja2VkIHN1Y2Nlc3NmdWxseSE8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7LyogU2ltdWxhdGlvbiBtb2RlIHRvZ2dsZSBhbmQgY29udHJhY3Qgc3RhdHVzICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC04IHAtNCBiZy1ncmF5LTIwMCByb3VuZGVkXCI+XG4gICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+Q29udHJhY3QgU3RhdHVzPC9oMz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0yIGdhcC00XCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+RXNjcm93IEFkZHJlc3M6PC9zdHJvbmc+IHtlc2Nyb3dBZGRyZXNzIHx8ICdOb3QgY29ubmVjdGVkJ308L3A+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlN0YXR1czo8L3N0cm9uZz4ge0VzY3Jvd1N0YXR1c1tlc2Nyb3dTdGF0dXNdfTwvcD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+RXNjcm93IEJhbGFuY2U6PC9zdHJvbmc+IHtlc2Nyb3dCYWxhbmNlfSBBUFQ8L3A+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHsvKiBFc2Nyb3cgd2FsbGV0IGNvbm5lY3Rpb24gcGFuZWwgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJnLWluZGlnby01MCBib3JkZXIgYm9yZGVyLWluZGlnby0yMDAgcm91bmRlZFwiPlxuICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQtaW5kaWdvLTgwMFwiPkVzY3JvdyBXYWxsZXQ8L2g0PlxuICAgICAgICAgICAgICB7ZXNjcm93QWRkcmVzcyA/IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTcwMFwiPkVzY3JvdyB3YWxsZXQgY29ubmVjdGVkOjwvcD5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtbW9ubyB0ZXh0LXNtIG10LTFcIj57ZXNjcm93QWRkcmVzc308L3A+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTIgYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEVzY3Jvd0FkZHJlc3MobnVsbCl9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIERpc2Nvbm5lY3QgRXNjcm93XG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTcwMCBtYi0yXCI+Q29ubmVjdCB5b3VyIGVzY3JvdyB3YWxsZXQ6PC9wPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNjAwIGhvdmVyOmJnLWluZGlnby03MDAgdGV4dC13aGl0ZSBweC0zIHB5LTIgcm91bmRlZCB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtjb25uZWN0RXNjcm93V2FsbGV0fVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17dXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIENvbm5lY3QgRXNjcm93IFdhbGxldFxuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtaW5kaWdvLTYwMCBtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAgIFRoZSBlc2Nyb3cgd2FsbGV0IHdpbGwgaG9sZCBmdW5kcyBkdXJpbmcgdGhlIGdhbWUgYW5kIGRpc3RyaWJ1dGUgdG8gdGhlIHdpbm5lci5cbiAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICB7LyogV2FsbGV0IENvbm5lY3Rpb24gVGlwcyAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTIgYmctYmx1ZS01MCBib3JkZXIgYm9yZGVyLWJsdWUtMjAwIHJvdW5kZWRcIj5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ibHVlLTgwMCBmb250LW1lZGl1bVwiPjMtV2FsbGV0IFNldHVwIEluc3RydWN0aW9uczo8L3A+XG4gICAgICAgICAgICAgIDxvbCBjbGFzc05hbWU9XCJsaXN0LWRlY2ltYWwgbGlzdC1pbnNpZGUgdGV4dC1ibHVlLTcwMCBwbC0yIHRleHQtc20gc3BhY2UteS0xIG10LTFcIj5cbiAgICAgICAgICAgICAgICA8bGk+Q29ubmVjdCBQbGF5ZXIgMSB3YWxsZXQgZmlyc3Q8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5Db25uZWN0IFBsYXllciAyIHdhbGxldCBzZWNvbmQgKG1ha2Ugc3VyZSB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgd2FsbGV0IGluIFBldHJhKTwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkNvbm5lY3QgdGhlIEVzY3JvdyB3YWxsZXQgdGhpcmQgKHNob3VsZCBiZSBhIHNlcGFyYXRlIHdhbGxldCBmcm9tIGJvdGggcGxheWVycyk8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5QbGFjZSBiZXRzIGFuZCBsb2NrIGVzY3JvdyB0byBzdGFydCB0aGUgZ2FtZTwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkFmdGVyIGdhbWUgY29tcGxldGVzLCB0aGUgZXNjcm93IHdhbGxldCB3aWxsIHBheSB0aGUgd2lubmVyPC9saT5cbiAgICAgICAgICAgICAgPC9vbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgaWQ9XCJzaW11bGF0aW9uTW9kZVwiXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17dXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRVc2VTaW11bGF0aW9uTW9kZShlLnRhcmdldC5jaGVja2VkKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtci0yXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJzaW11bGF0aW9uTW9kZVwiPlNpbXVsYXRpb24gTW9kZSAoTm8gcmVhbCB0cmFuc2FjdGlvbnMpPC9sYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNjAwIG10LTFcIj5cbiAgICAgICAgICAgICAgRW5hYmxlIHNpbXVsYXRpb24gbW9kZSB0byB0ZXN0IHRoZSBnYW1lIGZsb3cgd2l0aG91dCBhY3R1YWwgYmxvY2tjaGFpbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIGhvdmVyOmJnLWJsdWUtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWQgbXItMlwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17aW5pdGlhbGl6ZUVzY3Jvd31cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17dXNlU2ltdWxhdGlvbk1vZGUgfHwgIWVzY3Jvd0FkZHJlc3MgfHwgIXBsYXllcjFXYWxsZXQgfHwgIXBsYXllcjJXYWxsZXR9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBJbml0aWFsaXplIEVzY3Jvd1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCBob3ZlcjpiZy1ncmVlbi02MDAgdGV4dC13aGl0ZSBweC0zIHB5LTEgcm91bmRlZCBtci0yXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtjcmVhdGVTaW11bGF0ZWRFc2Nyb3d9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyF1c2VTaW11bGF0aW9uTW9kZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENyZWF0ZSBTaW11bGF0ZWQgRXNjcm93XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWQgbXItMlwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17cmVzZXRHYW1lU3RhdGV9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBSZXNldCBHYW1lXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmcteWVsbG93LTUwMCBob3ZlcjpiZy15ZWxsb3ctNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWRcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3Jlc2V0V2FsbGV0Q29ubmVjdGlvbnN9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBSZXNldCBBbGwgV2FsbGV0c1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwiSGVhZCIsIkNoZXNzYm9hcmQiLCJDaGVzcyIsIkdhbWVEYXNoYm9hcmQiLCJ1c2VXYWxsZXQiLCJBcHRvc0NsaWVudCIsIkVzY3Jvd0NvbnRyYWN0QWRhcHRlciIsIkVzY3Jvd1N0YXR1cyIsIkhvbWUiLCJnYW1lIiwic2V0R2FtZSIsImdhbWVTdGF0ZSIsInNldEdhbWVTdGF0ZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjbGllbnQiLCJwbGF5ZXIxV2FsbGV0Iiwic2V0UGxheWVyMVdhbGxldCIsInBsYXllcjJXYWxsZXQiLCJzZXRQbGF5ZXIyV2FsbGV0IiwicGxheWVyMUJldCIsInNldFBsYXllcjFCZXQiLCJwbGF5ZXIyQmV0Iiwic2V0UGxheWVyMkJldCIsImZpbmFsQmV0QW1vdW50Iiwic2V0RmluYWxCZXRBbW91bnQiLCJhaUVuYWJsZWQiLCJzZXRBaUVuYWJsZWQiLCJlc2Nyb3dBZGFwdGVyIiwidXNlU2ltdWxhdGlvbk1vZGUiLCJzZXRVc2VTaW11bGF0aW9uTW9kZSIsImVzY3Jvd0xvY2tlZCIsInNldEVzY3Jvd0xvY2tlZCIsInBsYXllcjFFc2Nyb3dMb2NrZWQiLCJzZXRQbGF5ZXIxRXNjcm93TG9ja2VkIiwicGxheWVyMkVzY3Jvd0xvY2tlZCIsInNldFBsYXllcjJFc2Nyb3dMb2NrZWQiLCJjdXJyZW50UGxheWVyIiwic2V0Q3VycmVudFBsYXllciIsImFjdGl2ZVBsYXllcldhbGxldCIsInNldEFjdGl2ZVBsYXllcldhbGxldCIsImVzY3Jvd0FkZHJlc3MiLCJzZXRFc2Nyb3dBZGRyZXNzIiwiZXNjcm93U3RhdHVzIiwic2V0RXNjcm93U3RhdHVzIiwiUEVORElORyIsImVzY3Jvd0JhbGFuY2UiLCJzZXRFc2Nyb3dCYWxhbmNlIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJhY2NvdW50IiwiY29ubmVjdGVkIiwic2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uIiwid2lubmVyIiwic2V0V2lubmVyIiwiZ2V0QWNjb3VudEJhbGFuY2UiLCJhZGRyZXNzIiwicmVzb3VyY2VzIiwiZ2V0QWNjb3VudFJlc291cmNlcyIsImFwdG9zQ29pblJlc291cmNlIiwiZmluZCIsInIiLCJ0eXBlIiwiYmFsYW5jZSIsImRhdGEiLCJjb2luIiwidmFsdWUiLCJOdW1iZXIiLCJjb25zb2xlIiwibG9nIiwiY3JlYXRlU2ltdWxhdGVkRXNjcm93IiwicmVzZXRXYWxsZXRDb25uZWN0aW9ucyIsImluaXRpYWxpemVFc2Nyb3ciLCJzaW11bGF0ZWRBZGRyZXNzIiwiRGF0ZSIsIm5vdyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNpbUVycm9yIiwidG9TdHJpbmciLCJjcmVhdGVFc2Nyb3dSZXN1bHQiLCJjcmVhdGVFc2Nyb3ciLCJ3aW5kb3ciLCJhcHRvcyIsImN1cnJlbnRBY2NvdW50IiwiZSIsImFsZXJ0Iiwid2FybiIsIkVycm9yIiwibWVzc2FnZSIsImVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQiLCJwbGF5ZXJOdW1iZXIiLCJyZXNwb25zZSIsImNvbm5lY3RQbGF5ZXJXYWxsZXQiLCJwbGF5ZXJXYWxsZXQiLCJvdGhlclBsYXllcldhbGxldCIsImNvbmZpcm1Vc2UiLCJjb25maXJtIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwid2FsbGV0SW5mbyIsImNvbm5lY3RFc2Nyb3dXYWxsZXQiLCJwYXlXaW5uZXIiLCJlc2Nyb3dXYWxsZXRDb25uZWN0ZWQiLCJwYXlsb2FkMSIsImZ1bmN0aW9uIiwidHlwZV9hcmd1bWVudHMiLCJhcmd1bWVudHMiLCJNYXRoIiwiZmxvb3IiLCJ0eFJlc3BvbnNlMSIsInBheWxvYWQyIiwidHhSZXNwb25zZTIiLCJ3aW5uZXJXYWxsZXQiLCJwYXlsb2FkIiwidHhSZXNwb25zZSIsIm5ld0JhbGFuY2UxIiwibmV3QmFsYW5jZTIiLCJwYXlvdXRBbW91bnQiLCJyZXNldEdhbWVTdGF0ZSIsImJvdGhXYWxsZXRzQ29ubmVjdGVkIiwibmVlZHNQbGF5ZXIxQmV0IiwibmVlZHNQbGF5ZXIyQmV0IiwiZ2V0V2FsbGV0Q29ubmVjdGlvbkluc3RydWN0aW9ucyIsImNvbm5lY3RQbGF5ZXIyV2FsbGV0Iiwid2FsbGV0UHJlZmFjZSIsImRpdiIsImNsYXNzTmFtZSIsImgyIiwicCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJhbm5vdW5jZVVuaWZpZWRCZXQiLCJtaW5pbXVtQmV0IiwibWluIiwibG9ja0VzY3JvdyIsInByZXZCYWxhbmNlIiwiaXNXYWxsZXRDb25uZWN0ZWQiLCJ0cmFuc2ZlclN1Y2Nlc3MiLCJ0cmFuc2ZlclRvRXNjcm93IiwibmV3QmFsYW5jZSIsImVzY3Jvd0JhbGFuY2VSZXN1bHQiLCJmaW5hbFBvb2xBbW91bnQiLCJQTEFZSU5HIiwiY2hlY2tBbmRTdGFydEdhbWUiLCJwbGF5ZXIxTG9ja2VkIiwicGxheWVyMkxvY2tlZCIsImN1cnJlbnRHYW1lU3RhdGUiLCJtaW5CZXRBbW91bnQiLCJhbW91bnQiLCJ0YXJnZXRBZGRyZXNzIiwiaXNDb3JyZWN0V2FsbGV0Q29ubmVjdGVkIiwidHJpbSIsImFtb3VudEluT2N0YXMiLCJKU09OIiwic3RyaW5naWZ5IiwidHhIYXNoIiwiZm9jdXMiLCJoYXNoIiwiZGlyZWN0RXJyb3IiLCJhZGFwdGVyRXJyb3IiLCJ0eFJlc3VsdCIsIndhaXRGb3JUcmFuc2FjdGlvbldpdGhSZXN1bHQiLCJjb25maXJtRXJyb3IiLCJ0eEVycm9yIiwic3RhcnROZXdHYW1lIiwiZm9yZmVpdEdhbWUiLCJoYW5kbGVHYW1lRW5kIiwiY29ubmVjdFdhbGxldCIsImRpc2Nvbm5lY3RXYWxsZXQiLCJzZXRNYW51YWxXYWxsZXRBZGRyZXNzIiwicHJvbXB0IiwibWFrZUFNb3ZlIiwibW92ZSIsImdhbWVDb3B5IiwiZmVuIiwicmVzdWx0IiwidHVybiIsIm9uRHJvcCIsInNvdXJjZVNxdWFyZSIsInRhcmdldFNxdWFyZSIsImN1cnJlbnRUdXJuIiwiaXNDb3JyZWN0UGxheWVyVHVybiIsImZyb20iLCJ0byIsInByb21vdGlvbiIsImlzR2FtZU92ZXIiLCJ3aW5uZXJQYXJhbSIsImN1cnJlbnRXaW5uZXIiLCJpc0RyYXciLCJDT01QTEVURUQiLCJ0aXRsZSIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsImxpbmsiLCJyZWwiLCJocmVmIiwiaDEiLCJzdHJvbmciLCJzcGFuIiwiZGlzYWJsZWQiLCJoMyIsImlucHV0Iiwic3RlcCIsIm9uQ2hhbmdlIiwicGFyc2VGbG9hdCIsInRhcmdldCIsInBsYWNlaG9sZGVyIiwicG9zaXRpb24iLCJvblBpZWNlRHJvcCIsImJvYXJkT3JpZW50YXRpb24iLCJoNCIsIm9sIiwibGkiLCJpZCIsImNoZWNrZWQiLCJsYWJlbCIsImh0bWxGb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/react-chessboard/dist/index.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-chessboard/dist/index.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chessboard: function() { return /* binding */ Chessboard; },\n/* harmony export */   ChessboardDnDProvider: function() { return /* binding */ ChessboardDnDProvider; },\n/* harmony export */   SparePiece: function() { return /* binding */ SparePiece; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst COLUMNS = \"abcdefgh\".split(\"\");\r\nconst START_POSITION_OBJECT = {\r\n    a8: \"bR\",\r\n    b8: \"bN\",\r\n    c8: \"bB\",\r\n    d8: \"bQ\",\r\n    e8: \"bK\",\r\n    f8: \"bB\",\r\n    g8: \"bN\",\r\n    h8: \"bR\",\r\n    a7: \"bP\",\r\n    b7: \"bP\",\r\n    c7: \"bP\",\r\n    d7: \"bP\",\r\n    e7: \"bP\",\r\n    f7: \"bP\",\r\n    g7: \"bP\",\r\n    h7: \"bP\",\r\n    a2: \"wP\",\r\n    b2: \"wP\",\r\n    c2: \"wP\",\r\n    d2: \"wP\",\r\n    e2: \"wP\",\r\n    f2: \"wP\",\r\n    g2: \"wP\",\r\n    h2: \"wP\",\r\n    a1: \"wR\",\r\n    b1: \"wN\",\r\n    c1: \"wB\",\r\n    d1: \"wQ\",\r\n    e1: \"wK\",\r\n    f1: \"wB\",\r\n    g1: \"wN\",\r\n    h1: \"wR\",\r\n};\r\nconst WHITE_COLUMN_VALUES = {\r\n    a: 0,\r\n    b: 1,\r\n    c: 2,\r\n    d: 3,\r\n    e: 4,\r\n    f: 5,\r\n    g: 6,\r\n    h: 7,\r\n};\r\nconst BLACK_COLUMN_VALUES = {\r\n    a: 7,\r\n    b: 6,\r\n    c: 5,\r\n    d: 4,\r\n    e: 3,\r\n    f: 2,\r\n    g: 1,\r\n    h: 0,\r\n};\r\nconst WHITE_ROWS = [7, 6, 5, 4, 3, 2, 1, 0];\r\nconst BLACK_ROWS = [0, 1, 2, 3, 4, 5, 6, 7];\n\n// https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\r\n// By en:User:Cburnett - Own work\r\n// This W3C - unspecified vector image was created with Inkscape., CC BY - SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1499810\r\nconst defaultPieces = {\r\n    wP: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\", style: {\r\n                opacity: \"1\",\r\n                fill: \"#ffffff\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"nonzero\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"miter\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }) }))),\r\n    wR: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"#ffffff\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14\", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 34,14 L 31,17 L 14,17 L 11,14\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 31,17 L 31,29.5 L 14,29.5 L 14,17\", style: { strokeLinecap: \"butt\", strokeLinejoin: \"miter\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,14 L 34,14\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" } })] })) }))),\r\n    wN: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"none\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\", style: { fill: \"#ffffff\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\", style: { fill: \"#ffffff\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\", style: { fill: \"#000000\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\", transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\", style: { fill: \"#000000\", stroke: \"#000000\" } })] })) }))),\r\n    wB: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"none\",\r\n                fillRule: \"evenodd\",\r\n                fillOpacity: \"1\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: { fill: \"#ffffff\", stroke: \"#000000\", strokeLinecap: \"butt\" } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" } })] })) }))),\r\n    wQ: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                fill: \"#ffffff\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinejoin: \"round\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11.5,30 C 15,29 30,29 33.5,30\", style: { fill: \"none\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12,33.5 C 18,32.5 27,32.5 33,33.5\", style: { fill: \"none\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"6\", cy: \"12\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"14\", cy: \"9\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"22.5\", cy: \"8\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"31\", cy: \"9\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"39\", cy: \"12\", r: \"2\" })] })) }))),\r\n    wK: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                fill: \"none\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22.5,11.63 L 22.5,6\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 20,8 L 25,8\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\", style: {\r\n                        fill: \"#ffffff\",\r\n                        stroke: \"#000000\",\r\n                        strokeLinecap: \"butt\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\", style: { fill: \"#ffffff\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,30 C 18,27 27,27 32.5,30\", style: { fill: \"none\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5\", style: { fill: \"none\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,37 C 18,34 27,34 32.5,37\", style: { fill: \"none\", stroke: \"#000000\" } })] })) }))),\r\n    bP: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z\", style: {\r\n                opacity: \"1\",\r\n                fill: \"#000000\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"nonzero\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"miter\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }) }))),\r\n    bR: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"#000000\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z \", style: { strokeLinecap: \"butt\", strokeLinejoin: \"miter\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z \", style: { strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12,35.5 L 33,35.5 L 33,35.5\", style: {\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: \"1\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 13,31.5 L 32,31.5\", style: {\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: \"1\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 14,29.5 L 31,29.5\", style: {\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: \"1\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 14,16.5 L 31,16.5\", style: {\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: \"1\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,14 L 34,14\", style: {\r\n                        fill: \"none\",\r\n                        stroke: \"#ffffff\",\r\n                        strokeWidth: \"1\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } })] })) }))),\r\n    bN: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"none\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18\", style: { fill: \"#000000\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10\", style: { fill: \"#000000\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z\", style: { fill: \"#ffffff\", stroke: \"#ffffff\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z\", transform: \"matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)\", style: { fill: \"#ffffff\", stroke: \"#ffffff\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z \", style: { fill: \"#ffffff\", stroke: \"none\" } })] })) }))),\r\n    bB: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                opacity: \"1\",\r\n                fill: \"none\",\r\n                fillRule: \"evenodd\",\r\n                fillOpacity: \"1\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: { fill: \"#000000\", stroke: \"#000000\", strokeLinecap: \"butt\" } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z\" })] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18\", style: { fill: \"none\", stroke: \"#ffffff\", strokeLinejoin: \"miter\" } })] })) }))),\r\n    bQ: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                fill: \"#000000\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z\", style: { strokeLinecap: \"butt\", fill: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11.5,30 C 15,29 30,29 33.5,30\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"m 12,33.5 c 6,-1 15,-1 21,0\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"6\", cy: \"12\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"14\", cy: \"9\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"22.5\", cy: \"8\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"31\", cy: \"9\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", { cx: \"39\", cy: \"12\", r: \"2\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,38.5 A 35,35 1 0 0 34,38.5\", style: { fill: \"none\", stroke: \"#000000\", strokeLinecap: \"butt\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: { fill: \"none\", stroke: \"#ffffff\" } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11,29 A 35,35 1 0 1 34,29\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,31.5 L 32.5,31.5\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 11.5,34.5 A 35,35 1 0 0 33.5,34.5\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 10.5,37.5 A 35,35 1 0 0 34.5,37.5\" })] }))] })) }))),\r\n    bK: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", width: \"45\", height: \"45\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", Object.assign({ style: {\r\n                fill: \"none\",\r\n                fillOpacity: \"1\",\r\n                fillRule: \"evenodd\",\r\n                stroke: \"#000000\",\r\n                strokeWidth: \"1.5\",\r\n                strokeLinecap: \"round\",\r\n                strokeLinejoin: \"round\",\r\n                strokeMiterlimit: \"4\",\r\n                strokeDasharray: \"none\",\r\n                strokeOpacity: \"1\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22.5,11.63 L 22.5,6\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" }, id: \"path6570\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25\", style: {\r\n                        fill: \"#000000\",\r\n                        fillOpacity: \"1\",\r\n                        strokeLinecap: \"butt\",\r\n                        strokeLinejoin: \"miter\",\r\n                    } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37\", style: { fill: \"#000000\", stroke: \"#000000\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 20,8 L 25,8\", style: { fill: \"none\", stroke: \"#000000\", strokeLinejoin: \"miter\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5\", style: { fill: \"none\", stroke: \"#ffffff\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { d: \"M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37\", style: { fill: \"none\", stroke: \"#ffffff\" } })] })) }))),\r\n};\n\n/**\r\n * Retrieves the coordinates at the centre of the requested square, relative to the top left of the board (0, 0).\r\n */\r\nfunction getRelativeCoords(boardOrientation, boardWidth, square) {\r\n    const squareWidth = boardWidth / 8;\r\n    const columns = boardOrientation === \"white\" ? WHITE_COLUMN_VALUES : BLACK_COLUMN_VALUES;\r\n    const rows = boardOrientation === \"white\" ? WHITE_ROWS : BLACK_ROWS;\r\n    const x = columns[square[0]] * squareWidth + squareWidth / 2;\r\n    const y = rows[parseInt(square[1], 10) - 1] * squareWidth + squareWidth / 2;\r\n    return { x, y };\r\n}\r\n/**\r\n * Returns whether the passed position is different from the start position.\r\n */\r\nfunction isDifferentFromStart(newPosition) {\r\n    let isDifferent = false;\r\n    Object.keys(START_POSITION_OBJECT).forEach((square) => {\r\n        if (newPosition[square] !== START_POSITION_OBJECT[square])\r\n            isDifferent = true;\r\n    });\r\n    Object.keys(newPosition).forEach((square) => {\r\n        if (START_POSITION_OBJECT[square] !== newPosition[square])\r\n            isDifferent = true;\r\n    });\r\n    return isDifferent;\r\n}\r\n/**\r\n * Returns what pieces have been added and what pieces have been removed between board positions.\r\n */\r\nfunction getPositionDifferences(currentPosition, newPosition) {\r\n    const difference = {\r\n        removed: {},\r\n        added: {},\r\n    };\r\n    // removed from current\r\n    Object.keys(currentPosition).forEach((square) => {\r\n        if (newPosition[square] !== currentPosition[square])\r\n            difference.removed[square] = currentPosition[square];\r\n    });\r\n    // added from new\r\n    Object.keys(newPosition).forEach((square) => {\r\n        if (currentPosition[square] !== newPosition[square])\r\n            difference.added[square] = newPosition[square];\r\n    });\r\n    return difference;\r\n}\r\n/**\r\n * Converts a fen string or existing position object to a position object.\r\n */\r\nfunction convertPositionToObject(position) {\r\n    if (position === \"start\") {\r\n        return START_POSITION_OBJECT;\r\n    }\r\n    if (typeof position === \"string\") {\r\n        // attempt to convert fen to position object\r\n        return fenToObj(position);\r\n    }\r\n    return position;\r\n}\r\n/**\r\n * Converts a fen string to a position object.\r\n */\r\nfunction fenToObj(fen) {\r\n    if (!isValidFen(fen))\r\n        return {};\r\n    // cut off any move, castling, etc info from the end. we're only interested in position information\r\n    fen = fen.replace(/ .+$/, \"\");\r\n    const rows = fen.split(\"/\");\r\n    const position = {};\r\n    let currentRow = 8;\r\n    for (let i = 0; i < 8; i++) {\r\n        const row = rows[i].split(\"\");\r\n        let colIdx = 0;\r\n        // loop through each character in the FEN section\r\n        for (let j = 0; j < row.length; j++) {\r\n            // number / empty squares\r\n            if (row[j].search(/[1-8]/) !== -1) {\r\n                const numEmptySquares = parseInt(row[j], 10);\r\n                colIdx = colIdx + numEmptySquares;\r\n            }\r\n            else {\r\n                // piece\r\n                const square = COLUMNS[colIdx] + currentRow;\r\n                position[square] = fenToPieceCode(row[j]);\r\n                colIdx = colIdx + 1;\r\n            }\r\n        }\r\n        currentRow = currentRow - 1;\r\n    }\r\n    return position;\r\n}\r\n/**\r\n * Returns whether string is valid fen notation.\r\n */\r\nfunction isValidFen(fen) {\r\n    // cut off any move, castling, etc info from the end. we're only interested in position information\r\n    fen = fen.replace(/ .+$/, \"\");\r\n    // expand the empty square numbers to just 1s\r\n    fen = expandFenEmptySquares(fen);\r\n    // fen should be 8 sections separated by slashes\r\n    const chunks = fen.split(\"/\");\r\n    if (chunks.length !== 8)\r\n        return false;\r\n    // check each section\r\n    for (let i = 0; i < 8; i++) {\r\n        if (chunks[i].length !== 8 || chunks[i].search(/[^kqrnbpKQRNBP1]/) !== -1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Expand out fen notation to countable characters for validation\r\n */\r\nfunction expandFenEmptySquares(fen) {\r\n    return fen\r\n        .replace(/8/g, \"11111111\")\r\n        .replace(/7/g, \"1111111\")\r\n        .replace(/6/g, \"111111\")\r\n        .replace(/5/g, \"11111\")\r\n        .replace(/4/g, \"1111\")\r\n        .replace(/3/g, \"111\")\r\n        .replace(/2/g, \"11\");\r\n}\r\n/**\r\n * Convert fen piece code to camel case notation. e.g. bP, wK.\r\n */\r\nfunction fenToPieceCode(piece) {\r\n    // black piece\r\n    if (piece.toLowerCase() === piece) {\r\n        return (\"b\" + piece.toUpperCase());\r\n    }\r\n    // white piece\r\n    return (\"w\" + piece.toUpperCase());\r\n}\n\nconst useArrows = (customArrows, areArrowsAllowed = true, onArrowsChange, customArrowColor) => {\r\n    // arrows passed programatically to `ChessBoard` as a react prop\r\n    const [customArrowsSet, setCustomArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\r\n    // arrows drawn with mouse by user on the board\r\n    const [arrows, setArrows] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\r\n    // active arrow which user draws while dragging mouse\r\n    const [newArrow, setNewArrow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\r\n    // handle external `customArrows` props changes\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        if (Array.isArray(customArrows)) {\r\n            // so that custom arrows overwrite temporary arrows\r\n            clearArrows();\r\n            setCustomArrows(\r\n            //filter out arrows which starts and ends in the same square\r\n            customArrows === null || customArrows === void 0 ? void 0 : customArrows.filter((arrow) => arrow[0] !== arrow[1]));\r\n        }\r\n    }, [customArrows]);\r\n    // callback when arrows changed after user interaction\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        onArrowsChange === null || onArrowsChange === void 0 ? void 0 : onArrowsChange(arrows);\r\n    }, [arrows]);\r\n    // function clears all arrows drawed by user\r\n    function clearArrows() {\r\n        setArrows([]);\r\n        setNewArrow(undefined);\r\n    }\r\n    const drawNewArrow = (fromSquare, toSquare) => {\r\n        if (!areArrowsAllowed)\r\n            return;\r\n        setNewArrow([fromSquare, toSquare, customArrowColor]);\r\n    };\r\n    const allBoardArrows = [...arrows, ...customArrowsSet];\r\n    const onArrowDrawEnd = (fromSquare, toSquare) => {\r\n        if (fromSquare === toSquare || !areArrowsAllowed)\r\n            return;\r\n        let arrowsCopy;\r\n        const newArrow = [fromSquare, toSquare, customArrowColor];\r\n        const isNewArrowUnique = allBoardArrows.every(([arrowFrom, arrowTo]) => {\r\n            return !(arrowFrom === fromSquare && arrowTo === toSquare);\r\n        });\r\n        // add the newArrow to arrows array if it is unique\r\n        if (isNewArrowUnique) {\r\n            arrowsCopy = [...arrows, newArrow];\r\n        }\r\n        // remove it from the board if we already have same arrow in arrows array\r\n        else {\r\n            arrowsCopy = arrows.filter(([arrowFrom, arrowTo]) => {\r\n                return !(arrowFrom === fromSquare && arrowTo === toSquare);\r\n            });\r\n        }\r\n        setNewArrow(undefined);\r\n        setArrows(arrowsCopy);\r\n    };\r\n    return {\r\n        arrows: allBoardArrows,\r\n        newArrow,\r\n        clearArrows,\r\n        drawNewArrow,\r\n        setArrows,\r\n        onArrowDrawEnd,\r\n    };\r\n};\n\nconst ChessboardContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\r\nconst useChessboard = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardContext);\r\nconst ChessboardProvider = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ allowDragOutsideBoard = true, animationDuration = 300, areArrowsAllowed = true, arePiecesDraggable = true, arePremovesAllowed = false, autoPromoteToQueen = false, boardOrientation = \"white\", boardWidth, children, clearPremovesOnRightClick = true, customArrows, customArrowColor = \"rgb(255,170,0)\", customBoardStyle, customNotationStyle, customDarkSquareStyle = { backgroundColor: \"#B58863\" }, customDropSquareStyle = {\r\n    boxShadow: \"inset 0 0 1px 6px rgba(255,255,255,0.75)\",\r\n}, customLightSquareStyle = { backgroundColor: \"#F0D9B5\" }, customPieces, customPremoveDarkSquareStyle = { backgroundColor: \"#A42323\" }, customPremoveLightSquareStyle = { backgroundColor: \"#BD2828\" }, customSquare = \"div\", customSquareStyles, dropOffBoardAction = \"snapback\", id = 0, isDraggablePiece = () => true, getPositionObject = () => { }, onArrowsChange = () => { }, onDragOverSquare = () => { }, onMouseOutSquare = () => { }, onMouseOverSquare = () => { }, onPieceClick = () => { }, onPieceDragBegin = () => { }, onPieceDragEnd = () => { }, onPieceDrop = () => true, onPieceDropOffBoard = () => { }, onPromotionCheck = (sourceSquare, targetSquare, piece) => {\r\n    return (((piece === \"wP\" &&\r\n        sourceSquare[1] === \"7\" &&\r\n        targetSquare[1] === \"8\") ||\r\n        (piece === \"bP\" &&\r\n            sourceSquare[1] === \"2\" &&\r\n            targetSquare[1] === \"1\")) &&\r\n        Math.abs(sourceSquare.charCodeAt(0) - targetSquare.charCodeAt(0)) <= 1);\r\n}, onPromotionPieceSelect = () => true, onSparePieceDrop = () => true, onSquareClick = () => { }, onSquareRightClick = () => { }, position = \"start\", promotionDialogVariant = \"default\", promotionToSquare = null, showBoardNotation = true, showPromotionDialog = false, snapToCursor = true, }, ref) => {\r\n    // position stored and displayed on board\r\n    const [currentPosition, setCurrentPosition] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(convertPositionToObject(position));\r\n    // calculated differences between current and incoming positions\r\n    const [positionDifferences, setPositionDifferences] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({ removed: {}, added: {} });\r\n    // colour of last piece moved to determine if premoving\r\n    const [lastPieceColour, setLastPieceColour] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\r\n    // show / hide promotion dialog\r\n    const [showPromoteDialog, setShowPromoteDialog] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(showPromotionDialog && !autoPromoteToQueen);\r\n    // which square a pawn is being promoted to\r\n    const [promoteFromSquare, setPromoteFromSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\r\n    const [promoteToSquare, setPromoteToSquare] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(promotionToSquare);\r\n    // current premoves\r\n    const [premoves, setPremoves] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\r\n    // ref used to access current value during timeouts (closures)\r\n    const premovesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(premoves);\r\n    // current right mouse down square\r\n    const [currentRightClickDown, setCurrentRightClickDown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\r\n    // chess pieces/styling\r\n    const [chessPieces, setChessPieces] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Object.assign(Object.assign({}, defaultPieces), customPieces));\r\n    // whether the last move was a manual drop or not\r\n    const [wasManualDrop, setWasManualDrop] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\r\n    // the most recent timeout whilst waiting for animation to complete\r\n    const [previousTimeout, setPreviousTimeout] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\r\n    // if currently waiting for an animation to finish\r\n    const [isWaitingForAnimation, setIsWaitingForAnimation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\r\n    // last square dragged over for checking in touch events\r\n    const [lastSquareDraggedOver, setLastSquareDraggedOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\r\n    // open clearPremoves() to allow user to call on undo/reset/whenever\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, () => ({\r\n        clearPremoves(clearLastPieceColour = true) {\r\n            clearPremoves(clearLastPieceColour);\r\n        },\r\n    }));\r\n    // handle custom pieces change\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setChessPieces(Object.assign(Object.assign({}, defaultPieces), customPieces));\r\n    }, [customPieces]);\r\n    // handle promote changes\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setShowPromoteDialog(showPromotionDialog);\r\n        setPromoteToSquare(promotionToSquare);\r\n    }, [promotionToSquare, showPromotionDialog]);\r\n    // handle external position change\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        var _a, _b, _c;\r\n        // clear any open promotion dialogs\r\n        clearPromotion();\r\n        const newPosition = convertPositionToObject(position);\r\n        const differences = getPositionDifferences(currentPosition, newPosition);\r\n        const newPieceColour = ((_a = Object.keys(differences.added)) === null || _a === void 0 ? void 0 : _a.length) <= 2\r\n            ? (_c = (_b = Object.entries(differences.added)) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[1][0]\r\n            : undefined;\r\n        // external move has come in before animation is over\r\n        // cancel animation and immediately update position\r\n        if (isWaitingForAnimation) {\r\n            setCurrentPosition(newPosition);\r\n            setIsWaitingForAnimation(false);\r\n            arePremovesAllowed && attemptPremove(newPieceColour);\r\n            if (previousTimeout) {\r\n                clearTimeout(previousTimeout);\r\n            }\r\n        }\r\n        else {\r\n            // move was made using drag and drop\r\n            if (wasManualDrop) {\r\n                setCurrentPosition(newPosition);\r\n                setIsWaitingForAnimation(false);\r\n                arePremovesAllowed && attemptPremove(newPieceColour);\r\n            }\r\n            else {\r\n                // move was made by external position change\r\n                // if position === start then don't override newPieceColour\r\n                // needs isDifferentFromStart in scenario where premoves have been cleared upon board reset but first move is made by computer, the last move colour would need to be updated\r\n                if (isDifferentFromStart(newPosition) &&\r\n                    lastPieceColour !== undefined) {\r\n                    setLastPieceColour(newPieceColour);\r\n                }\r\n                else if (!isDifferentFromStart(newPosition)) {\r\n                    // position === start, likely a board reset. set to black to allow black to make premoves on first move\r\n                    setLastPieceColour(\"b\");\r\n                }\r\n                else {\r\n                    setLastPieceColour(undefined);\r\n                }\r\n                setPositionDifferences(differences);\r\n                // animate external move\r\n                setIsWaitingForAnimation(true);\r\n                const newTimeout = setTimeout(() => {\r\n                    setCurrentPosition(newPosition);\r\n                    setIsWaitingForAnimation(false);\r\n                    arePremovesAllowed && attemptPremove(newPieceColour);\r\n                }, animationDuration);\r\n                setPreviousTimeout(newTimeout);\r\n            }\r\n        }\r\n        // reset manual drop, ready for next move to be made by user or external\r\n        setWasManualDrop(false);\r\n        // inform latest position information\r\n        getPositionObject(newPosition);\r\n        // clear arrows\r\n        clearArrows();\r\n        // clear timeout on unmount\r\n        return () => {\r\n            clearTimeout(previousTimeout);\r\n        };\r\n    }, [position]);\r\n    const { arrows, newArrow, clearArrows, drawNewArrow, onArrowDrawEnd } = useArrows(customArrows, areArrowsAllowed, onArrowsChange, customArrowColor);\r\n    // handle drop position change\r\n    function handleSetPosition(sourceSq, targetSq, piece, wasManualDropOverride) {\r\n        // if dropped back down, don't do anything\r\n        if (sourceSq === targetSq) {\r\n            return;\r\n        }\r\n        clearArrows();\r\n        // if second move is made for same colour, or there are still premoves queued, then this move needs to be added to premove queue instead of played\r\n        // premoves length check for colour is added in because white could make 3 premoves, and then black responds to the first move (changing the last piece colour) and then white pre-moves again\r\n        if ((arePremovesAllowed && isWaitingForAnimation) ||\r\n            (arePremovesAllowed &&\r\n                (lastPieceColour === piece[0] ||\r\n                    premovesRef.current.filter((p) => p.piece[0] === piece[0])\r\n                        .length > 0))) {\r\n            const oldPremoves = [...premovesRef.current];\r\n            oldPremoves.push({ sourceSq, targetSq, piece });\r\n            premovesRef.current = oldPremoves;\r\n            setPremoves([...oldPremoves]);\r\n            clearPromotion();\r\n            return;\r\n        }\r\n        // if transitioning, don't allow new drop\r\n        if (!arePremovesAllowed && isWaitingForAnimation)\r\n            return;\r\n        const newOnDropPosition = Object.assign({}, currentPosition);\r\n        setWasManualDrop(!!wasManualDropOverride);\r\n        setLastPieceColour(piece[0]);\r\n        // if onPieceDrop function provided, execute it, position must be updated externally and captured by useEffect above for this move to show on board\r\n        if (onPieceDrop.length) {\r\n            const isValidMove = onPieceDrop(sourceSq, targetSq, piece);\r\n            if (!isValidMove) {\r\n                clearPremoves();\r\n                setWasManualDrop(false);\r\n            }\r\n        }\r\n        else {\r\n            // delete source piece\r\n            delete newOnDropPosition[sourceSq];\r\n            // add piece in new position\r\n            newOnDropPosition[targetSq] = piece;\r\n            setCurrentPosition(newOnDropPosition);\r\n        }\r\n        clearPromotion();\r\n        // inform latest position information\r\n        getPositionObject(newOnDropPosition);\r\n    }\r\n    function deletePieceFromSquare(square) {\r\n        const positionCopy = Object.assign({}, currentPosition);\r\n        delete positionCopy[square];\r\n        setCurrentPosition(positionCopy);\r\n        // inform latest position information\r\n        getPositionObject(positionCopy);\r\n    }\r\n    function attemptPremove(newPieceColour) {\r\n        if (premovesRef.current.length === 0)\r\n            return;\r\n        // get current value of premove as this is called in a timeout so value may have changed since timeout was set\r\n        const premove = premovesRef.current[0];\r\n        // if premove is a differing colour to last move made, then this move can be made\r\n        if (premove.piece[0] !== undefined &&\r\n            premove.piece[0] !== newPieceColour &&\r\n            onPieceDrop.length) {\r\n            setLastPieceColour(premove.piece[0]);\r\n            setWasManualDrop(true); // pre-move doesn't need animation\r\n            const isValidMove = onPieceDrop(premove.sourceSq, premove.targetSq, premove.piece);\r\n            // premove was successful and can be removed from queue\r\n            if (isValidMove) {\r\n                const oldPremoves = [...premovesRef.current];\r\n                oldPremoves.shift();\r\n                premovesRef.current = oldPremoves;\r\n                setPremoves([...oldPremoves]);\r\n            }\r\n            else {\r\n                // premove wasn't successful, clear premove queue\r\n                clearPremoves();\r\n            }\r\n        }\r\n    }\r\n    function handleSparePieceDrop(piece, targetSq) {\r\n        const isValidDrop = onSparePieceDrop(piece, targetSq);\r\n        if (!isValidDrop)\r\n            return;\r\n        const newOnDropPosition = Object.assign({}, currentPosition);\r\n        // add piece in new position\r\n        newOnDropPosition[targetSq] = piece;\r\n        setCurrentPosition(newOnDropPosition);\r\n        // inform latest position information\r\n        getPositionObject(newOnDropPosition);\r\n    }\r\n    function clearPremoves(clearLastPieceColour = true) {\r\n        // don't clear when right clicking to clear, otherwise you won't be able to premove again before next go\r\n        if (clearLastPieceColour)\r\n            setLastPieceColour(undefined);\r\n        premovesRef.current = [];\r\n        setPremoves([]);\r\n    }\r\n    function clearPromotion() {\r\n        setPromoteFromSquare(null);\r\n        setPromoteToSquare(null);\r\n        setShowPromoteDialog(false);\r\n    }\r\n    function onRightClickDown(square) {\r\n        setCurrentRightClickDown(square);\r\n    }\r\n    function onRightClickUp(square) {\r\n        if (currentRightClickDown) {\r\n            // same square, don't draw an arrow, but do clear premoves and run onSquareRightClick\r\n            if (currentRightClickDown === square) {\r\n                setCurrentRightClickDown(undefined);\r\n                clearPremovesOnRightClick && clearPremoves(false);\r\n                onSquareRightClick(square);\r\n                return;\r\n            }\r\n        }\r\n        else\r\n            setCurrentRightClickDown(undefined);\r\n    }\r\n    function clearCurrentRightClickDown() {\r\n        setCurrentRightClickDown(undefined);\r\n    }\r\n    const ChessboardProviderContextValue = {\r\n        allowDragOutsideBoard,\r\n        animationDuration,\r\n        arePiecesDraggable,\r\n        arePremovesAllowed,\r\n        arrows,\r\n        autoPromoteToQueen,\r\n        boardOrientation,\r\n        boardWidth,\r\n        chessPieces,\r\n        clearArrows,\r\n        clearCurrentRightClickDown,\r\n        currentPosition,\r\n        currentRightClickDown,\r\n        customArrowColor,\r\n        customBoardStyle,\r\n        customDarkSquareStyle,\r\n        customDropSquareStyle,\r\n        customLightSquareStyle,\r\n        customNotationStyle,\r\n        customPremoveDarkSquareStyle,\r\n        customPremoveLightSquareStyle,\r\n        customSquare,\r\n        customSquareStyles,\r\n        deletePieceFromSquare,\r\n        drawNewArrow,\r\n        dropOffBoardAction,\r\n        handleSetPosition,\r\n        handleSparePieceDrop,\r\n        id,\r\n        isDraggablePiece,\r\n        isWaitingForAnimation,\r\n        lastPieceColour,\r\n        lastSquareDraggedOver,\r\n        newArrow,\r\n        onArrowDrawEnd,\r\n        onDragOverSquare,\r\n        onMouseOutSquare,\r\n        onMouseOverSquare,\r\n        onPieceClick,\r\n        onPieceDragBegin,\r\n        onPieceDragEnd,\r\n        onPieceDrop,\r\n        onPieceDropOffBoard,\r\n        onPromotionCheck,\r\n        onPromotionPieceSelect,\r\n        onRightClickDown,\r\n        onRightClickUp,\r\n        onSparePieceDrop,\r\n        onSquareClick,\r\n        positionDifferences,\r\n        premoves,\r\n        promoteFromSquare,\r\n        promoteToSquare,\r\n        promotionDialogVariant,\r\n        setLastSquareDraggedOver,\r\n        setPromoteFromSquare,\r\n        setPromoteToSquare,\r\n        setShowPromoteDialog,\r\n        showBoardNotation,\r\n        showPromoteDialog,\r\n        snapToCursor,\r\n    };\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardContext.Provider, Object.assign({ value: ChessboardProviderContextValue }, { children: children })));\r\n});\n\nfunction Notation({ row, col }) {\r\n    const { boardOrientation, boardWidth, customDarkSquareStyle, customLightSquareStyle, customNotationStyle, } = useChessboard();\r\n    const whiteColor = customLightSquareStyle.backgroundColor;\r\n    const blackColor = customDarkSquareStyle.backgroundColor;\r\n    const isRow = col === 0;\r\n    const isColumn = row === 7;\r\n    const isBottomLeftSquare = isRow && isColumn;\r\n    function getRow() {\r\n        return boardOrientation === \"white\" ? 8 - row : row + 1;\r\n    }\r\n    function getColumn() {\r\n        return boardOrientation === \"black\" ? COLUMNS[7 - col] : COLUMNS[col];\r\n    }\r\n    function renderBottomLeft() {\r\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: \"absolute\" }, { color: whiteColor }), numericStyle(boardWidth, customNotationStyle)) }, { children: getRow() })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: \"absolute\" }, { color: whiteColor }), alphaStyle(boardWidth, customNotationStyle)) }, { children: getColumn() }))] }));\r\n    }\r\n    function renderLetters() {\r\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: Object.assign(Object.assign({ userSelect: \"none\", zIndex: 3, position: \"absolute\" }, { color: col % 2 !== 0 ? blackColor : whiteColor }), alphaStyle(boardWidth, customNotationStyle)) }, { children: getColumn() })));\r\n    }\r\n    function renderNumbers() {\r\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: Object.assign(Object.assign({ userSelect: \"none\", zIndex: 3, position: \"absolute\" }, (boardOrientation === \"black\"\r\n                ? { color: row % 2 === 0 ? blackColor : whiteColor }\r\n                : { color: row % 2 === 0 ? blackColor : whiteColor })), numericStyle(boardWidth, customNotationStyle)) }, { children: getRow() })));\r\n    }\r\n    if (isBottomLeftSquare) {\r\n        return renderBottomLeft();\r\n    }\r\n    if (isColumn) {\r\n        return renderLetters();\r\n    }\r\n    if (isRow) {\r\n        return renderNumbers();\r\n    }\r\n    return null;\r\n}\r\nconst alphaStyle = (width, customNotationStyle) => (Object.assign({ alignSelf: \"flex-end\", paddingLeft: width / 8 - width / 48, fontSize: width / 48 }, customNotationStyle));\r\nconst numericStyle = (width, customNotationStyle) => (Object.assign({ alignSelf: \"flex-start\", paddingRight: width / 8 - width / 48, fontSize: width / 48 }, customNotationStyle));\n\n/**\n * Create the React Context\n */ const DndContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    dragDropManager: undefined\n});\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function':\n      {\n        return type;\n      }\n  }\n\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  var constructorName = ctorName(val);\n\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (true) {\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error( false ? 0 : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error( false ? 0 : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n\n    if (isDispatching) {\n      throw new Error( false ? 0 : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error( false ? 0 : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n\n    if (isDispatching) {\n      throw new Error( false ? 0 : 'Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ function invariant(condition, format, ...args) {\n    if (isProduction()) {\n        if (format === undefined) {\n            throw new Error('invariant requires an error message argument');\n        }\n    }\n    if (!condition) {\n        let error;\n        if (format === undefined) {\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n        } else {\n            let argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = 'Invariant Violation';\n        }\n        error.framesToPop = 1 // we don't care about invariant's own frame\n        ;\n        throw error;\n    }\n}\nfunction isProduction() {\n    return typeof process !== 'undefined' && \"development\" === 'production';\n}\n\n// cheap lodash replacements\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */ function get(obj, path, defaultValue) {\n    return path.split('.').reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null\n    , obj);\n}\n/**\n * drop-in replacement for _.without\n */ function without$1(items, item) {\n    return items.filter((i)=>i !== item\n    );\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ function isObject(input) {\n    return typeof input === 'object';\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */ function xor(itemsA, itemsB) {\n    const map = new Map();\n    const insertItem = (item)=>{\n        map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n    };\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    map.forEach((count, key)=>{\n        if (count === 1) {\n            result.push(key);\n        }\n    });\n    return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */ function intersection(itemsA, itemsB) {\n    return itemsA.filter((t)=>itemsB.indexOf(t) > -1\n    );\n}\n\nconst INIT_COORDS = 'dnd-core/INIT_COORDS';\nconst BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nconst PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nconst HOVER = 'dnd-core/HOVER';\nconst DROP = 'dnd-core/DROP';\nconst END_DRAG = 'dnd-core/END_DRAG';\n\nfunction setClientOffset(clientOffset, sourceClientOffset) {\n    return {\n        type: INIT_COORDS,\n        payload: {\n            sourceClientOffset: sourceClientOffset || null,\n            clientOffset: clientOffset || null\n        }\n    };\n}\n\nconst ResetCoordinatesAction = {\n    type: INIT_COORDS,\n    payload: {\n        clientOffset: null,\n        sourceClientOffset: null\n    }\n};\nfunction createBeginDrag(manager) {\n    return function beginDrag(sourceIds = [], options = {\n        publishSource: true\n    }) {\n        const { publishSource =true , clientOffset , getSourceClientOffset ,  } = options;\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        // Initialize the coordinates using the client offset\n        manager.dispatch(setClientOffset(clientOffset));\n        verifyInvariants$1(sourceIds, monitor, registry);\n        // Get the draggable source\n        const sourceId = getDraggableSource(sourceIds, monitor);\n        if (sourceId == null) {\n            manager.dispatch(ResetCoordinatesAction);\n            return;\n        }\n        // Get the source client offset\n        let sourceClientOffset = null;\n        if (clientOffset) {\n            if (!getSourceClientOffset) {\n                throw new Error('getSourceClientOffset must be defined');\n            }\n            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);\n            sourceClientOffset = getSourceClientOffset(sourceId);\n        }\n        // Initialize the full coordinates\n        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n        const source = registry.getSource(sourceId);\n        const item = source.beginDrag(monitor, sourceId);\n        // If source.beginDrag returns null, this is an indicator to cancel the drag\n        if (item == null) {\n            return undefined;\n        }\n        verifyItemIsObject(item);\n        registry.pinSource(sourceId);\n        const itemType = registry.getSourceType(sourceId);\n        return {\n            type: BEGIN_DRAG,\n            payload: {\n                itemType,\n                item,\n                sourceId,\n                clientOffset: clientOffset || null,\n                sourceClientOffset: sourceClientOffset || null,\n                isSourcePublic: !!publishSource\n            }\n        };\n    };\n}\nfunction verifyInvariants$1(sourceIds, monitor, registry) {\n    invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n    sourceIds.forEach(function(sourceId) {\n        invariant(registry.getSource(sourceId), 'Expected sourceIds to be registered.');\n    });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {\n    invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n}\nfunction verifyItemIsObject(item) {\n    invariant(isObject(item), 'Item must be an object.');\n}\nfunction getDraggableSource(sourceIds, monitor) {\n    let sourceId = null;\n    for(let i = sourceIds.length - 1; i >= 0; i--){\n        if (monitor.canDragSource(sourceIds[i])) {\n            sourceId = sourceIds[i];\n            break;\n        }\n    }\n    return sourceId;\n}\n\nfunction _defineProperty$4(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$4(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$4(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction createDrop(manager) {\n    return function drop(options = {}) {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyInvariants(monitor);\n        const targetIds = getDroppableTargets(monitor);\n        // Multiple actions are dispatched here, which is why this doesn't return an action\n        targetIds.forEach((targetId, index)=>{\n            const dropResult = determineDropResult(targetId, index, registry, monitor);\n            const action = {\n                type: DROP,\n                payload: {\n                    dropResult: _objectSpread$4({}, options, dropResult)\n                }\n            };\n            manager.dispatch(action);\n        });\n    };\n}\nfunction verifyInvariants(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n}\nfunction determineDropResult(targetId, index, registry, monitor) {\n    const target = registry.getTarget(targetId);\n    let dropResult = target ? target.drop(monitor, targetId) : undefined;\n    verifyDropResultType(dropResult);\n    if (typeof dropResult === 'undefined') {\n        dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n    return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n    invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n}\nfunction getDroppableTargets(monitor) {\n    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n    targetIds.reverse();\n    return targetIds;\n}\n\nfunction createEndDrag(manager) {\n    return function endDrag() {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyIsDragging(monitor);\n        const sourceId = monitor.getSourceId();\n        if (sourceId != null) {\n            const source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n        }\n        return {\n            type: END_DRAG\n        };\n    };\n}\nfunction verifyIsDragging(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n}\n\nfunction matchesType(targetType, draggedItemType) {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType\n    ) : targetType === draggedItemType;\n}\n\nfunction createHover(manager) {\n    return function hover(targetIdsArg, { clientOffset  } = {}) {\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        checkInvariants(targetIds, monitor, registry);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null\n            }\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n    for(let i = 0; i < targetIds.length; i++){\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        const target = registry.getTarget(targetId);\n        invariant(target, 'Expected targetIds to be registered.');\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for(let i = targetIds.length - 1; i >= 0; i--){\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function(targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\n\nfunction createPublishDragSource(manager) {\n    return function publishDragSource() {\n        const monitor = manager.getMonitor();\n        if (monitor.isDragging()) {\n            return {\n                type: PUBLISH_DRAG_SOURCE\n            };\n        }\n        return;\n    };\n}\n\nfunction createDragDropActions(manager) {\n    return {\n        beginDrag: createBeginDrag(manager),\n        publishDragSource: createPublishDragSource(manager),\n        hover: createHover(manager),\n        drop: createDrop(manager),\n        endDrag: createEndDrag(manager)\n    };\n}\n\nclass DragDropManagerImpl {\n    receiveBackend(backend) {\n        this.backend = backend;\n    }\n    getMonitor() {\n        return this.monitor;\n    }\n    getBackend() {\n        return this.backend;\n    }\n    getRegistry() {\n        return this.monitor.registry;\n    }\n    getActions() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;\n        const { dispatch  } = this.store;\n        function bindActionCreator(actionCreator) {\n            return (...args)=>{\n                const action = actionCreator.apply(manager, args);\n                if (typeof action !== 'undefined') {\n                    dispatch(action);\n                }\n            };\n        }\n        const actions = createDragDropActions(this);\n        return Object.keys(actions).reduce((boundActions, key)=>{\n            const action = actions[key];\n            boundActions[key] = bindActionCreator(action);\n            return boundActions;\n        }, {});\n    }\n    dispatch(action) {\n        this.store.dispatch(action);\n    }\n    constructor(store, monitor){\n        this.isSetUp = false;\n        this.handleRefCountChange = ()=>{\n            const shouldSetUp = this.store.getState().refCount > 0;\n            if (this.backend) {\n                if (shouldSetUp && !this.isSetUp) {\n                    this.backend.setup();\n                    this.isSetUp = true;\n                } else if (!shouldSetUp && this.isSetUp) {\n                    this.backend.teardown();\n                    this.isSetUp = false;\n                }\n            }\n        };\n        this.store = store;\n        this.monitor = monitor;\n        store.subscribe(this.handleRefCountChange);\n    }\n}\n\n/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */ function add(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y\n    };\n}\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */ function subtract(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */ function getSourceClientOffset(state) {\n    const { clientOffset , initialClientOffset , initialSourceClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n        return null;\n    }\n    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */ function getDifferenceFromInitialOffset(state) {\n    const { clientOffset , initialClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset) {\n        return null;\n    }\n    return subtract(clientOffset, initialClientOffset);\n}\n\nconst NONE = [];\nconst ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */ function areDirty(dirtyIds, handlerIds) {\n    if (dirtyIds === NONE) {\n        return false;\n    }\n    if (dirtyIds === ALL || typeof handlerIds === 'undefined') {\n        return true;\n    }\n    const commonIds = intersection(handlerIds, dirtyIds);\n    return commonIds.length > 0;\n}\n\nclass DragDropMonitorImpl {\n    subscribeToStateChange(listener, options = {}) {\n        const { handlerIds  } = options;\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = ()=>{\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n                if (!canSkipListener) {\n                    listener();\n                }\n            } finally{\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = ()=>{\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId, options = {\n        shallow: false\n    }) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow  } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        } else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n    constructor(store, registry){\n        this.store = store;\n        this.registry = registry;\n    }\n}\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n/* globals self */ const scope = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : self;\nconst BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        const timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        const intervalHandle = setInterval(handleTimer, 50);\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    let toggle = 1;\n    const observer = new BrowserMutationObserver(callback);\n    const node = document.createTextNode('');\n    observer.observe(node, {\n        characterData: true\n    });\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\nconst makeRequestCall = typeof BrowserMutationObserver === 'function' ? // reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nmakeRequestCallFromMutationObserver : // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\nmakeRequestCallFromTimer;\n\nclass AsapQueue {\n    // Use the fastest means possible to execute a task in its own turn, with\n    // priority over other events including IO, animation, reflow, and redraw\n    // events in browsers.\n    //\n    // An exception thrown by a task will permanently interrupt the processing of\n    // subsequent tasks. The higher level `asap` function ensures that if an\n    // exception is thrown by a task, that the task queue will continue flushing as\n    // soon as possible, but if you use `rawAsap` directly, you are responsible to\n    // either ensure that no exceptions are thrown from your task, or to manually\n    // call `rawAsap.requestFlush` if an exception is thrown.\n    enqueueTask(task) {\n        const { queue: q , requestFlush  } = this;\n        if (!q.length) {\n            requestFlush();\n            this.flushing = true;\n        }\n        // Equivalent to push, but avoids a function call.\n        q[q.length] = task;\n    }\n    constructor(){\n        this.queue = [];\n        // We queue errors to ensure they are thrown in right order (FIFO).\n        // Array-as-queue is good enough here, since we are just dealing with exceptions.\n        this.pendingErrors = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        // @ts-ignore\n        this.flushing = false;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        this.index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        this.capacity = 1024;\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        this.flush = ()=>{\n            const { queue: q  } = this;\n            while(this.index < q.length){\n                const currentIndex = this.index;\n                // Advance the index before calling the task. This ensures that we will\n                // begin flushing on the next task the task throws an error.\n                this.index++;\n                q[currentIndex].call();\n                // Prevent leaking memory for long chains of recursive calls to `asap`.\n                // If we call `asap` within tasks scheduled by `asap`, the queue will\n                // grow, but to avoid an O(n) walk for every task we execute, we don't\n                // shift tasks off the queue after they have been executed.\n                // Instead, we periodically shift 1024 tasks off the queue.\n                if (this.index > this.capacity) {\n                    // Manually shift all values starting at the index back to the\n                    // beginning of the queue.\n                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){\n                        q[scan] = q[scan + this.index];\n                    }\n                    q.length -= this.index;\n                    this.index = 0;\n                }\n            }\n            q.length = 0;\n            this.index = 0;\n            this.flushing = false;\n        };\n        // In a web browser, exceptions are not fatal. However, to avoid\n        // slowing down the queue of pending tasks, we rethrow the error in a\n        // lower priority turn.\n        this.registerPendingError = (err)=>{\n            this.pendingErrors.push(err);\n            this.requestErrorThrow();\n        };\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.jss\n        // `process.on(\"uncaughtException\")` or by a domain.\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n        this.requestFlush = makeRequestCall(this.flush);\n        this.requestErrorThrow = makeRequestCallFromTimer(()=>{\n            // Throw first error\n            if (this.pendingErrors.length) {\n                throw this.pendingErrors.shift();\n            }\n        });\n    }\n} // The message channel technique was discovered by Malte Ubl and was the\n // original foundation for this library.\n // http://www.nonblocking.io/2011/06/windownexttick.html\n // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n // page's first load. Thankfully, this version of Safari supports\n // MutationObservers, so we don't need to fall back in that case.\n // function makeRequestCallFromMessageChannel(callback) {\n //     var channel = new MessageChannel();\n //     channel.port1.onmessage = callback;\n //     return function requestCall() {\n //         channel.port2.postMessage(0);\n //     };\n // }\n // For reasons explained above, we are also unable to use `setImmediate`\n // under any circumstances.\n // Even if we were, there is another bug in Internet Explorer 10.\n // It is not sufficient to assign `setImmediate` to `requestFlush` because\n // `setImmediate` must be called *by name* and therefore must be wrapped in a\n // closure.\n // Never forget.\n // function makeRequestCallFromSetImmediate(callback) {\n //     return function requestCall() {\n //         setImmediate(callback);\n //     };\n // }\n // Safari 6.0 has a problem where timers will get lost while the user is\n // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n // mutation observers, so that implementation is used instead.\n // However, if we ever elect to use timers in Safari, the prevalent work-around\n // is to add a scroll event listener that calls for a flush.\n // `setTimeout` does not call the passed callback if the delay is less than\n // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n // even then.\n // This is for `asap.js` only.\n // Its name will be periodically randomized to break any code that depends on\n // // its existence.\n // rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n // ASAP was originally a nextTick shim included in Q. This was factored out\n // into this ASAP package. It was later adapted to RSVP which made further\n // amendments. These decisions, particularly to marginalize MessageChannel and\n // to capture the MutationObserver implementation in a closure, were integrated\n // back into ASAP proper.\n // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n// `call`, just like a function.\nclass RawTask {\n    call() {\n        try {\n            this.task && this.task();\n        } catch (error) {\n            this.onError(error);\n        } finally{\n            this.task = null;\n            this.release(this);\n        }\n    }\n    constructor(onError, release){\n        this.onError = onError;\n        this.release = release;\n        this.task = null;\n    }\n}\n\nclass TaskFactory {\n    create(task) {\n        const tasks = this.freeTasks;\n        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t\n        );\n        t1.task = task;\n        return t1;\n    }\n    constructor(onError){\n        this.onError = onError;\n        this.freeTasks = [];\n    }\n}\n\nconst asapQueue = new AsapQueue();\nconst taskFactory = new TaskFactory(asapQueue.registerPendingError);\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */ function asap(task) {\n    asapQueue.enqueueTask(taskFactory.create(task));\n}\n\nconst ADD_SOURCE = 'dnd-core/ADD_SOURCE';\nconst ADD_TARGET = 'dnd-core/ADD_TARGET';\nconst REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';\nconst REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';\nfunction addSource(sourceId) {\n    return {\n        type: ADD_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction addTarget(targetId) {\n    return {\n        type: ADD_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nfunction removeSource(sourceId) {\n    return {\n        type: REMOVE_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nfunction removeTarget(targetId) {\n    return {\n        type: REMOVE_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\n\nfunction validateSourceContract(source) {\n    invariant(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');\n    invariant(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');\n    invariant(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');\n}\nfunction validateTargetContract(target) {\n    invariant(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');\n    invariant(typeof target.hover === 'function', 'Expected hover to be a function.');\n    invariant(typeof target.drop === 'function', 'Expected beginDrag to be a function.');\n}\nfunction validateType(type, allowArray) {\n    if (allowArray && Array.isArray(type)) {\n        type.forEach((t)=>validateType(t, false)\n        );\n        return;\n    }\n    invariant(typeof type === 'string' || typeof type === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');\n}\n\nvar HandlerRole;\n(function(HandlerRole) {\n    HandlerRole[\"SOURCE\"] = \"SOURCE\";\n    HandlerRole[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\n\nlet nextUniqueId = 0;\nfunction getNextUniqueId() {\n    return nextUniqueId++;\n}\n\nfunction getNextHandlerId(role) {\n    const id = getNextUniqueId().toString();\n    switch(role){\n        case HandlerRole.SOURCE:\n            return `S${id}`;\n        case HandlerRole.TARGET:\n            return `T${id}`;\n        default:\n            throw new Error(`Unknown Handler Role: ${role}`);\n    }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n    switch(handlerId[0]){\n        case 'S':\n            return HandlerRole.SOURCE;\n        case 'T':\n            return HandlerRole.TARGET;\n        default:\n            throw new Error(`Cannot parse handler ID: ${handlerId}`);\n    }\n}\nfunction mapContainsValue(map, searchValue) {\n    const entries = map.entries();\n    let isDone = false;\n    do {\n        const { done , value: [, value] ,  } = entries.next();\n        if (value === searchValue) {\n            return true;\n        }\n        isDone = !!done;\n    }while (!isDone)\n    return false;\n}\nclass HandlerRegistryImpl {\n    addSource(type, source) {\n        validateType(type);\n        validateSourceContract(source);\n        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n        this.store.dispatch(addSource(sourceId));\n        return sourceId;\n    }\n    addTarget(type, target) {\n        validateType(type, true);\n        validateTargetContract(target);\n        const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n        this.store.dispatch(addTarget(targetId));\n        return targetId;\n    }\n    containsHandler(handler) {\n        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n    }\n    getSource(sourceId, includePinned = false) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        const isPinned = includePinned && sourceId === this.pinnedSourceId;\n        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n        return source;\n    }\n    getTarget(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.dropTargets.get(targetId);\n    }\n    getSourceType(sourceId) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        return this.types.get(sourceId);\n    }\n    getTargetType(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.types.get(targetId);\n    }\n    isSourceId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.SOURCE;\n    }\n    isTargetId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.TARGET;\n    }\n    removeSource(sourceId) {\n        invariant(this.getSource(sourceId), 'Expected an existing source.');\n        this.store.dispatch(removeSource(sourceId));\n        asap(()=>{\n            this.dragSources.delete(sourceId);\n            this.types.delete(sourceId);\n        });\n    }\n    removeTarget(targetId) {\n        invariant(this.getTarget(targetId), 'Expected an existing target.');\n        this.store.dispatch(removeTarget(targetId));\n        this.dropTargets.delete(targetId);\n        this.types.delete(targetId);\n    }\n    pinSource(sourceId) {\n        const source = this.getSource(sourceId);\n        invariant(source, 'Expected an existing source.');\n        this.pinnedSourceId = sourceId;\n        this.pinnedSource = source;\n    }\n    unpinSource() {\n        invariant(this.pinnedSource, 'No source is pinned at the time.');\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n    }\n    addHandler(role, type, handler) {\n        const id = getNextHandlerId(role);\n        this.types.set(id, type);\n        if (role === HandlerRole.SOURCE) {\n            this.dragSources.set(id, handler);\n        } else if (role === HandlerRole.TARGET) {\n            this.dropTargets.set(id, handler);\n        }\n        return id;\n    }\n    constructor(store){\n        this.types = new Map();\n        this.dragSources = new Map();\n        this.dropTargets = new Map();\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n        this.store = store;\n    }\n}\n\nconst strictEquality = (a, b)=>a === b\n;\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */ function areCoordsEqual(offsetA, offsetB) {\n    if (!offsetA && !offsetB) {\n        return true;\n    } else if (!offsetA || !offsetB) {\n        return false;\n    } else {\n        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n    }\n}\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */ function areArraysEqual(a, b, isEqual = strictEquality) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; ++i){\n        if (!isEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction reduce$5(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_state = NONE, action) {\n    switch(action.type){\n        case HOVER:\n            break;\n        case ADD_SOURCE:\n        case ADD_TARGET:\n        case REMOVE_TARGET:\n        case REMOVE_SOURCE:\n            return NONE;\n        case BEGIN_DRAG:\n        case PUBLISH_DRAG_SOURCE:\n        case END_DRAG:\n        case DROP:\n        default:\n            return ALL;\n    }\n    const { targetIds =[] , prevTargetIds =[]  } = action.payload;\n    const result = xor(targetIds, prevTargetIds);\n    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n    if (!didChange) {\n        return NONE;\n    }\n    // Check the target ids at the innermost position. If they are valid, add them\n    // to the result\n    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n    const innermostTargetId = targetIds[targetIds.length - 1];\n    if (prevInnermostTargetId !== innermostTargetId) {\n        if (prevInnermostTargetId) {\n            result.push(prevInnermostTargetId);\n        }\n        if (innermostTargetId) {\n            result.push(innermostTargetId);\n        }\n    }\n    return result;\n}\n\nfunction _defineProperty$3(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$3(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$3(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState$1 = {\n    initialSourceClientOffset: null,\n    initialClientOffset: null,\n    clientOffset: null\n};\nfunction reduce$4(state = initialState$1, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case INIT_COORDS:\n        case BEGIN_DRAG:\n            return {\n                initialSourceClientOffset: payload.sourceClientOffset,\n                initialClientOffset: payload.clientOffset,\n                clientOffset: payload.clientOffset\n            };\n        case HOVER:\n            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n                return state;\n            }\n            return _objectSpread$3({}, state, {\n                clientOffset: payload.clientOffset\n            });\n        case END_DRAG:\n        case DROP:\n            return initialState$1;\n        default:\n            return state;\n    }\n}\n\nfunction _defineProperty$2(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$2(target, key, source[key]);\n        });\n    }\n    return target;\n}\nconst initialState = {\n    itemType: null,\n    item: null,\n    sourceId: null,\n    targetIds: [],\n    dropResult: null,\n    didDrop: false,\n    isSourcePublic: null\n};\nfunction reduce$3(state = initialState, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case BEGIN_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: payload.itemType,\n                item: payload.item,\n                sourceId: payload.sourceId,\n                isSourcePublic: payload.isSourcePublic,\n                dropResult: null,\n                didDrop: false\n            });\n        case PUBLISH_DRAG_SOURCE:\n            return _objectSpread$2({}, state, {\n                isSourcePublic: true\n            });\n        case HOVER:\n            return _objectSpread$2({}, state, {\n                targetIds: payload.targetIds\n            });\n        case REMOVE_TARGET:\n            if (state.targetIds.indexOf(payload.targetId) === -1) {\n                return state;\n            }\n            return _objectSpread$2({}, state, {\n                targetIds: without$1(state.targetIds, payload.targetId)\n            });\n        case DROP:\n            return _objectSpread$2({}, state, {\n                dropResult: payload.dropResult,\n                didDrop: true,\n                targetIds: []\n            });\n        case END_DRAG:\n            return _objectSpread$2({}, state, {\n                itemType: null,\n                item: null,\n                sourceId: null,\n                dropResult: null,\n                didDrop: false,\n                isSourcePublic: null,\n                targetIds: []\n            });\n        default:\n            return state;\n    }\n}\n\nfunction reduce$2(state = 0, action) {\n    switch(action.type){\n        case ADD_SOURCE:\n        case ADD_TARGET:\n            return state + 1;\n        case REMOVE_SOURCE:\n        case REMOVE_TARGET:\n            return state - 1;\n        default:\n            return state;\n    }\n}\n\nfunction reduce$1(state = 0) {\n    return state + 1;\n}\n\nfunction _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty$1(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction reduce(state = {}, action) {\n    return {\n        dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {\n            type: action.type,\n            payload: _objectSpread$1({}, action.payload, {\n                prevTargetIds: get(state, 'dragOperation.targetIds', [])\n            })\n        }),\n        dragOffset: reduce$4(state.dragOffset, action),\n        refCount: reduce$2(state.refCount, action),\n        dragOperation: reduce$3(state.dragOperation, action),\n        stateId: reduce$1(state.stateId)\n    };\n}\n\nfunction createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {\n    const store = makeStoreInstance(debugMode);\n    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n    const manager = new DragDropManagerImpl(store, monitor);\n    const backend = backendFactory(manager, globalContext, backendOptions);\n    manager.receiveBackend(backend);\n    return manager;\n}\nfunction makeStoreInstance(debugMode) {\n    // TODO: if we ever make a react-native version of this,\n    // we'll need to consider how to pull off dev-tooling\n    const reduxDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;\n    return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({\n        name: 'dnd-core',\n        instanceId: 'dnd-core'\n    }));\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nlet refCount = 0;\nconst INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');\nvar DndProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(function DndProvider(_param) {\n    var { children  } = _param, props = _objectWithoutProperties(_param, [\n        \"children\"\n    ]);\n    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n    ;\n    /**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isGlobalInstance) {\n            const context = getGlobalContext();\n            ++refCount;\n            return ()=>{\n                if (--refCount === 0) {\n                    context[INSTANCE_SYM] = null;\n                }\n            };\n        }\n        return;\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndContext.Provider, {\n        value: manager,\n        children: children\n    });\n});\nfunction getDndContextValue(props) {\n    if ('manager' in props) {\n        const manager = {\n            dragDropManager: props.manager\n        };\n        return [\n            manager,\n            false\n        ];\n    }\n    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n    const isGlobalInstance = !props.context;\n    return [\n        manager,\n        isGlobalInstance\n    ];\n}\nfunction createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {\n    const ctx = context;\n    if (!ctx[INSTANCE_SYM]) {\n        ctx[INSTANCE_SYM] = {\n            dragDropManager: createDragDropManager(backend, context, options, debugMode)\n        };\n    }\n    return ctx[INSTANCE_SYM];\n}\nfunction getGlobalContext() {\n    return typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;\n}\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n// suppress the useLayoutEffect warning on server side.\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */ function useCollector(monitor, collect, onUpdate) {\n    const [collected, setCollected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>collect(monitor)\n    );\n    const updateCollected = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const nextValue = collect(monitor);\n        // This needs to be a deep-equality check because some monitor-collected values\n        // include XYCoord objects that may be equivalent, but do not have instance equality.\n        if (!fastDeepEqual(collected, nextValue)) {\n            setCollected(nextValue);\n            if (onUpdate) {\n                onUpdate();\n            }\n        }\n    }, [\n        collected,\n        monitor,\n        onUpdate\n    ]);\n    // update the collected properties after react renders.\n    // Note that the \"Dustbin Stress Test\" fails if this is not\n    // done when the component updates\n    useIsomorphicLayoutEffect(updateCollected);\n    return [\n        collected,\n        updateCollected\n    ];\n}\n\nfunction useMonitorOutput(monitor, collect, onCollect) {\n    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {\n        const handlerId = monitor.getHandlerId();\n        if (handlerId == null) {\n            return;\n        }\n        return monitor.subscribeToStateChange(updateCollected, {\n            handlerIds: [\n                handlerId\n            ]\n        });\n    }, [\n        monitor,\n        updateCollected\n    ]);\n    return collected;\n}\n\nfunction useCollectedProps(collector, monitor, connector) {\n    return useMonitorOutput(monitor, collector || (()=>({})\n    ), ()=>connector.reconnect()\n    );\n}\n\nfunction useOptionalFactory(arg, deps) {\n    const memoDeps = [\n        ...deps || []\n    ];\n    if (deps == null && typeof arg !== 'function') {\n        memoDeps.push(arg);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return typeof arg === 'function' ? arg() : arg;\n    }, memoDeps);\n}\n\nfunction useConnectDragSource(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragSource()\n    , [\n        connector\n    ]);\n}\nfunction useConnectDragPreview(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dragPreview()\n    , [\n        connector\n    ]);\n}\n\nlet isCallingCanDrag = false;\nlet isCallingIsDragging = false;\nclass DragSourceMonitorImpl {\n    receiveHandlerId(sourceId) {\n        this.sourceId = sourceId;\n    }\n    getHandlerId() {\n        return this.sourceId;\n    }\n    canDrag() {\n        invariant(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');\n        try {\n            isCallingCanDrag = true;\n            return this.internalMonitor.canDragSource(this.sourceId);\n        } finally{\n            isCallingCanDrag = false;\n        }\n    }\n    isDragging() {\n        if (!this.sourceId) {\n            return false;\n        }\n        invariant(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');\n        try {\n            isCallingIsDragging = true;\n            return this.internalMonitor.isDraggingSource(this.sourceId);\n        } finally{\n            isCallingIsDragging = false;\n        }\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    isDraggingSource(sourceId) {\n        return this.internalMonitor.isDraggingSource(sourceId);\n    }\n    isOverTarget(targetId, options) {\n        return this.internalMonitor.isOverTarget(targetId, options);\n    }\n    getTargetIds() {\n        return this.internalMonitor.getTargetIds();\n    }\n    isSourcePublic() {\n        return this.internalMonitor.isSourcePublic();\n    }\n    getSourceId() {\n        return this.internalMonitor.getSourceId();\n    }\n    subscribeToOffsetChange(listener) {\n        return this.internalMonitor.subscribeToOffsetChange(listener);\n    }\n    canDragSource(sourceId) {\n        return this.internalMonitor.canDragSource(sourceId);\n    }\n    canDropOnTarget(targetId) {\n        return this.internalMonitor.canDropOnTarget(targetId);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.sourceId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\n\nlet isCallingCanDrop = false;\nclass DropTargetMonitorImpl {\n    receiveHandlerId(targetId) {\n        this.targetId = targetId;\n    }\n    getHandlerId() {\n        return this.targetId;\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    canDrop() {\n        // Cut out early if the target id has not been set. This should prevent errors\n        // where the user has an older version of dnd-core like in\n        // https://github.com/react-dnd/react-dnd/issues/1310\n        if (!this.targetId) {\n            return false;\n        }\n        invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally{\n            isCallingCanDrop = false;\n        }\n    }\n    isOver(options) {\n        if (!this.targetId) {\n            return false;\n        }\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.targetId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\n\nfunction registerTarget(type, target, manager) {\n    const registry = manager.getRegistry();\n    const targetId = registry.addTarget(type, target);\n    return [\n        targetId,\n        ()=>registry.removeTarget(targetId)\n    ];\n}\nfunction registerSource(type, source, manager) {\n    const registry = manager.getRegistry();\n    const sourceId = registry.addSource(type, source);\n    return [\n        sourceId,\n        ()=>registry.removeSource(sourceId)\n    ];\n}\n\nfunction shallowEqual(objA, objB, compare, compareContext) {\n    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (compareResult !== void 0) {\n        return !!compareResult;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(let idx = 0; idx < keysA.length; idx++){\n        const key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        const valueA = objA[key];\n        const valueB = objB[key];\n        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isRef(obj) {\n    return(// eslint-disable-next-line no-prototype-builtins\n    obj !== null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current'));\n}\n\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === 'string') {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || 'the component';\n    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null)=>{\n        // When passed a node, call the hook straight away.\n        if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options)\n         : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nfunction wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith('Ref')) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook\n            ;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === 'function') {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: newRef\n        });\n    } else {\n        return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\n\nclass SourceConnector {\n    receiveHandlerId(newHandlerId) {\n        if (this.handlerId === newHandlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get connectTarget() {\n        return this.dragSource;\n    }\n    get dragSourceOptions() {\n        return this.dragSourceOptionsInternal;\n    }\n    set dragSourceOptions(options) {\n        this.dragSourceOptionsInternal = options;\n    }\n    get dragPreviewOptions() {\n        return this.dragPreviewOptionsInternal;\n    }\n    set dragPreviewOptions(options) {\n        this.dragPreviewOptionsInternal = options;\n    }\n    reconnect() {\n        const didChange = this.reconnectDragSource();\n        this.reconnectDragPreview(didChange);\n    }\n    reconnectDragSource() {\n        const dragSource = this.dragSource;\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();\n        if (didChange) {\n            this.disconnectDragSource();\n        }\n        if (!this.handlerId) {\n            return didChange;\n        }\n        if (!dragSource) {\n            this.lastConnectedDragSource = dragSource;\n            return didChange;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragSource = dragSource;\n            this.lastConnectedDragSourceOptions = this.dragSourceOptions;\n            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);\n        }\n        return didChange;\n    }\n    reconnectDragPreview(forceDidChange = false) {\n        const dragPreview = this.dragPreview;\n        // if nothing has changed then don't resubscribe\n        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();\n        if (didChange) {\n            this.disconnectDragPreview();\n        }\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dragPreview) {\n            this.lastConnectedDragPreview = dragPreview;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragPreview = dragPreview;\n            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;\n            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);\n        }\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didConnectedDragSourceChange() {\n        return this.lastConnectedDragSource !== this.dragSource;\n    }\n    didConnectedDragPreviewChange() {\n        return this.lastConnectedDragPreview !== this.dragPreview;\n    }\n    didDragSourceOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);\n    }\n    didDragPreviewOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);\n    }\n    disconnectDragSource() {\n        if (this.dragSourceUnsubscribe) {\n            this.dragSourceUnsubscribe();\n            this.dragSourceUnsubscribe = undefined;\n        }\n    }\n    disconnectDragPreview() {\n        if (this.dragPreviewUnsubscribe) {\n            this.dragPreviewUnsubscribe();\n            this.dragPreviewUnsubscribe = undefined;\n            this.dragPreviewNode = null;\n            this.dragPreviewRef = null;\n        }\n    }\n    get dragSource() {\n        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;\n    }\n    get dragPreview() {\n        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;\n    }\n    clearDragSource() {\n        this.dragSourceNode = null;\n        this.dragSourceRef = null;\n    }\n    clearDragPreview() {\n        this.dragPreviewNode = null;\n        this.dragPreviewRef = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dragSource: (node, options)=>{\n                this.clearDragSource();\n                this.dragSourceOptions = options || null;\n                if (isRef(node)) {\n                    this.dragSourceRef = node;\n                } else {\n                    this.dragSourceNode = node;\n                }\n                this.reconnectDragSource();\n            },\n            dragPreview: (node, options)=>{\n                this.clearDragPreview();\n                this.dragPreviewOptions = options || null;\n                if (isRef(node)) {\n                    this.dragPreviewRef = node;\n                } else {\n                    this.dragPreviewNode = node;\n                }\n                this.reconnectDragPreview();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dragSourceRef = null;\n        this.dragSourceOptionsInternal = null;\n        // The drag preview may either be attached via ref or connect function\n        this.dragPreviewRef = null;\n        this.dragPreviewOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDragSource = null;\n        this.lastConnectedDragSourceOptions = null;\n        this.lastConnectedDragPreview = null;\n        this.lastConnectedDragPreviewOptions = null;\n        this.backend = backend;\n    }\n}\n\nclass TargetConnector {\n    get connectTarget() {\n        return this.dropTarget;\n    }\n    reconnect() {\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n        if (didChange) {\n            this.disconnectDropTarget();\n        }\n        const dropTarget = this.dropTarget;\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dropTarget) {\n            this.lastConnectedDropTarget = dropTarget;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDropTarget = dropTarget;\n            this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n        }\n    }\n    receiveHandlerId(newHandlerId) {\n        if (newHandlerId === this.handlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get dropTargetOptions() {\n        return this.dropTargetOptionsInternal;\n    }\n    set dropTargetOptions(options) {\n        this.dropTargetOptionsInternal = options;\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didDropTargetChange() {\n        return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n    didOptionsChange() {\n        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n    disconnectDropTarget() {\n        if (this.unsubscribeDropTarget) {\n            this.unsubscribeDropTarget();\n            this.unsubscribeDropTarget = undefined;\n        }\n    }\n    get dropTarget() {\n        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n    clearDropTarget() {\n        this.dropTargetRef = null;\n        this.dropTargetNode = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dropTarget: (node, options)=>{\n                this.clearDropTarget();\n                this.dropTargetOptions = options;\n                if (isRef(node)) {\n                    this.dropTargetRef = node;\n                } else {\n                    this.dropTargetNode = node;\n                }\n                this.reconnect();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dropTargetRef = null;\n        this.dropTargetOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDropTarget = null;\n        this.lastConnectedDropTargetOptions = null;\n        this.backend = backend;\n    }\n}\n\n/**\n * A hook to retrieve the DragDropManager from Context\n */ function useDragDropManager() {\n    const { dragDropManager  } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DndContext);\n    invariant(dragDropManager != null, 'Expected drag drop context');\n    return dragDropManager;\n}\n\nfunction useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new SourceConnector(manager.getBackend())\n    , [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragSourceOptions = dragSourceOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragSource()\n        ;\n    }, [\n        connector,\n        dragSourceOptions\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragPreviewOptions = dragPreviewOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragPreview()\n        ;\n    }, [\n        connector,\n        dragPreviewOptions\n    ]);\n    return connector;\n}\n\nfunction useDragSourceMonitor() {\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceMonitorImpl(manager)\n    , [\n        manager\n    ]);\n}\n\nclass DragSourceImpl {\n    beginDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        let result = null;\n        if (typeof spec.item === 'object') {\n            result = spec.item;\n        } else if (typeof spec.item === 'function') {\n            result = spec.item(monitor);\n        } else {\n            result = {};\n        }\n        return result !== null && result !== void 0 ? result : null;\n    }\n    canDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (typeof spec.canDrag === 'boolean') {\n            return spec.canDrag;\n        } else if (typeof spec.canDrag === 'function') {\n            return spec.canDrag(monitor);\n        } else {\n            return true;\n        }\n    }\n    isDragging(globalMonitor, target) {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const { isDragging  } = spec;\n        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();\n    }\n    endDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const connector = this.connector;\n        const { end  } = spec;\n        if (end) {\n            end(monitor.getItem(), monitor);\n        }\n        connector.reconnect();\n    }\n    constructor(spec, monitor, connector){\n        this.spec = spec;\n        this.monitor = monitor;\n        this.connector = connector;\n    }\n}\n\nfunction useDragSource(spec, monitor, connector) {\n    const handler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DragSourceImpl(spec, monitor, connector)\n    , [\n        monitor,\n        connector\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        handler.spec = spec;\n    }, [\n        spec\n    ]);\n    return handler;\n}\n\nfunction useDragType(spec) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const result = spec.type;\n        invariant(result != null, 'spec.type must be defined');\n        return result;\n    }, [\n        spec\n    ]);\n}\n\nfunction useRegisteredDragSource(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const handler = useDragSource(spec, monitor, connector);\n    const itemType = useDragType(spec);\n    useIsomorphicLayoutEffect(function registerDragSource() {\n        if (itemType != null) {\n            const [handlerId, unregister] = registerSource(itemType, handler, manager);\n            monitor.receiveHandlerId(handlerId);\n            connector.receiveHandlerId(handlerId);\n            return unregister;\n        }\n        return;\n    }, [\n        manager,\n        monitor,\n        connector,\n        handler,\n        itemType\n    ]);\n}\n\n/**\n * useDragSource hook\n * @param sourceSpec The drag source specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrag(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);\n    const monitor = useDragSourceMonitor();\n    const connector = useDragSourceConnector(spec.options, spec.previewOptions);\n    useRegisteredDragSource(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDragSource(connector),\n        useConnectDragPreview(connector), \n    ];\n}\n\n/**\n * useDragLayer Hook\n * @param collector The property collector\n */ function useDragLayer(collect) {\n    const dragDropManager = useDragDropManager();\n    const monitor = dragDropManager.getMonitor();\n    const [collected, updateCollected] = useCollector(monitor, collect);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToOffsetChange(updateCollected)\n    );\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>monitor.subscribeToStateChange(updateCollected)\n    );\n    return collected;\n}\n\nfunction useConnectDropTarget(connector) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>connector.hooks.dropTarget()\n    , [\n        connector\n    ]);\n}\n\nfunction useDropTargetConnector(options) {\n    const manager = useDragDropManager();\n    const connector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new TargetConnector(manager.getBackend())\n    , [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dropTargetOptions = options || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDropTarget()\n        ;\n    }, [\n        options\n    ]);\n    return connector;\n}\n\nfunction useDropTargetMonitor() {\n    const manager = useDragDropManager();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetMonitorImpl(manager)\n    , [\n        manager\n    ]);\n}\n\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */ function useAccept(spec) {\n    const { accept  } = spec;\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        invariant(spec.accept != null, 'accept must be defined');\n        return Array.isArray(accept) ? accept : [\n            accept\n        ];\n    }, [\n        accept\n    ]);\n}\n\nclass DropTargetImpl {\n    canDrop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n    }\n    hover() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.hover) {\n            spec.hover(monitor.getItem(), monitor);\n        }\n    }\n    drop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.drop) {\n            return spec.drop(monitor.getItem(), monitor);\n        }\n        return;\n    }\n    constructor(spec, monitor){\n        this.spec = spec;\n        this.monitor = monitor;\n    }\n}\n\nfunction useDropTarget(spec, monitor) {\n    const dropTarget = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new DropTargetImpl(spec, monitor)\n    , [\n        monitor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dropTarget.spec = spec;\n    }, [\n        spec\n    ]);\n    return dropTarget;\n}\n\nfunction useRegisteredDropTarget(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const dropTarget = useDropTarget(spec, monitor);\n    const accept = useAccept(spec);\n    useIsomorphicLayoutEffect(function registerDropTarget() {\n        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n        monitor.receiveHandlerId(handlerId);\n        connector.receiveHandlerId(handlerId);\n        return unregister;\n    }, [\n        manager,\n        monitor,\n        dropTarget,\n        connector,\n        accept.map((a)=>a.toString()\n        ).join('|'), \n    ]);\n}\n\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ function useDrop(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    const monitor = useDropTargetMonitor();\n    const connector = useDropTargetConnector(spec.options);\n    useRegisteredDropTarget(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDropTarget(connector), \n    ];\n}\n\n// cheap lodash replacements\nfunction memoize(fn) {\n    let result = null;\n    const memoized = ()=>{\n        if (result == null) {\n            result = fn();\n        }\n        return result;\n    };\n    return memoized;\n}\n/**\n * drop-in replacement for _.without\n */ function without(items, item) {\n    return items.filter((i)=>i !== item\n    );\n}\nfunction union(itemsA, itemsB) {\n    const set = new Set();\n    const insertItem = (item)=>set.add(item)\n    ;\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    set.forEach((key)=>result.push(key)\n    );\n    return result;\n}\n\nclass EnterLeaveCounter {\n    enter(enteringNode) {\n        const previousLength = this.entered.length;\n        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode))\n        ;\n        this.entered = union(this.entered.filter(isNodeEntered), [\n            enteringNode\n        ]);\n        return previousLength === 0 && this.entered.length > 0;\n    }\n    leave(leavingNode) {\n        const previousLength = this.entered.length;\n        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);\n        return previousLength > 0 && this.entered.length === 0;\n    }\n    reset() {\n        this.entered = [];\n    }\n    constructor(isNodeInDocument){\n        this.entered = [];\n        this.isNodeInDocument = isNodeInDocument;\n    }\n}\n\nclass NativeDragSource {\n    initializeExposedProperties() {\n        Object.keys(this.config.exposeProperties).forEach((property)=>{\n            Object.defineProperty(this.item, property, {\n                configurable: true,\n                enumerable: true,\n                get () {\n                    // eslint-disable-next-line no-console\n                    console.warn(`Browser doesn't allow reading \"${property}\" until the drop event.`);\n                    return null;\n                }\n            });\n        });\n    }\n    loadDataTransfer(dataTransfer) {\n        if (dataTransfer) {\n            const newProperties = {};\n            Object.keys(this.config.exposeProperties).forEach((property)=>{\n                const propertyFn = this.config.exposeProperties[property];\n                if (propertyFn != null) {\n                    newProperties[property] = {\n                        value: propertyFn(dataTransfer, this.config.matchesTypes),\n                        configurable: true,\n                        enumerable: true\n                    };\n                }\n            });\n            Object.defineProperties(this.item, newProperties);\n        }\n    }\n    canDrag() {\n        return true;\n    }\n    beginDrag() {\n        return this.item;\n    }\n    isDragging(monitor, handle) {\n        return handle === monitor.getSourceId();\n    }\n    endDrag() {\n    // empty\n    }\n    constructor(config){\n        this.config = config;\n        this.item = {};\n        this.initializeExposedProperties();\n    }\n}\n\nconst FILE = '__NATIVE_FILE__';\nconst URL = '__NATIVE_URL__';\nconst TEXT = '__NATIVE_TEXT__';\nconst HTML = '__NATIVE_HTML__';\n\nvar NativeTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    FILE: FILE,\n    HTML: HTML,\n    TEXT: TEXT,\n    URL: URL\n});\n\nfunction getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {\n    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry)\n    , '');\n    return result != null ? result : defaultValue;\n}\n\nconst nativeTypesConfig = {\n    [FILE]: {\n        exposeProperties: {\n            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files)\n            ,\n            items: (dataTransfer)=>dataTransfer.items\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Files'\n        ]\n    },\n    [HTML]: {\n        exposeProperties: {\n            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Html',\n            'text/html'\n        ]\n    },\n    [URL]: {\n        exposeProperties: {\n            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\\n')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Url',\n            'text/uri-list'\n        ]\n    },\n    [TEXT]: {\n        exposeProperties: {\n            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Text',\n            'text/plain'\n        ]\n    }\n};\n\nfunction createNativeDragSource(type, dataTransfer) {\n    const config = nativeTypesConfig[type];\n    if (!config) {\n        throw new Error(`native type ${type} has no configuration`);\n    }\n    const result = new NativeDragSource(config);\n    result.loadDataTransfer(dataTransfer);\n    return result;\n}\nfunction matchNativeItemType(dataTransfer) {\n    if (!dataTransfer) {\n        return null;\n    }\n    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);\n    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{\n        const typeConfig = nativeTypesConfig[nativeItemType];\n        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {\n            return false;\n        }\n        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1\n        );\n    })[0] || null;\n}\n\nconst isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent)\n);\nconst isSafari = memoize(()=>Boolean(window.safari)\n);\n\nclass MonotonicInterpolant {\n    interpolate(x) {\n        const { xs , ys , c1s , c2s , c3s  } = this;\n        // The rightmost point in the dataset should give an exact result\n        let i = xs.length - 1;\n        if (x === xs[i]) {\n            return ys[i];\n        }\n        // Search for the interval x is in, returning the corresponding y if x is one of the original xs\n        let low = 0;\n        let high = c3s.length - 1;\n        let mid;\n        while(low <= high){\n            mid = Math.floor(0.5 * (low + high));\n            const xHere = xs[mid];\n            if (xHere < x) {\n                low = mid + 1;\n            } else if (xHere > x) {\n                high = mid - 1;\n            } else {\n                return ys[mid];\n            }\n        }\n        i = Math.max(0, high);\n        // Interpolate\n        const diff = x - xs[i];\n        const diffSq = diff * diff;\n        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;\n    }\n    constructor(xs, ys){\n        const { length  } = xs;\n        // Rearrange xs and ys so that xs is sorted\n        const indexes = [];\n        for(let i = 0; i < length; i++){\n            indexes.push(i);\n        }\n        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1\n        );\n        const dxs = [];\n        const ms = [];\n        let dx;\n        let dy;\n        for(let i1 = 0; i1 < length - 1; i1++){\n            dx = xs[i1 + 1] - xs[i1];\n            dy = ys[i1 + 1] - ys[i1];\n            dxs.push(dx);\n            ms.push(dy / dx);\n        }\n        // Get degree-1 coefficients\n        const c1s = [\n            ms[0]\n        ];\n        for(let i2 = 0; i2 < dxs.length - 1; i2++){\n            const m2 = ms[i2];\n            const mNext = ms[i2 + 1];\n            if (m2 * mNext <= 0) {\n                c1s.push(0);\n            } else {\n                dx = dxs[i2];\n                const dxNext = dxs[i2 + 1];\n                const common = dx + dxNext;\n                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));\n            }\n        }\n        c1s.push(ms[ms.length - 1]);\n        // Get degree-2 and degree-3 coefficients\n        const c2s = [];\n        const c3s = [];\n        let m;\n        for(let i3 = 0; i3 < c1s.length - 1; i3++){\n            m = ms[i3];\n            const c1 = c1s[i3];\n            const invDx = 1 / dxs[i3];\n            const common = c1 + c1s[i3 + 1] - m - m;\n            c2s.push((m - c1 - common) * invDx);\n            c3s.push(common * invDx * invDx);\n        }\n        this.xs = xs;\n        this.ys = ys;\n        this.c1s = c1s;\n        this.c2s = c2s;\n        this.c3s = c3s;\n    }\n}\n\nconst ELEMENT_NODE$1 = 1;\nfunction getNodeClientOffset$1(node) {\n    const el = node.nodeType === ELEMENT_NODE$1 ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    const { top , left  } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientOffset$1(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY\n    };\n}\nfunction isImageNode(node) {\n    var ref;\n    return node.nodeName === 'IMG' && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return {\n        dragPreviewWidth,\n        dragPreviewHeight\n    };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    const isImage = isImageNode(dragPreview);\n    const dragPreviewNode = isImage ? sourceNode : dragPreview;\n    const dragPreviewNodeOffsetFromClient = getNodeClientOffset$1(dragPreviewNode);\n    const offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n    };\n    const { offsetWidth: sourceWidth , offsetHeight: sourceHeight  } = sourceNode;\n    const { anchorX , anchorY  } = anchorPoint;\n    const { dragPreviewWidth , dragPreviewHeight  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n    const calculateYOffset = ()=>{\n        const interpolantY = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight, \n        ]);\n        let y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    const calculateXOffset = ()=>{\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        const interpolantX = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth, \n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    const { offsetX , offsetY  } = offsetPoint;\n    const isManualOffsetX = offsetX === 0 || offsetX;\n    const isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset()\n    };\n}\n\nlet OptionsReader$1 = class OptionsReader {\n    get window() {\n        if (this.globalContext) {\n            return this.globalContext;\n        } else if (typeof window !== 'undefined') {\n            return window;\n        }\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.globalContext.document;\n        } else if (this.window) {\n            return this.window.document;\n        } else {\n            return undefined;\n        }\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;\n    }\n    constructor(globalContext, options){\n        this.ownerDocument = null;\n        this.globalContext = globalContext;\n        this.optionsArgs = options;\n    }\n};\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nclass HTML5BackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref, ref1;\n        return {\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            sourceNodeOptions: this.sourceNodeOptions.size,\n            sourceNodes: this.sourceNodes.size,\n            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n            dropTargetIds: this.dropTargetIds.length,\n            dragEnterTargetIds: this.dragEnterTargetIds.length,\n            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n        };\n    }\n    // public for test\n    get window() {\n        return this.options.window;\n    }\n    get document() {\n        return this.options.document;\n    }\n    /**\n\t * Get the root element to use for event subscriptions\n\t */ get rootElement() {\n        return this.options.rootElement;\n    }\n    setup() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        if (root.__isReactDndBackendSetUp) {\n            throw new Error('Cannot have two HTML5 backends at the same time.');\n        }\n        root.__isReactDndBackendSetUp = true;\n        this.addEventListeners(root);\n    }\n    teardown() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        root.__isReactDndBackendSetUp = false;\n        this.removeEventListeners(this.rootElement);\n        this.clearCurrentDragSourceNode();\n        if (this.asyncEndDragFrameId) {\n            var ref;\n            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n        }\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDragSource(sourceId, node, options) {\n        this.sourceNodes.set(sourceId, node);\n        this.sourceNodeOptions.set(sourceId, options);\n        const handleDragStart = (e)=>this.handleDragStart(e, sourceId)\n        ;\n        const handleSelectStart = (e)=>this.handleSelectStart(e)\n        ;\n        node.setAttribute('draggable', 'true');\n        node.addEventListener('dragstart', handleDragStart);\n        node.addEventListener('selectstart', handleSelectStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.sourceNodeOptions.delete(sourceId);\n            node.removeEventListener('dragstart', handleDragStart);\n            node.removeEventListener('selectstart', handleSelectStart);\n            node.setAttribute('draggable', 'false');\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId)\n        ;\n        const handleDragOver = (e)=>this.handleDragOver(e, targetId)\n        ;\n        const handleDrop = (e)=>this.handleDrop(e, targetId)\n        ;\n        node.addEventListener('dragenter', handleDragEnter);\n        node.addEventListener('dragover', handleDragOver);\n        node.addEventListener('drop', handleDrop);\n        return ()=>{\n            node.removeEventListener('dragenter', handleDragEnter);\n            node.removeEventListener('dragover', handleDragOver);\n            node.removeEventListener('drop', handleDrop);\n        };\n    }\n    addEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.addEventListener) {\n            return;\n        }\n        target.addEventListener('dragstart', this.handleTopDragStart);\n        target.addEventListener('dragstart', this.handleTopDragStartCapture, true);\n        target.addEventListener('dragend', this.handleTopDragEndCapture, true);\n        target.addEventListener('dragenter', this.handleTopDragEnter);\n        target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);\n        target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n        target.addEventListener('dragover', this.handleTopDragOver);\n        target.addEventListener('dragover', this.handleTopDragOverCapture, true);\n        target.addEventListener('drop', this.handleTopDrop);\n        target.addEventListener('drop', this.handleTopDropCapture, true);\n    }\n    removeEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.removeEventListener) {\n            return;\n        }\n        target.removeEventListener('dragstart', this.handleTopDragStart);\n        target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);\n        target.removeEventListener('dragend', this.handleTopDragEndCapture, true);\n        target.removeEventListener('dragenter', this.handleTopDragEnter);\n        target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);\n        target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n        target.removeEventListener('dragover', this.handleTopDragOver);\n        target.removeEventListener('dragover', this.handleTopDragOverCapture, true);\n        target.removeEventListener('drop', this.handleTopDrop);\n        target.removeEventListener('drop', this.handleTopDropCapture, true);\n    }\n    getCurrentSourceNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n        return _objectSpread({\n            dropEffect: this.altKeyPressed ? 'copy' : 'move'\n        }, sourceNodeOptions || {});\n    }\n    getCurrentDropEffect() {\n        if (this.isDraggingNativeItem()) {\n            // It makes more sense to default to 'copy' for native resources\n            return 'copy';\n        }\n        return this.getCurrentSourceNodeOptions().dropEffect;\n    }\n    getCurrentSourcePreviewNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n        return _objectSpread({\n            anchorX: 0.5,\n            anchorY: 0.5,\n            captureDraggingState: false\n        }, sourcePreviewNodeOptions || {});\n    }\n    isDraggingNativeItem() {\n        const itemType = this.monitor.getItemType();\n        return Object.keys(NativeTypes).some((key)=>NativeTypes[key] === itemType\n        );\n    }\n    beginDragNativeItem(type, dataTransfer) {\n        this.clearCurrentDragSourceNode();\n        this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n        this.actions.beginDrag([\n            this.currentNativeHandle\n        ]);\n    }\n    setCurrentDragSourceNode(node) {\n        this.clearCurrentDragSourceNode();\n        this.currentDragSourceNode = node;\n        // A timeout of > 0 is necessary to resolve Firefox issue referenced\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        const MOUSE_MOVE_TIMEOUT = 1000;\n        // Receiving a mouse event in the middle of a dragging operation\n        // means it has ended and the drag source node disappeared from DOM,\n        // so the browser didn't dispatch the dragend event.\n        //\n        // We need to wait before we start listening for mousemove events.\n        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n        // immediately in some browsers.\n        //\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        //\n        this.mouseMoveTimeoutTimer = setTimeout(()=>{\n            var ref;\n            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n        }, MOUSE_MOVE_TIMEOUT);\n    }\n    clearCurrentDragSourceNode() {\n        if (this.currentDragSourceNode) {\n            this.currentDragSourceNode = null;\n            if (this.rootElement) {\n                var ref;\n                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n                this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n            }\n            this.mouseMoveTimeoutTimer = null;\n            return true;\n        }\n        return false;\n    }\n    handleDragStart(e, sourceId) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        if (!this.dragStartSourceIds) {\n            this.dragStartSourceIds = [];\n        }\n        this.dragStartSourceIds.unshift(sourceId);\n    }\n    handleDragEnter(_e, targetId) {\n        this.dragEnterTargetIds.unshift(targetId);\n    }\n    handleDragOver(_e, targetId) {\n        if (this.dragOverTargetIds === null) {\n            this.dragOverTargetIds = [];\n        }\n        this.dragOverTargetIds.unshift(targetId);\n    }\n    handleDrop(_e, targetId) {\n        this.dropTargetIds.unshift(targetId);\n    }\n    constructor(manager, globalContext, options){\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.sourceNodes = new Map();\n        this.sourceNodeOptions = new Map();\n        this.dragStartSourceIds = null;\n        this.dropTargetIds = [];\n        this.dragEnterTargetIds = [];\n        this.currentNativeSource = null;\n        this.currentNativeHandle = null;\n        this.currentDragSourceNode = null;\n        this.altKeyPressed = false;\n        this.mouseMoveTimeoutTimer = null;\n        this.asyncEndDragFrameId = null;\n        this.dragOverTargetIds = null;\n        this.lastClientOffset = null;\n        this.hoverRafId = null;\n        this.getSourceClientOffset = (sourceId)=>{\n            const source = this.sourceNodes.get(sourceId);\n            return source && getNodeClientOffset$1(source) || null;\n        };\n        this.endDragNativeItem = ()=>{\n            if (!this.isDraggingNativeItem()) {\n                return;\n            }\n            this.actions.endDrag();\n            if (this.currentNativeHandle) {\n                this.registry.removeSource(this.currentNativeHandle);\n            }\n            this.currentNativeHandle = null;\n            this.currentNativeSource = null;\n        };\n        this.isNodeInDocument = (node)=>{\n            // Check the node either in the main document or in the current context\n            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n        };\n        this.endDragIfSourceWasRemovedFromDOM = ()=>{\n            const node = this.currentDragSourceNode;\n            if (node == null || this.isNodeInDocument(node)) {\n                return;\n            }\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.scheduleHover = (dragOverTargetIds)=>{\n            if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {\n                this.hoverRafId = requestAnimationFrame(()=>{\n                    if (this.monitor.isDragging()) {\n                        this.actions.hover(dragOverTargetIds || [], {\n                            clientOffset: this.lastClientOffset\n                        });\n                    }\n                    this.hoverRafId = null;\n                });\n            }\n        };\n        this.cancelHover = ()=>{\n            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== 'undefined') {\n                cancelAnimationFrame(this.hoverRafId);\n                this.hoverRafId = null;\n            }\n        };\n        this.handleTopDragStartCapture = ()=>{\n            this.clearCurrentDragSourceNode();\n            this.dragStartSourceIds = [];\n        };\n        this.handleTopDragStart = (e)=>{\n            if (e.defaultPrevented) {\n                return;\n            }\n            const { dragStartSourceIds  } = this;\n            this.dragStartSourceIds = null;\n            const clientOffset = getEventClientOffset$1(e);\n            // Avoid crashing if we missed a drop event or our previous drag died\n            if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n                this.cancelHover();\n            }\n            // Don't publish the source just yet (see why below)\n            this.actions.beginDrag(dragStartSourceIds || [], {\n                publishSource: false,\n                getSourceClientOffset: this.getSourceClientOffset,\n                clientOffset\n            });\n            const { dataTransfer  } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (this.monitor.isDragging()) {\n                if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {\n                    // Use custom drag image if user specifies it.\n                    // If child drag source refuses drag but parent agrees,\n                    // use parent's node as drag image. Neither works in IE though.\n                    const sourceId = this.monitor.getSourceId();\n                    const sourceNode = this.sourceNodes.get(sourceId);\n                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n                    if (dragPreview) {\n                        const { anchorX , anchorY , offsetX , offsetY  } = this.getCurrentSourcePreviewNodeOptions();\n                        const anchorPoint = {\n                            anchorX,\n                            anchorY\n                        };\n                        const offsetPoint = {\n                            offsetX,\n                            offsetY\n                        };\n                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n                    }\n                }\n                try {\n                    // Firefox won't drag without setting data\n                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});\n                } catch (err) {\n                // IE doesn't support MIME types in setData\n                }\n                // Store drag source node so we can check whether\n                // it is removed from DOM and trigger endDrag manually.\n                this.setCurrentDragSourceNode(e.target);\n                // Now we are ready to publish the drag source.. or are we not?\n                const { captureDraggingState  } = this.getCurrentSourcePreviewNodeOptions();\n                if (!captureDraggingState) {\n                    // Usually we want to publish it in the next tick so that browser\n                    // is able to screenshot the current (not yet dragging) state.\n                    //\n                    // It also neatly avoids a situation where render() returns null\n                    // in the same tick for the source element, and browser freaks out.\n                    setTimeout(()=>this.actions.publishDragSource()\n                    , 0);\n                } else {\n                    // In some cases the user may want to override this behavior, e.g.\n                    // to work around IE not supporting custom drag previews.\n                    //\n                    // When using a custom drag layer, the only way to prevent\n                    // the default drag preview from drawing in IE is to screenshot\n                    // the dragging state in which the node itself has zero opacity\n                    // and height. In this case, though, returning null from render()\n                    // will abruptly end the dragging, which is not obvious.\n                    //\n                    // This is the reason such behavior is strictly opt-in.\n                    this.actions.publishDragSource();\n                }\n            } else if (nativeType) {\n                // A native item (such as URL) dragged from inside the document\n                this.beginDragNativeItem(nativeType);\n            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {\n                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n                // Just let it drag. It's a native type (URL or text) and will be picked up in\n                // dragenter handler.\n                return;\n            } else {\n                // If by this time no drag source reacted, tell browser not to drag.\n                e.preventDefault();\n            }\n        };\n        this.handleTopDragEndCapture = ()=>{\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                // Firefox can dispatch this event in an infinite loop\n                // if dragend handler does something like showing an alert.\n                // Only proceed if we have not handled it already.\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleTopDragEnterCapture = (e)=>{\n            this.dragEnterTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n            const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n            if (!isFirstEnter || this.monitor.isDragging()) {\n                return;\n            }\n            const { dataTransfer  } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (nativeType) {\n                // A native item (such as file or URL) dragged from outside the document\n                this.beginDragNativeItem(nativeType, dataTransfer);\n            }\n        };\n        this.handleTopDragEnter = (e)=>{\n            const { dragEnterTargetIds  } = this;\n            this.dragEnterTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            // If the target changes position as the result of `dragenter`, `dragover` might still\n            // get dispatched despite target being no longer there. The easy solution is to check\n            // whether there actually is a target before firing `hover`.\n            if (dragEnterTargetIds.length > 0) {\n                this.actions.hover(dragEnterTargetIds, {\n                    clientOffset: getEventClientOffset$1(e)\n                });\n            }\n            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId)\n            );\n            if (canDrop) {\n                // IE requires this to fire dragover events\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            }\n        };\n        this.handleTopDragOverCapture = (e)=>{\n            this.dragOverTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n        };\n        this.handleTopDragOver = (e)=>{\n            const { dragOverTargetIds  } = this;\n            this.dragOverTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                // Prevent default \"drop and blow away the whole document\" action.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = 'none';\n                }\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            this.lastClientOffset = getEventClientOffset$1(e);\n            this.scheduleHover(dragOverTargetIds);\n            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId)\n            );\n            if (canDrop) {\n                // Show user-specified drop effect.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            } else if (this.isDraggingNativeItem()) {\n                // Don't show a nice cursor but still prevent default\n                // \"drop and blow away the whole document\" action.\n                e.preventDefault();\n            } else {\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = 'none';\n                }\n            }\n        };\n        this.handleTopDragLeaveCapture = (e)=>{\n            if (this.isDraggingNativeItem()) {\n                e.preventDefault();\n            }\n            const isLastLeave = this.enterLeaveCounter.leave(e.target);\n            if (!isLastLeave) {\n                return;\n            }\n            if (this.isDraggingNativeItem()) {\n                setTimeout(()=>this.endDragNativeItem()\n                , 0);\n            }\n            this.cancelHover();\n        };\n        this.handleTopDropCapture = (e)=>{\n            this.dropTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                e.preventDefault();\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            } else if (matchNativeItemType(e.dataTransfer)) {\n                // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n                // even if the current drag event matches a user-defined type.\n                // Stop the default behavior when we're not expecting a native item to be dropped.\n                e.preventDefault();\n            }\n            this.enterLeaveCounter.reset();\n        };\n        this.handleTopDrop = (e)=>{\n            const { dropTargetIds  } = this;\n            this.dropTargetIds = [];\n            this.actions.hover(dropTargetIds, {\n                clientOffset: getEventClientOffset$1(e)\n            });\n            this.actions.drop({\n                dropEffect: this.getCurrentDropEffect()\n            });\n            if (this.isDraggingNativeItem()) {\n                this.endDragNativeItem();\n            } else if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleSelectStart = (e)=>{\n            const target = e.target;\n            // Only IE requires us to explicitly say\n            // we want drag drop operation to start\n            if (typeof target.dragDrop !== 'function') {\n                return;\n            }\n            // Inputs and textareas should be selectable\n            if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n                return;\n            }\n            // For other targets, ask IE\n            // to enable drag and drop\n            e.preventDefault();\n            target.dragDrop();\n        };\n        this.options = new OptionsReader$1(globalContext, options);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.registry = manager.getRegistry();\n        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n    }\n}\n\nlet emptyImage;\nfunction getEmptyImage() {\n    if (!emptyImage) {\n        emptyImage = new Image();\n        emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n    }\n    return emptyImage;\n}\n\nconst HTML5Backend = function createBackend(manager, context, options) {\n    return new HTML5BackendImpl(manager, context, options);\n};\n\nfunction Piece({ isPremovedPiece = false, piece, square, squares, }) {\r\n    const { animationDuration, arePiecesDraggable, boardWidth, boardOrientation, chessPieces, currentPosition, deletePieceFromSquare, dropOffBoardAction, id, isDraggablePiece, isWaitingForAnimation, onPieceClick, onPieceDragBegin, onPieceDragEnd, onPieceDropOffBoard, onPromotionCheck, positionDifferences, } = useChessboard();\r\n    const [pieceStyle, setPieceStyle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\r\n        opacity: 1,\r\n        zIndex: 5,\r\n        touchAction: \"none\",\r\n        cursor: arePiecesDraggable && isDraggablePiece({ piece, sourceSquare: square })\r\n            ? \"-webkit-grab\"\r\n            : \"default\",\r\n    });\r\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(() => ({\r\n        type: \"piece\",\r\n        item: () => {\r\n            onPieceDragBegin(piece, square);\r\n            return { piece, square, id };\r\n        },\r\n        end: (item, monitor) => {\r\n            onPieceDragEnd(piece, square);\r\n            const wasDropOutsideTheBoard = !monitor.didDrop();\r\n            if (wasDropOutsideTheBoard) {\r\n                if (dropOffBoardAction === \"trash\") {\r\n                    deletePieceFromSquare(square);\r\n                }\r\n                onPieceDropOffBoard === null || onPieceDropOffBoard === void 0 ? void 0 : onPieceDropOffBoard(square, piece);\r\n            }\r\n        },\r\n        collect: (monitor) => ({\r\n            canDrag: isDraggablePiece({ piece, sourceSquare: square }),\r\n            isDragging: !!monitor.isDragging(),\r\n        }),\r\n    }), [piece, square, currentPosition, id]);\r\n    // hide the default preview\r\n    dragPreview(getEmptyImage(), { captureDraggingState: true });\r\n    // hide piece on drag\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setPieceStyle((oldPieceStyle) => (Object.assign(Object.assign({}, oldPieceStyle), { opacity: isDragging ? 0 : 1 })));\r\n    }, [isDragging]);\r\n    // new move has come in\r\n    // if waiting for animation, then animation has started and we can perform animation\r\n    // we need to head towards where we need to go, we are the source, we are heading towards the target\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        var _a;\r\n        const removedPiece = (_a = positionDifferences.removed) === null || _a === void 0 ? void 0 : _a[square];\r\n        // return as null and not loaded yet\r\n        if (!positionDifferences.added || !removedPiece)\r\n            return;\r\n        // check if piece matches or if removed piece was a pawn and new square is on 1st or 8th rank (promotion)\r\n        const newSquare = Object.entries(positionDifferences.added).find(([s, p]) => p === removedPiece || onPromotionCheck(square, s, removedPiece));\r\n        // we can perform animation if our square was in removed, AND the matching piece is in added AND this isn't a premoved piece\r\n        if (isWaitingForAnimation &&\r\n            removedPiece &&\r\n            newSquare &&\r\n            !isPremovedPiece) {\r\n            const sourceSq = square;\r\n            const targetSq = newSquare[0];\r\n            if (sourceSq && targetSq) {\r\n                const squareWidth = boardWidth / 8;\r\n                setPieceStyle((oldPieceStyle) => (Object.assign(Object.assign({}, oldPieceStyle), { transform: `translate(${(boardOrientation === \"black\" ? -1 : 1) *\r\n                        (targetSq.charCodeAt(0) - sourceSq.charCodeAt(0)) *\r\n                        squareWidth}px, ${(boardOrientation === \"black\" ? -1 : 1) *\r\n                        (Number(sourceSq[1]) - Number(targetSq[1])) *\r\n                        squareWidth}px)`, transition: `transform ${animationDuration}ms`, zIndex: 6 })));\r\n            }\r\n        }\r\n    }, [positionDifferences]);\r\n    // translate to their own positions (repaint on undo)\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        const { sourceSq } = getSingleSquareCoordinates();\r\n        if (sourceSq) {\r\n            setPieceStyle((oldPieceStyle) => (Object.assign(Object.assign({}, oldPieceStyle), { transform: `translate(${0}px, ${0}px)`, transition: `transform ${0}ms` })));\r\n        }\r\n    }, [currentPosition]);\r\n    // update is piece draggable\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setPieceStyle((oldPieceStyle) => (Object.assign(Object.assign({}, oldPieceStyle), { cursor: arePiecesDraggable && isDraggablePiece({ piece, sourceSquare: square })\r\n                ? \"-webkit-grab\"\r\n                : \"default\" })));\r\n    }, [square, currentPosition, arePiecesDraggable]);\r\n    function getSingleSquareCoordinates() {\r\n        return { sourceSq: squares[square] };\r\n    }\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ ref: arePiecesDraggable && canDrag ? drag : null, onClick: () => onPieceClick(piece, square), \"data-piece\": piece, style: pieceStyle }, { children: typeof chessPieces[piece] === \"function\" ? (chessPieces[piece]({\r\n            squareWidth: boardWidth / 8,\r\n            isDragging,\r\n            square,\r\n        })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ viewBox: \"1 1 43 43\", width: boardWidth / 8, height: boardWidth / 8, style: { display: \"block\" } }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", { children: chessPieces[piece] }) }))) })));\r\n}\n\nfunction Square({ square, squareColor, setSquares, squareHasPremove, children, }) {\r\n    const squareRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\r\n    const { autoPromoteToQueen, boardWidth, boardOrientation, clearArrows, currentPosition, currentRightClickDown, customBoardStyle, customDarkSquareStyle, customDropSquareStyle, customLightSquareStyle, customPremoveDarkSquareStyle, customPremoveLightSquareStyle, customSquare: CustomSquare, customSquareStyles, drawNewArrow, handleSetPosition, handleSparePieceDrop, isWaitingForAnimation, lastPieceColour, lastSquareDraggedOver, onArrowDrawEnd, onDragOverSquare, onMouseOutSquare, onMouseOverSquare, onPieceDrop, onPromotionCheck, onRightClickDown, onRightClickUp, onSquareClick, setLastSquareDraggedOver, setPromoteFromSquare, setPromoteToSquare, setShowPromoteDialog, } = useChessboard();\r\n    const [{ isOver }, drop] = useDrop(() => ({\r\n        accept: \"piece\",\r\n        drop: handleDrop,\r\n        collect: (monitor) => ({\r\n            isOver: !!monitor.isOver(),\r\n        }),\r\n    }), [\r\n        square,\r\n        currentPosition,\r\n        onPieceDrop,\r\n        isWaitingForAnimation,\r\n        lastPieceColour,\r\n    ]);\r\n    function handleDrop(item) {\r\n        if (item.isSpare) {\r\n            handleSparePieceDrop(item.piece, square);\r\n            return;\r\n        }\r\n        if (onPromotionCheck(item.square, square, item.piece)) {\r\n            if (autoPromoteToQueen) {\r\n                handleSetPosition(item.square, square, item.piece[0] === \"w\" ? \"wQ\" : \"bQ\");\r\n            }\r\n            else {\r\n                setPromoteFromSquare(item.square);\r\n                setPromoteToSquare(square);\r\n                setShowPromoteDialog(true);\r\n            }\r\n        }\r\n        else {\r\n            handleSetPosition(item.square, square, item.piece, true);\r\n        }\r\n    }\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        if (squareRef.current) {\r\n            const { x, y } = squareRef.current.getBoundingClientRect();\r\n            setSquares((oldSquares) => (Object.assign(Object.assign({}, oldSquares), { [square]: { x, y } })));\r\n        }\r\n    }, [boardWidth, boardOrientation]);\r\n    const defaultSquareStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, borderRadius(square, boardOrientation, customBoardStyle)), (squareColor === \"black\"\r\n        ? customDarkSquareStyle\r\n        : customLightSquareStyle)), (squareHasPremove &&\r\n        (squareColor === \"black\"\r\n            ? customPremoveDarkSquareStyle\r\n            : customPremoveLightSquareStyle))), (isOver && customDropSquareStyle));\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ ref: drop, style: defaultSquareStyle, \"data-square-color\": squareColor, \"data-square\": square, onTouchMove: (e) => {\r\n            var _a;\r\n            // Handle touch events on tablet and mobile not covered by onMouseOver/onDragEnter\r\n            const touchLocation = e.touches[0];\r\n            const touchElement = document.elementsFromPoint(touchLocation.clientX, touchLocation.clientY);\r\n            const draggedOverSquare = (_a = touchElement === null || touchElement === void 0 ? void 0 : touchElement.find((el) => el.getAttribute(\"data-square\"))) === null || _a === void 0 ? void 0 : _a.getAttribute(\"data-square\");\r\n            if (draggedOverSquare && draggedOverSquare !== lastSquareDraggedOver) {\r\n                setLastSquareDraggedOver(draggedOverSquare);\r\n                onDragOverSquare(draggedOverSquare);\r\n            }\r\n        }, onMouseOver: (e) => {\r\n            // noop if moving from child of square into square.\r\n            if (e.buttons === 2 && currentRightClickDown) {\r\n                drawNewArrow(currentRightClickDown, square);\r\n            }\r\n            if (e.relatedTarget &&\r\n                e.currentTarget.contains(e.relatedTarget)) {\r\n                return;\r\n            }\r\n            onMouseOverSquare(square);\r\n        }, onMouseOut: (e) => {\r\n            // noop if moving from square into a child of square.\r\n            if (e.relatedTarget &&\r\n                e.currentTarget.contains(e.relatedTarget))\r\n                return;\r\n            onMouseOutSquare(square);\r\n        }, onMouseDown: (e) => {\r\n            if (e.button === 2)\r\n                onRightClickDown(square);\r\n        }, onMouseUp: (e) => {\r\n            if (e.button === 2) {\r\n                if (currentRightClickDown)\r\n                    onArrowDrawEnd(currentRightClickDown, square);\r\n                onRightClickUp(square);\r\n            }\r\n        }, onDragEnter: () => onDragOverSquare(square), onClick: () => {\r\n            const piece = currentPosition[square];\r\n            onSquareClick(square, piece);\r\n            clearArrows();\r\n        }, onContextMenu: (e) => {\r\n            e.preventDefault();\r\n        } }, { children: typeof CustomSquare === \"string\" ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare\r\n        // Type is too complex to properly evaluate, so ignore this line.\r\n        // @ts-ignore\r\n        , Object.assign({ \r\n            // Type is too complex to properly evaluate, so ignore this line.\r\n            // @ts-ignore\r\n            ref: squareRef, style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), (!squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))) }, { children: children }))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomSquare, Object.assign({ ref: squareRef, square: square, squareColor: squareColor, style: Object.assign(Object.assign(Object.assign({}, size(boardWidth)), center), (!squareHasPremove && (customSquareStyles === null || customSquareStyles === void 0 ? void 0 : customSquareStyles[square]))) }, { children: children }))) })));\r\n}\r\nconst center = {\r\n    display: \"flex\",\r\n    justifyContent: \"center\",\r\n};\r\nconst size = (width) => ({\r\n    width: width / 8,\r\n    height: width / 8,\r\n});\r\nconst borderRadius = (square, boardOrientation, customBoardStyle) => {\r\n    if (!(customBoardStyle === null || customBoardStyle === void 0 ? void 0 : customBoardStyle.borderRadius))\r\n        return {};\r\n    if (square === \"a1\") {\r\n        return boardOrientation === \"white\"\r\n            ? { borderBottomLeftRadius: customBoardStyle.borderRadius }\r\n            : { borderTopRightRadius: customBoardStyle.borderRadius };\r\n    }\r\n    if (square === \"a8\") {\r\n        return boardOrientation === \"white\"\r\n            ? { borderTopLeftRadius: customBoardStyle.borderRadius }\r\n            : { borderBottomRightRadius: customBoardStyle.borderRadius };\r\n    }\r\n    if (square === \"h1\") {\r\n        return boardOrientation === \"white\"\r\n            ? { borderBottomRightRadius: customBoardStyle.borderRadius }\r\n            : { borderTopLeftRadius: customBoardStyle.borderRadius };\r\n    }\r\n    if (square === \"h8\") {\r\n        return boardOrientation === \"white\"\r\n            ? { borderTopRightRadius: customBoardStyle.borderRadius }\r\n            : { borderBottomLeftRadius: customBoardStyle.borderRadius };\r\n    }\r\n    return {};\r\n};\n\nfunction Squares() {\r\n    const [squares, setSquares] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\r\n    const { arePremovesAllowed, boardOrientation, boardWidth, currentPosition, id, premoves, showBoardNotation, } = useChessboard();\r\n    const premovesHistory = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\r\n        const result = [];\r\n        // if premoves aren't allowed, don't waste time on calculations\r\n        if (!arePremovesAllowed)\r\n            return [];\r\n        premoves.forEach((premove, index) => {\r\n            const { sourceSq, targetSq, piece } = premove;\r\n            // determine if the premove is made by an already premoved piece\r\n            const relatedPremovedPiece = result.find((p) => { var _a; return p.piece === piece && ((_a = p.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === sourceSq; });\r\n            // if premove has been made by already premoved piece then write the move to its `premovesRoute` field to be able find its final destination later\r\n            if (relatedPremovedPiece) {\r\n                relatedPremovedPiece.premovesRoute.push({ sourceSq, targetSq, index });\r\n            }\r\n            // if premove has been made by standard piece create new object in `premovesHistory` where we will keep its own premoves\r\n            else {\r\n                result.push({\r\n                    piece,\r\n                    // index is useful for scenarios where two or more pieces are targeting the same square\r\n                    premovesRoute: [{ sourceSq, targetSq, index }],\r\n                });\r\n            }\r\n        });\r\n        return result;\r\n    }, [premoves]);\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ \"data-boardid\": id }, { children: [...Array(8)].map((_, r) => {\r\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: {\r\n                    display: \"flex\",\r\n                    flexWrap: \"nowrap\",\r\n                    width: boardWidth,\r\n                } }, { children: [...Array(8)].map((_, c) => {\r\n                    const square = boardOrientation === \"black\"\r\n                        ? (COLUMNS[7 - c] + (r + 1))\r\n                        : (COLUMNS[c] + (8 - r));\r\n                    const squareColor = c % 2 === r % 2 ? \"white\" : \"black\";\r\n                    const squareHasPremove = premoves.find((p) => p.sourceSq === square || p.targetSq === square);\r\n                    const squareHasPremoveTarget = premovesHistory\r\n                        .filter(({ premovesRoute }) => { var _a; return ((_a = premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.targetSq) === square; })\r\n                        //the premoved piece with the higher index will be shown, as it is the latest one\r\n                        .sort((a, b) => {\r\n                        var _a, _b;\r\n                        return ((_a = b.premovesRoute.at(-1)) === null || _a === void 0 ? void 0 : _a.index) -\r\n                            ((_b = a.premovesRoute.at(-1)) === null || _b === void 0 ? void 0 : _b.index);\r\n                    })\r\n                        .at(0);\r\n                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Square, Object.assign({ square: square, squareColor: squareColor, setSquares: setSquares, squareHasPremove: !!squareHasPremove }, { children: [!squareHasPremove && currentPosition[square] && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, { piece: currentPosition[square], square: square, squares: squares })), squareHasPremoveTarget && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Piece, { isPremovedPiece: true, piece: squareHasPremoveTarget.piece, square: square, squares: squares })), showBoardNotation && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Notation, { row: r, col: c })] }), `${c}${r}`));\r\n                }) }), r.toString()));\r\n        }) })));\r\n}\n\nconst Arrows = () => {\r\n    const { arrows, newArrow, boardOrientation, boardWidth, customArrowColor: primaryArrowCollor, } = useChessboard();\r\n    const arrowsList = [...arrows, newArrow].filter(Boolean);\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ width: boardWidth, height: boardWidth, style: {\r\n            position: \"absolute\",\r\n            top: \"0\",\r\n            left: \"0\",\r\n            pointerEvents: \"none\",\r\n            zIndex: \"10\",\r\n        } }, { children: arrowsList.map((arrow, i) => {\r\n            const [arrowStartField, arrowEndField, arrowColor] = arrow;\r\n            if (arrowStartField === arrowEndField)\r\n                return null;\r\n            const from = getRelativeCoords(boardOrientation, boardWidth, arrowStartField);\r\n            const to = getRelativeCoords(boardOrientation, boardWidth, arrowEndField);\r\n            let ARROW_LENGTH_REDUCER = boardWidth / 32;\r\n            const isArrowActive = i === arrows.length;\r\n            // if there are different arrows targeting the same square make their length a bit shorter\r\n            if (arrows.some((restArrow) => restArrow[0] !== arrowStartField && restArrow[1] === arrowEndField) &&\r\n                !isArrowActive) {\r\n                ARROW_LENGTH_REDUCER = boardWidth / 16;\r\n            }\r\n            const dx = to.x - from.x;\r\n            const dy = to.y - from.y;\r\n            const r = Math.hypot(dy, dx);\r\n            const end = {\r\n                x: from.x + (dx * (r - ARROW_LENGTH_REDUCER)) / r,\r\n                y: from.y + (dy * (r - ARROW_LENGTH_REDUCER)) / r,\r\n            };\r\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", Object.assign({ id: `arrowhead-${i}`, markerWidth: \"2\", markerHeight: \"2.5\", refX: \"1.25\", refY: \"1.25\", orient: \"auto\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polygon\", { points: \"0.3 0, 2 1.25, 0.3 2.5\", fill: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"line\", { x1: from.x, y1: from.y, x2: end.x, y2: end.y, opacity: isArrowActive ? \"0.5\" : \"0.65\", stroke: arrowColor !== null && arrowColor !== void 0 ? arrowColor : primaryArrowCollor, strokeWidth: isArrowActive ? (0.9 * boardWidth) / 40 : boardWidth / 40, markerEnd: `url(#arrowhead-${i})` })] }, `${arrowStartField}-${arrowEndField}${isArrowActive ? \"-active\" : \"\"}`));\r\n        }) })));\r\n};\n\nfunction PromotionOption({ option }) {\r\n    const [isHover, setIsHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\r\n    const { boardWidth, chessPieces, customDarkSquareStyle, customLightSquareStyle, handleSetPosition, onPromotionPieceSelect, promoteFromSquare, promoteToSquare, promotionDialogVariant, } = useChessboard();\r\n    const backgroundColor = () => {\r\n        switch (option[1]) {\r\n            case \"Q\":\r\n                return customDarkSquareStyle.backgroundColor;\r\n            case \"R\":\r\n                return customLightSquareStyle.backgroundColor;\r\n            case \"N\":\r\n                return promotionDialogVariant === \"default\"\r\n                    ? customLightSquareStyle.backgroundColor\r\n                    : customDarkSquareStyle.backgroundColor;\r\n            case \"B\":\r\n                return promotionDialogVariant === \"default\"\r\n                    ? customDarkSquareStyle.backgroundColor\r\n                    : customLightSquareStyle.backgroundColor;\r\n        }\r\n    };\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ onClick: () => {\r\n            if (onPromotionPieceSelect(option, promoteFromSquare !== null && promoteFromSquare !== void 0 ? promoteFromSquare : undefined, promoteToSquare !== null && promoteToSquare !== void 0 ? promoteToSquare : undefined))\r\n                handleSetPosition(promoteFromSquare, promoteToSquare, option, true);\r\n        }, onMouseOver: () => setIsHover(true), onMouseOut: () => setIsHover(false), \"data-piece\": option, style: {\r\n            cursor: \"pointer\",\r\n            backgroundColor: isHover ? backgroundColor() : `${backgroundColor()}aa`,\r\n            borderRadius: \"4px\",\r\n            transition: \"all 0.1s ease-out\",\r\n        } }, { children: typeof chessPieces[option] === \"function\" ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: {\r\n                transition: \"all 0.1s ease-out\",\r\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\",\r\n            } }, { children: chessPieces[option]({\r\n                squareWidth: boardWidth / 8,\r\n                isDragging: false,\r\n            }) }))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ viewBox: \"1 1 43 43\", width: boardWidth / 8, height: boardWidth / 8, style: {\r\n                transition: \"all 0.1s ease-out\",\r\n                transform: isHover ? \"scale(1)\" : \"scale(0.85)\",\r\n            } }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", { children: chessPieces[option] }) }))) })));\r\n}\n\nfunction PromotionDialog() {\r\n    const { boardOrientation, boardWidth, promotionDialogVariant, promoteToSquare, } = useChessboard();\r\n    const promotePieceColor = (promoteToSquare === null || promoteToSquare === void 0 ? void 0 : promoteToSquare[1]) === \"1\" ? \"b\" : \"w\";\r\n    const promotionOptions = [\r\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}Q`,\r\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}R`,\r\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}N`,\r\n        `${promotePieceColor !== null && promotePieceColor !== void 0 ? promotePieceColor : \"w\"}B`,\r\n    ];\r\n    const dialogStyles = {\r\n        default: {\r\n            display: \"grid\",\r\n            gridTemplateColumns: \"1fr 1fr\",\r\n            transform: `translate(${-boardWidth / 8}px, ${-boardWidth / 8}px)`,\r\n        },\r\n        vertical: {\r\n            transform: `translate(${-boardWidth / 16}px, ${-boardWidth / 16}px)`,\r\n        },\r\n        modal: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            alignItems: \"center\",\r\n            transform: `translate(0px, ${(3 * boardWidth) / 8}px)`,\r\n            width: \"100%\",\r\n            height: `${boardWidth / 4}px`,\r\n            top: 0,\r\n            backgroundColor: \"white\",\r\n            left: 0,\r\n        },\r\n    };\r\n    const dialogCoords = getRelativeCoords(boardOrientation, boardWidth, promoteToSquare || \"a8\");\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: Object.assign({ position: \"absolute\", top: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.y}px`, left: `${dialogCoords === null || dialogCoords === void 0 ? void 0 : dialogCoords.x}px`, zIndex: 1000 }, dialogStyles[promotionDialogVariant]), title: \"Choose promotion piece\" }, { children: promotionOptions.map((option) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionOption, { option: option }, option))) })));\r\n}\n\nconst errorImage = {\r\n    whiteKing: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ xmlns: \"http://www.w3.org/2000/svg\", version: \"1.1\", style: {\r\n            shapeRendering: \"geometricPrecision\",\r\n            textRendering: \"geometricPrecision\",\r\n            imageRendering: \"crisp-edges\",\r\n        }, viewBox: \"0 0 4210 12970\", x: \"0px\", y: \"0px\", fillRule: \"evenodd\", clipRule: \"evenodd\", width: \"250\", height: \"250\" }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", { style: {\r\n                    fill: \"black\",\r\n                    fillRule: \"nonzero\",\r\n                }, d: \"M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z\" }) }) }))),\r\n};\n\nfunction ErrorBoundary({ children }) {\r\n    try {\r\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });\r\n    }\r\n    catch (error) {\r\n        console.log(error);\r\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, { showError: true });\r\n    }\r\n}\r\nfunction WhiteKing({ showError = false }) {\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({ style: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            alignItems: \"center\",\r\n            flexDirection: \"column\",\r\n        } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: {\r\n                    width: 250,\r\n                    height: 250,\r\n                    transform: \"rotate(90deg)\",\r\n                } }, { children: errorImage.whiteKing })), showError && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", { children: \"Something went wrong\" })] })));\r\n}\n\nfunction Board() {\r\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\r\n    const { boardWidth, clearCurrentRightClickDown, onPromotionPieceSelect, setShowPromoteDialog, showPromoteDialog, customBoardStyle, } = useChessboard();\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        function handleClickOutside(event) {\r\n            if (boardRef.current &&\r\n                !boardRef.current.contains(event.target)) {\r\n                clearCurrentRightClickDown();\r\n            }\r\n        }\r\n        document.addEventListener(\"mouseup\", handleClickOutside);\r\n        return () => {\r\n            document.removeEventListener(\"mouseup\", handleClickOutside);\r\n        };\r\n    }, []);\r\n    return boardWidth ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: { perspective: \"1000px\" } }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({ ref: boardRef, style: Object.assign(Object.assign({ position: \"relative\" }, boardStyles(boardWidth)), customBoardStyle) }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Squares, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Arrows, {}), showPromoteDialog && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { onClick: () => {\r\n                                setShowPromoteDialog(false);\r\n                                onPromotionPieceSelect === null || onPromotionPieceSelect === void 0 ? void 0 : onPromotionPieceSelect();\r\n                            }, style: {\r\n                                position: \"absolute\",\r\n                                top: \"0\",\r\n                                left: \"0\",\r\n                                zIndex: \"100\",\r\n                                backgroundColor: \"rgba(22,21,18,.7)\",\r\n                                width: boardWidth,\r\n                                height: boardWidth,\r\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PromotionDialog, {})] }))] })) }))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(WhiteKing, {}));\r\n}\r\nconst boardStyles = (width) => ({\r\n    cursor: \"default\",\r\n    height: width,\r\n    width,\r\n});\n\nvar ListenerType;\n(function(ListenerType) {\n    ListenerType[\"mouse\"] = \"mouse\";\n    ListenerType[\"touch\"] = \"touch\";\n    ListenerType[\"keyboard\"] = \"keyboard\";\n})(ListenerType || (ListenerType = {}));\n\nclass OptionsReader {\n    get delay() {\n        var _delay;\n        return (_delay = this.args.delay) !== null && _delay !== void 0 ? _delay : 0;\n    }\n    get scrollAngleRanges() {\n        return this.args.scrollAngleRanges;\n    }\n    get getDropTargetElementsAtPoint() {\n        return this.args.getDropTargetElementsAtPoint;\n    }\n    get ignoreContextMenu() {\n        var _ignoreContextMenu;\n        return (_ignoreContextMenu = this.args.ignoreContextMenu) !== null && _ignoreContextMenu !== void 0 ? _ignoreContextMenu : false;\n    }\n    get enableHoverOutsideTarget() {\n        var _enableHoverOutsideTarget;\n        return (_enableHoverOutsideTarget = this.args.enableHoverOutsideTarget) !== null && _enableHoverOutsideTarget !== void 0 ? _enableHoverOutsideTarget : false;\n    }\n    get enableKeyboardEvents() {\n        var _enableKeyboardEvents;\n        return (_enableKeyboardEvents = this.args.enableKeyboardEvents) !== null && _enableKeyboardEvents !== void 0 ? _enableKeyboardEvents : false;\n    }\n    get enableMouseEvents() {\n        var _enableMouseEvents;\n        return (_enableMouseEvents = this.args.enableMouseEvents) !== null && _enableMouseEvents !== void 0 ? _enableMouseEvents : false;\n    }\n    get enableTouchEvents() {\n        var _enableTouchEvents;\n        return (_enableTouchEvents = this.args.enableTouchEvents) !== null && _enableTouchEvents !== void 0 ? _enableTouchEvents : true;\n    }\n    get touchSlop() {\n        return this.args.touchSlop || 0;\n    }\n    get delayTouchStart() {\n        var ref, ref1;\n        var ref2, ref3;\n        return (ref3 = (ref2 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayTouchStart) !== null && ref2 !== void 0 ? ref2 : (ref1 = this.args) === null || ref1 === void 0 ? void 0 : ref1.delay) !== null && ref3 !== void 0 ? ref3 : 0;\n    }\n    get delayMouseStart() {\n        var ref, ref4;\n        var ref5, ref6;\n        return (ref6 = (ref5 = (ref = this.args) === null || ref === void 0 ? void 0 : ref.delayMouseStart) !== null && ref5 !== void 0 ? ref5 : (ref4 = this.args) === null || ref4 === void 0 ? void 0 : ref4.delay) !== null && ref6 !== void 0 ? ref6 : 0;\n    }\n    get window() {\n        if (this.context && this.context.window) {\n            return this.context.window;\n        } else if (typeof window !== 'undefined') {\n            return window;\n        }\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.context) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.context.document;\n        }\n        if (this.window) {\n            return this.window.document;\n        }\n        return undefined;\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.args) === null || ref === void 0 ? void 0 : ref.rootElement) || this.document;\n    }\n    constructor(args, context){\n        this.args = args;\n        this.context = context;\n    }\n}\n\nfunction distance(x1, y1, x2, y2) {\n    return Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));\n}\nfunction inAngleRanges(x1, y1, x2, y2, angleRanges) {\n    if (!angleRanges) {\n        return false;\n    }\n    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI + 180;\n    for(let i = 0; i < angleRanges.length; ++i){\n        const ar = angleRanges[i];\n        if (ar && (ar.start == null || angle >= ar.start) && (ar.end == null || angle <= ar.end)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Used for MouseEvent.buttons (note the s on the end).\nconst MouseButtons = {\n    Left: 1,\n    Right: 2,\n    Center: 4\n};\n// Used for e.button (note the lack of an s on the end).\nconst MouseButton = {\n    Left: 0,\n    Center: 1,\n    Right: 2\n};\n/**\n * Only touch events and mouse events where the left button is pressed should initiate a drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldStartDrag(e) {\n    // For touch events, button will be undefined. If e.button is defined,\n    // then it should be MouseButton.Left.\n    return e.button === undefined || e.button === MouseButton.Left;\n}\n/**\n * Only touch events and mouse events where the left mouse button is no longer held should end a drag.\n * It's possible the user mouse downs with the left mouse button, then mouse down and ups with the right mouse button.\n * We don't want releasing the right mouse button to end the drag.\n * @param {MouseEvent | TouchEvent} e The event\n */ function eventShouldEndDrag(e) {\n    // Touch events will have buttons be undefined, while mouse events will have e.buttons's left button\n    // bit field unset if the left mouse button has been released\n    return e.buttons === undefined || (e.buttons & MouseButtons.Left) === 0;\n}\nfunction isTouchEvent(e) {\n    return !!e.targetTouches;\n}\n\nconst ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return undefined;\n    }\n    const { top , left  } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nfunction getEventClientTouchOffset(e, lastTargetTouchFallback) {\n    if (e.targetTouches.length === 1) {\n        return getEventClientOffset(e.targetTouches[0]);\n    } else if (lastTargetTouchFallback && e.touches.length === 1) {\n        if (e.touches[0].target === lastTargetTouchFallback.target) {\n            return getEventClientOffset(e.touches[0]);\n        }\n    }\n    return;\n}\nfunction getEventClientOffset(e, lastTargetTouchFallback) {\n    if (isTouchEvent(e)) {\n        return getEventClientTouchOffset(e, lastTargetTouchFallback);\n    } else {\n        return {\n            x: e.clientX,\n            y: e.clientY\n        };\n    }\n}\n\nconst supportsPassive = (()=>{\n    // simular to jQuery's test\n    let supported = false;\n    try {\n        addEventListener('test', ()=>{\n        // do nothing\n        }, Object.defineProperty({}, 'passive', {\n            get () {\n                supported = true;\n                return true;\n            }\n        }));\n    } catch (e) {\n    // do nothing\n    }\n    return supported;\n})();\n\nconst eventNames = {\n    [ListenerType.mouse]: {\n        start: 'mousedown',\n        move: 'mousemove',\n        end: 'mouseup',\n        contextmenu: 'contextmenu'\n    },\n    [ListenerType.touch]: {\n        start: 'touchstart',\n        move: 'touchmove',\n        end: 'touchend'\n    },\n    [ListenerType.keyboard]: {\n        keydown: 'keydown'\n    }\n};\nclass TouchBackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref;\n        return {\n            sourceNodes: this.sourceNodes.size,\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            targetNodes: this.targetNodes.size,\n            dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n        };\n    }\n    // public for test\n    get document() {\n        return this.options.document;\n    }\n    setup() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n        TouchBackendImpl.isSetUp = true;\n        this.addEventListener(root, 'start', this.getTopMoveStartHandler());\n        this.addEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n        this.addEventListener(root, 'move', this.handleTopMove);\n        this.addEventListener(root, 'move', this.handleTopMoveCapture, true);\n        this.addEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.addEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.addEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n        }\n    }\n    teardown() {\n        const root = this.options.rootElement;\n        if (!root) {\n            return;\n        }\n        TouchBackendImpl.isSetUp = false;\n        this._mouseClientOffset = {};\n        this.removeEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n        this.removeEventListener(root, 'start', this.handleTopMoveStart);\n        this.removeEventListener(root, 'move', this.handleTopMoveCapture, true);\n        this.removeEventListener(root, 'move', this.handleTopMove);\n        this.removeEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n        if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n            this.removeEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.removeEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n        }\n        this.uninstallSourceNodeRemovalObserver();\n    }\n    addEventListener(subject, event, handler, capture = false) {\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.addEventListener(evt, handler, options);\n            }\n        });\n    }\n    removeEventListener(subject, event, handler, capture = false) {\n        const options = supportsPassive ? {\n            capture,\n            passive: false\n        } : capture;\n        this.listenerTypes.forEach(function(listenerType) {\n            const evt = eventNames[listenerType][event];\n            if (evt) {\n                subject.removeEventListener(evt, handler, options);\n            }\n        });\n    }\n    connectDragSource(sourceId, node) {\n        const handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n        this.sourceNodes.set(sourceId, node);\n        this.addEventListener(node, 'start', handleMoveStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.removeEventListener(node, 'start', handleMoveStart);\n        };\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const root = this.options.rootElement;\n        if (!this.document || !root) {\n            return ()=>{\n            /* noop */ };\n        }\n        const handleMove = (e)=>{\n            if (!this.document || !root || !this.monitor.isDragging()) {\n                return;\n            }\n            let coords;\n            /**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */ switch(e.type){\n                case eventNames.mouse.move:\n                    coords = {\n                        x: e.clientX,\n                        y: e.clientY\n                    };\n                    break;\n                case eventNames.touch.move:\n                    var ref, ref1;\n                    coords = {\n                        x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n                        y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n                    };\n                    break;\n            }\n            /**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */ const droppedOn = coords != null ? this.document.elementFromPoint(coords.x, coords.y) : undefined;\n            const childMatch = droppedOn && node.contains(droppedOn);\n            if (droppedOn === node || childMatch) {\n                return this.handleMove(e, targetId);\n            }\n        };\n        /**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */ this.addEventListener(this.document.body, 'move', handleMove);\n        this.targetNodes.set(targetId, node);\n        return ()=>{\n            if (this.document) {\n                this.targetNodes.delete(targetId);\n                this.removeEventListener(this.document.body, 'move', handleMove);\n            }\n        };\n    }\n    getTopMoveStartHandler() {\n        if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n            return this.handleTopMoveStart;\n        }\n        return this.handleTopMoveStartDelay;\n    }\n    installSourceNodeRemovalObserver(node) {\n        this.uninstallSourceNodeRemovalObserver();\n        this.draggedSourceNode = node;\n        this.draggedSourceNodeRemovalObserver = new MutationObserver(()=>{\n            if (node && !node.parentElement) {\n                this.resurrectSourceNode();\n                this.uninstallSourceNodeRemovalObserver();\n            }\n        });\n        if (!node || !node.parentElement) {\n            return;\n        }\n        this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n            childList: true\n        });\n    }\n    resurrectSourceNode() {\n        if (this.document && this.draggedSourceNode) {\n            this.draggedSourceNode.style.display = 'none';\n            this.draggedSourceNode.removeAttribute('data-reactid');\n            this.document.body.appendChild(this.draggedSourceNode);\n        }\n    }\n    uninstallSourceNodeRemovalObserver() {\n        if (this.draggedSourceNodeRemovalObserver) {\n            this.draggedSourceNodeRemovalObserver.disconnect();\n        }\n        this.draggedSourceNodeRemovalObserver = undefined;\n        this.draggedSourceNode = undefined;\n    }\n    constructor(manager, context, options){\n        this.getSourceClientOffset = (sourceId)=>{\n            const element = this.sourceNodes.get(sourceId);\n            return element && getNodeClientOffset(element);\n        };\n        this.handleTopMoveStartCapture = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            this.moveStartSourceIds = [];\n        };\n        this.handleMoveStart = (sourceId)=>{\n            // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n            // We only collect start collecting drag sources on touch and left mouse events.\n            if (Array.isArray(this.moveStartSourceIds)) {\n                this.moveStartSourceIds.unshift(sourceId);\n            }\n        };\n        this.handleTopMoveStart = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            // Don't prematurely preventDefault() here since it might:\n            // 1. Mess up scrolling\n            // 2. Mess up long tap (which brings up context menu)\n            // 3. If there's an anchor link as a child, tap won't be triggered on link\n            const clientOffset = getEventClientOffset(e);\n            if (clientOffset) {\n                if (isTouchEvent(e)) {\n                    this.lastTargetTouchFallback = e.targetTouches[0];\n                }\n                this._mouseClientOffset = clientOffset;\n            }\n            this.waitingForDelay = false;\n        };\n        this.handleTopMoveStartDelay = (e)=>{\n            if (!eventShouldStartDrag(e)) {\n                return;\n            }\n            const delay = e.type === eventNames.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;\n            this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e), delay);\n            this.waitingForDelay = true;\n        };\n        this.handleTopMoveCapture = ()=>{\n            this.dragOverTargetIds = [];\n        };\n        this.handleMove = (_evt, targetId)=>{\n            if (this.dragOverTargetIds) {\n                this.dragOverTargetIds.unshift(targetId);\n            }\n        };\n        this.handleTopMove = (e1)=>{\n            if (this.timeout) {\n                clearTimeout(this.timeout);\n            }\n            if (!this.document || this.waitingForDelay) {\n                return;\n            }\n            const { moveStartSourceIds , dragOverTargetIds  } = this;\n            const enableHoverOutsideTarget = this.options.enableHoverOutsideTarget;\n            const clientOffset = getEventClientOffset(e1, this.lastTargetTouchFallback);\n            if (!clientOffset) {\n                return;\n            }\n            // If the touch move started as a scroll, or is is between the scroll angles\n            if (this._isScrolling || !this.monitor.isDragging() && inAngleRanges(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, this.options.scrollAngleRanges)) {\n                this._isScrolling = true;\n                return;\n            }\n            // If we're not dragging and we've moved a little, that counts as a drag start\n            if (!this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n            this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (this.options.touchSlop ? this.options.touchSlop : 0)) {\n                this.moveStartSourceIds = undefined;\n                this.actions.beginDrag(moveStartSourceIds, {\n                    clientOffset: this._mouseClientOffset,\n                    getSourceClientOffset: this.getSourceClientOffset,\n                    publishSource: false\n                });\n            }\n            if (!this.monitor.isDragging()) {\n                return;\n            }\n            const sourceNode = this.sourceNodes.get(this.monitor.getSourceId());\n            this.installSourceNodeRemovalObserver(sourceNode);\n            this.actions.publishDragSource();\n            if (e1.cancelable) e1.preventDefault();\n            // Get the node elements of the hovered DropTargets\n            const dragOverTargetNodes = (dragOverTargetIds || []).map((key)=>this.targetNodes.get(key)\n            ).filter((e)=>!!e\n            );\n            // Get the a ordered list of nodes that are touched by\n            const elementsAtPoint = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n            // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n            const elementsAtPointExtended = [];\n            for(const nodeId in elementsAtPoint){\n                // eslint-disable-next-line no-prototype-builtins\n                if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n                    continue;\n                }\n                let currentNode = elementsAtPoint[nodeId];\n                if (currentNode != null) {\n                    elementsAtPointExtended.push(currentNode);\n                }\n                while(currentNode){\n                    currentNode = currentNode.parentElement;\n                    if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n                        elementsAtPointExtended.push(currentNode);\n                    }\n                }\n            }\n            const orderedDragOverTargetIds = elementsAtPointExtended// Filter off nodes that arent a hovered DropTargets nodes\n            .filter((node)=>dragOverTargetNodes.indexOf(node) > -1\n            )// Map back the nodes elements to targetIds\n            .map((node)=>this._getDropTargetId(node)\n            )// Filter off possible null rows\n            .filter((node)=>!!node\n            ).filter((id, index, ids)=>ids.indexOf(id) === index\n            );\n            // Invoke hover for drop targets when source node is still over and pointer is outside\n            if (enableHoverOutsideTarget) {\n                for(const targetId in this.targetNodes){\n                    const targetNode = this.targetNodes.get(targetId);\n                    if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n                        orderedDragOverTargetIds.unshift(targetId);\n                        break;\n                    }\n                }\n            }\n            // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n            orderedDragOverTargetIds.reverse();\n            this.actions.hover(orderedDragOverTargetIds, {\n                clientOffset: clientOffset\n            });\n        };\n        /**\n\t *\n\t * visible for testing\n\t */ this._getDropTargetId = (node)=>{\n            const keys = this.targetNodes.keys();\n            let next = keys.next();\n            while(next.done === false){\n                const targetId = next.value;\n                if (node === this.targetNodes.get(targetId)) {\n                    return targetId;\n                } else {\n                    next = keys.next();\n                }\n            }\n            return undefined;\n        };\n        this.handleTopMoveEndCapture = (e)=>{\n            this._isScrolling = false;\n            this.lastTargetTouchFallback = undefined;\n            if (!eventShouldEndDrag(e)) {\n                return;\n            }\n            if (!this.monitor.isDragging() || this.monitor.didDrop()) {\n                this.moveStartSourceIds = undefined;\n                return;\n            }\n            if (e.cancelable) e.preventDefault();\n            this._mouseClientOffset = {};\n            this.uninstallSourceNodeRemovalObserver();\n            this.actions.drop();\n            this.actions.endDrag();\n        };\n        this.handleCancelOnEscape = (e)=>{\n            if (e.key === 'Escape' && this.monitor.isDragging()) {\n                this._mouseClientOffset = {};\n                this.uninstallSourceNodeRemovalObserver();\n                this.actions.endDrag();\n            }\n        };\n        this.options = new OptionsReader(options, context);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.sourceNodes = new Map();\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.targetNodes = new Map();\n        this.listenerTypes = [];\n        this._mouseClientOffset = {};\n        this._isScrolling = false;\n        if (this.options.enableMouseEvents) {\n            this.listenerTypes.push(ListenerType.mouse);\n        }\n        if (this.options.enableTouchEvents) {\n            this.listenerTypes.push(ListenerType.touch);\n        }\n        if (this.options.enableKeyboardEvents) {\n            this.listenerTypes.push(ListenerType.keyboard);\n        }\n    }\n}\n\nconst TouchBackend = function createBackend(manager, context = {}, options = {}) {\n    return new TouchBackendImpl(manager, context, options);\n};\n\nconst ChessboardDnDContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({ isCustomDndProviderSet: false });\r\nconst EmptyProvider = ({ children }) => {\r\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });\r\n};\r\nconst ChessboardDnDProvider = ({ children, backend, context, options, debugMode, }) => {\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDContext.Provider, Object.assign({ value: { isCustomDndProviderSet: true } }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DndProvider, Object.assign({ backend: backend || (\"ontouchstart\" in window ? TouchBackend : HTML5Backend), context: context, options: options, debugMode: debugMode !== null && debugMode !== void 0 ? debugMode : false }, { children: children })) })));\r\n};\r\nconst ChessboardDnDRoot = ({ customDndBackend, customDndBackendOptions, children, }) => {\r\n    const [clientWindow, setClientWindow] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\r\n    const [backendSet, setBackendSet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\r\n    const [isMobile, setIsMobile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\r\n    const { isCustomDndProviderSet } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChessboardDnDContext);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setIsMobile(\"ontouchstart\" in window);\r\n        setBackendSet(true);\r\n        setClientWindow(window);\r\n    }, []);\r\n    // in case we already wrapped `<Chessboard/>`  with `<DnDProvider/>` we don't need to create a new one\r\n    const DnDWrapper = isCustomDndProviderSet ? EmptyProvider : DndProvider;\r\n    if (!backendSet) {\r\n        return null;\r\n    }\r\n    return clientWindow ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DnDWrapper, Object.assign({ backend: customDndBackend || (isMobile ? TouchBackend : HTML5Backend), context: clientWindow, options: customDndBackend ? customDndBackendOptions : undefined }, { children: children }))) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }));\r\n};\n\nfunction CustomDragLayer({ boardContainer }) {\r\n    const { boardWidth, chessPieces, id, snapToCursor, allowDragOutsideBoard } = useChessboard();\r\n    const collectedProps = useDragLayer((monitor) => ({\r\n        item: monitor.getItem(),\r\n        clientOffset: monitor.getClientOffset(),\r\n        sourceClientOffset: monitor.getSourceClientOffset(),\r\n        isDragging: monitor.isDragging(),\r\n    }));\r\n    const { isDragging, item, clientOffset, sourceClientOffset, } = collectedProps;\r\n    const getItemStyle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((clientOffset, sourceClientOffset) => {\r\n        if (!clientOffset || !sourceClientOffset)\r\n            return { display: \"none\" };\r\n        let { x, y } = snapToCursor ? clientOffset : sourceClientOffset;\r\n        const halfSquareWidth = boardWidth / 8 / 2;\r\n        if (snapToCursor) {\r\n            x -= halfSquareWidth;\r\n            y -= halfSquareWidth;\r\n        }\r\n        if (!allowDragOutsideBoard) {\r\n            const { left, top } = boardContainer;\r\n            // half square so the piece reaches the board\r\n            const maxLeft = left - halfSquareWidth;\r\n            const maxTop = top - halfSquareWidth;\r\n            const maxRight = left + boardWidth - halfSquareWidth;\r\n            const maxBottom = top + boardWidth - halfSquareWidth;\r\n            x = Math.max(maxLeft, Math.min(x, maxRight));\r\n            y = Math.max(maxTop, Math.min(y, maxBottom));\r\n        }\r\n        const transform = `translate(${x}px, ${y}px)`;\r\n        return {\r\n            transform,\r\n            WebkitTransform: transform,\r\n            touchAction: \"none\",\r\n        };\r\n    }, [boardWidth, allowDragOutsideBoard, snapToCursor, boardContainer]);\r\n    return isDragging && item.id === id ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: {\r\n            position: \"fixed\",\r\n            pointerEvents: \"none\",\r\n            zIndex: 10,\r\n            left: 0,\r\n            top: 0,\r\n        } }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ style: getItemStyle(clientOffset, sourceClientOffset) }, { children: typeof chessPieces[item.piece] === \"function\" ? (chessPieces[item.piece]({\r\n                squareWidth: boardWidth / 8,\r\n                isDragging: true,\r\n            })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ viewBox: \"1 1 43 43\", width: boardWidth / 8, height: boardWidth / 8 }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", { children: chessPieces[item.piece] }) }))) })) }))) : null;\r\n}\n\nconst SparePiece = ({ piece, width, customPieceJSX, dndId, }) => {\r\n    const renderPiece = customPieceJSX !== null && customPieceJSX !== void 0 ? customPieceJSX : defaultPieces[piece];\r\n    const [{ canDrag, isDragging }, drag, dragPreview] = useDrag(() => ({\r\n        type: \"piece\",\r\n        item: () => {\r\n            return { piece, isSpare: true, id: dndId };\r\n        },\r\n        collect: (monitor) => ({\r\n            canDrag: true,\r\n            isDragging: !!monitor.isDragging(),\r\n        }),\r\n    }), [piece, dndId]);\r\n    // hide the default preview\r\n    dragPreview(getEmptyImage(), { captureDraggingState: true });\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", Object.assign({ ref: canDrag ? drag : null, \"data-piece\": piece, style: { cursor: \"move\" } }, { children: typeof renderPiece === \"function\" ? (renderPiece({\r\n            squareWidth: width,\r\n            isDragging,\r\n        })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", Object.assign({ viewBox: \"1 1 43 43\", width: width, height: width }, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", { children: renderPiece }) }))) })));\r\n};\n\nconst Chessboard = (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref) => {\r\n    const { customDndBackend, customDndBackendOptions, onBoardWidthChange } = props, otherProps = __rest(props, [\"customDndBackend\", \"customDndBackendOptions\", \"onBoardWidthChange\"]);\r\n    const [boardWidth, setBoardWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(props.boardWidth);\r\n    const boardRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\r\n    const boardContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\r\n    const [boardContainerPos, setBoardContainerPos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\r\n        left: 0,\r\n        top: 0,\r\n    });\r\n    const metrics = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => { var _a; return (_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect(); }, [boardRef.current]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        boardWidth && (onBoardWidthChange === null || onBoardWidthChange === void 0 ? void 0 : onBoardWidthChange(boardWidth));\r\n    }, [boardWidth]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        setBoardContainerPos({\r\n            left: (metrics === null || metrics === void 0 ? void 0 : metrics.left) ? metrics === null || metrics === void 0 ? void 0 : metrics.left : 0,\r\n            top: (metrics === null || metrics === void 0 ? void 0 : metrics.top) ? metrics === null || metrics === void 0 ? void 0 : metrics.top : 0,\r\n        });\r\n    }, [metrics]);\r\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\r\n        var _a;\r\n        if (props.boardWidth === undefined && ((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth)) {\r\n            const resizeObserver = new ResizeObserver(() => {\r\n                var _a;\r\n                setBoardWidth((_a = boardRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth);\r\n            });\r\n            resizeObserver.observe(boardRef.current);\r\n            return () => {\r\n                resizeObserver.disconnect();\r\n            };\r\n        }\r\n    }, [boardRef.current]);\r\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorBoundary, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", Object.assign({ ref: boardContainerRef, style: {\r\n                display: \"flex\",\r\n                flexDirection: \"column\",\r\n                width: \"100%\",\r\n            } }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: boardRef, style: { width: \"100%\" } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ChessboardDnDRoot, Object.assign({ customDndBackend: customDndBackend, customDndBackendOptions: customDndBackendOptions }, { children: boardWidth && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(ChessboardProvider, Object.assign({ boardWidth: boardWidth }, otherProps, { ref: ref }, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomDragLayer, { boardContainer: boardContainerPos }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Board, {})] }))) }))] })) }));\r\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF3RDtBQUMySjs7QUFFbk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBRyx3QkFBd0IsZ0ZBQWdGLElBQUksVUFBVSxzREFBRyxXQUFXO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsU0FBUyxzREFBRyx3QkFBd0IsZ0ZBQWdGLElBQUksVUFBVSx1REFBSSxzQkFBc0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSSxXQUFXLHNEQUFHLFdBQVcsdURBQXVELHlCQUF5QixHQUFHLHNEQUFHLFdBQVcsMERBQTBELHlCQUF5QixHQUFHLHNEQUFHLFdBQVcseUdBQXlHLHlCQUF5QixHQUFH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cEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixnRUFBZ0U7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGdCQUFnQixJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pELGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFNLG1CQUFtQixxQkFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBQ0Esc0NBQXNDLCtDQUFRO0FBQzlDO0FBQ0EsNEJBQTRCLGtEQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXLDhDQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxhQUFhO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbURBQW1EO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBWTtBQUMzQjtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ04sZUFBZSxtREFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUIsRUFBRSxpREFBVTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw4Q0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixXQUFXLDhDQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDhDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUF5RDtBQUNyRSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQkFBMEI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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L19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmVzbS5qcz8xZjA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUNvbnRleHQsIG1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIGlzVmFsaWRFbGVtZW50LCBjbG9uZUVsZW1lbnQsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEgfSBmcm9tICdyZWFjdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmNvbnN0IENPTFVNTlMgPSBcImFiY2RlZmdoXCIuc3BsaXQoXCJcIik7XHJcbmNvbnN0IFNUQVJUX1BPU0lUSU9OX09CSkVDVCA9IHtcclxuICAgIGE4OiBcImJSXCIsXHJcbiAgICBiODogXCJiTlwiLFxyXG4gICAgYzg6IFwiYkJcIixcclxuICAgIGQ4OiBcImJRXCIsXHJcbiAgICBlODogXCJiS1wiLFxyXG4gICAgZjg6IFwiYkJcIixcclxuICAgIGc4OiBcImJOXCIsXHJcbiAgICBoODogXCJiUlwiLFxyXG4gICAgYTc6IFwiYlBcIixcclxuICAgIGI3OiBcImJQXCIsXHJcbiAgICBjNzogXCJiUFwiLFxyXG4gICAgZDc6IFwiYlBcIixcclxuICAgIGU3OiBcImJQXCIsXHJcbiAgICBmNzogXCJiUFwiLFxyXG4gICAgZzc6IFwiYlBcIixcclxuICAgIGg3OiBcImJQXCIsXHJcbiAgICBhMjogXCJ3UFwiLFxyXG4gICAgYjI6IFwid1BcIixcclxuICAgIGMyOiBcIndQXCIsXHJcbiAgICBkMjogXCJ3UFwiLFxyXG4gICAgZTI6IFwid1BcIixcclxuICAgIGYyOiBcIndQXCIsXHJcbiAgICBnMjogXCJ3UFwiLFxyXG4gICAgaDI6IFwid1BcIixcclxuICAgIGExOiBcIndSXCIsXHJcbiAgICBiMTogXCJ3TlwiLFxyXG4gICAgYzE6IFwid0JcIixcclxuICAgIGQxOiBcIndRXCIsXHJcbiAgICBlMTogXCJ3S1wiLFxyXG4gICAgZjE6IFwid0JcIixcclxuICAgIGcxOiBcIndOXCIsXHJcbiAgICBoMTogXCJ3UlwiLFxyXG59O1xyXG5jb25zdCBXSElURV9DT0xVTU5fVkFMVUVTID0ge1xyXG4gICAgYTogMCxcclxuICAgIGI6IDEsXHJcbiAgICBjOiAyLFxyXG4gICAgZDogMyxcclxuICAgIGU6IDQsXHJcbiAgICBmOiA1LFxyXG4gICAgZzogNixcclxuICAgIGg6IDcsXHJcbn07XHJcbmNvbnN0IEJMQUNLX0NPTFVNTl9WQUxVRVMgPSB7XHJcbiAgICBhOiA3LFxyXG4gICAgYjogNixcclxuICAgIGM6IDUsXHJcbiAgICBkOiA0LFxyXG4gICAgZTogMyxcclxuICAgIGY6IDIsXHJcbiAgICBnOiAxLFxyXG4gICAgaDogMCxcclxufTtcclxuY29uc3QgV0hJVEVfUk9XUyA9IFs3LCA2LCA1LCA0LCAzLCAyLCAxLCAwXTtcclxuY29uc3QgQkxBQ0tfUk9XUyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3XTtcblxuLy8gaHR0cHM6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9DYXRlZ29yeTpTVkdfY2hlc3NfcGllY2VzXHJcbi8vIEJ5IGVuOlVzZXI6Q2J1cm5ldHQgLSBPd24gd29ya1xyXG4vLyBUaGlzIFczQyAtIHVuc3BlY2lmaWVkIHZlY3RvciBpbWFnZSB3YXMgY3JlYXRlZCB3aXRoIElua3NjYXBlLiwgQ0MgQlkgLSBTQSAzLjAsIGh0dHBzOi8vY29tbW9ucy53aWtpbWVkaWEub3JnL3cvaW5kZXgucGhwP2N1cmlkPTE0OTk4MTBcclxuY29uc3QgZGVmYXVsdFBpZWNlcyA9IHtcclxuICAgIHdQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIHdSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLDM2IEwgMTIsMzIgTCAzMywzMiBMIDMzLDM2IEwgMTIsMzYgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDExLDkgTCAxNSw5IEwgMTUsMTEgTCAyMCwxMSBMIDIwLDkgTCAyNSw5IEwgMjUsMTEgTCAzMCwxMSBMIDMwLDkgTCAzNCw5IEwgMzQsMTRcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAzNCwxNCBMIDMxLDE3IEwgMTQsMTcgTCAxMSwxNFwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDE3IEwgMzEsMjkuNSBMIDE0LDI5LjUgTCAxNCwxN1wiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMxLDI5LjUgTCAzMi41LDMyIEwgMTIuNSwzMiBMIDE0LDI5LjVcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgd046IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMiwxMCBDIDMyLjUsMTEgMzguNSwxOCAzOCwzOSBMIDE1LDM5IEMgMTUsMzAgMjUsMzIuNSAyMywxOFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI0LDE4IEMgMjQuMzgsMjAuOTEgMTguNDUsMjUuMzcgMTYsMjcgQyAxMywyOSAxMy4xOCwzMS4zNCAxMSwzMSBDIDkuOTU4LDMwLjA2IDEyLjQxLDI3Ljk2IDExLDI4IEMgMTAsMjggMTEuMTksMjkuMjMgMTAsMzAgQyA5LDMwIDUuOTk3LDMxIDYsMjYgQyA2LDI0IDEyLDE0IDEyLDE0IEMgMTIsMTQgMTMuODksMTIuMSAxNCwxMC41IEMgMTMuMjcsOS41MDYgMTMuNSw4LjUgMTMuNSw3LjUgQyAxNC41LDYuNSAxNi41LDEwIDE2LjUsMTAgTCAxOC41LDEwIEMgMTguNSwxMCAxOS4yOCw4LjAwOCAyMSw3IEMgMjIsNyAyMiwxMCAyMiwxMFwiLCBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDkuNSAyNS41IEEgMC41IDAuNSAwIDEgMSA4LjUsMjUuNSBBIDAuNSAwLjUgMCAxIDEgOS41IDI1LjUgelwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE1IDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNCwxNS41IEEgMC41IDEuNSAwIDEgMSAgMTUgMTUuNSB6XCIsIHRyYW5zZm9ybTogXCJtYXRyaXgoMC44NjYsMC41LC0wLjUsMC44NjYsOS42OTMsLTUuMTczKVwiLCBzdHlsZTogeyBmaWxsOiBcIiMwMDAwMDBcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdCOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBmaWxsOiBcIiNmZmZmZmZcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUsMzIgQyAxNy41LDM0LjUgMjcuNSwzNC41IDMwLDMyIEMgMzAuNSwzMC41IDMwLDMwIDMwLDMwIEMgMzAsMjcuNSAyNy41LDI2IDI3LjUsMjYgQyAzMywyNC41IDMzLjUsMTQuNSAyMi41LDEwLjUgQyAxMS41LDE0LjUgMTIsMjQuNSAxNy41LDI2IEMgMTcuNSwyNiAxNSwyNy41IDE1LDMwIEMgMTUsMzAgMTQuNSwzMC41IDE1LDMyIHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNSA4IEEgMi41IDIuNSAwIDEgMSAgMjAsOCBBIDIuNSAyLjUgMCAxIDEgIDI1IDggelwiIH0pXSB9KSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTcuNSwyNiBMIDI3LjUsMjYgTSAxNSwzMCBMIDMwLDMwIE0gMjIuNSwxNS41IEwgMjIuNSwyMC41IE0gMjAsMTggTCAyNSwxOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIHdROiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDI2IEMgMTcuNSwyNC41IDMwLDI0LjUgMzYsMjYgTCAzOC41LDEzLjUgTCAzMSwyNSBMIDMwLjcsMTAuOSBMIDI1LjUsMjQuNSBMIDIyLjUsMTAgTCAxOS41LDI0LjUgTCAxNC4zLDEwLjkgTCAxNCwyNSBMIDYuNSwxMy41IEwgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwyNiBDIDksMjggMTAuNSwyOCAxMS41LDMwIEMgMTIuNSwzMS41IDEyLjUsMzEgMTIsMzMuNSBDIDEwLjUsMzQuNSAxMSwzNiAxMSwzNiBDIDkuNSwzNy41IDExLDM4LjUgMTEsMzguNSBDIDE3LjUsMzkuNSAyNy41LDM5LjUgMzQsMzguNSBDIDM0LDM4LjUgMzUuNSwzNy41IDM0LDM2IEMgMzQsMzYgMzQuNSwzNC41IDMzLDMzLjUgQyAzMi41LDMxIDMyLjUsMzEuNSAzMy41LDMwIEMgMzQuNSwyOCAzNiwyOCAzNiwyNiBDIDI3LjUsMjQuNSAxNy41LDI0LjUgOSwyNiB6XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzMCBDIDE1LDI5IDMwLDI5IDMzLjUsMzBcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMiwzMy41IEMgMTgsMzIuNSAyNywzMi41IDMzLDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIgfSB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiNlwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMTRcIiwgY3k6IFwiOVwiLCByOiBcIjJcIiB9KSwganN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMjIuNVwiLCBjeTogXCI4XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzMVwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzOVwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KV0gfSkpIH0pKSksXHJcbiAgICB3SzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjAsOCBMIDI1LDhcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIsIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDI1IEMgMjIuNSwyNSAyNywxNy41IDI1LjUsMTQuNSBDIDI1LjUsMTQuNSAyNC41LDEyIDIyLjUsMTIgQyAyMC41LDEyIDE5LjUsMTQuNSAxOS41LDE0LjUgQyAxOCwxNy41IDIyLjUsMjUgMjIuNSwyNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjZmZmZmZmXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiB9IH0pXSB9KSkgfSkpKSxcclxuICAgIGJQOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSkgfSkpKSxcclxuICAgIGJSOiAoanN4KFwic3ZnXCIsIE9iamVjdC5hc3NpZ24oeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB3aWR0aDogXCI0NVwiLCBoZWlnaHQ6IFwiNDVcIiB9LCB7IGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogXCI0XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogW2pzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwzOSBMIDM2LDM5IEwgMzYsMzYgTCA5LDM2IEwgOSwzOSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzIgTCAxNCwyOS41IEwgMzEsMjkuNSBMIDMyLjUsMzIgTCAxMi41LDMyIHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzYgTCAxMiwzMiBMIDMzLDMyIEwgMzMsMzYgTCAxMiwzNiB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDI5LjUgTCAxNCwxNi41IEwgMzEsMTYuNSBMIDMxLDI5LjUgTCAxNCwyOS41IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMTYuNSBMIDExLDE0IEwgMzQsMTQgTCAzMSwxNi41IEwgMTQsMTYuNSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDE0IEwgMTEsOSBMIDE1LDkgTCAxNSwxMSBMIDIwLDExIEwgMjAsOSBMIDI1LDkgTCAyNSwxMSBMIDMwLDExIEwgMzAsOSBMIDM0LDkgTCAzNCwxNCBMIDExLDE0IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6IFwiYnV0dFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzUuNSBMIDMzLDM1LjUgTCAzMywzNS41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMywzMS41IEwgMzIsMzEuNVwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiNmZmZmZmZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMjkuNSBMIDMxLDI5LjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDE0LDE2LjUgTCAzMSwxNi41XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDM0LDE0XCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiI2ZmZmZmZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KV0gfSkpIH0pKSksXHJcbiAgICBiTjogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU1pdGVybGltaXQ6IFwiNFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQsMTggQyAyNC4zOCwyMC45MSAxOC40NSwyNS4zNyAxNiwyNyBDIDEzLDI5IDEzLjE4LDMxLjM0IDExLDMxIEMgOS45NTgsMzAuMDYgMTIuNDEsMjcuOTYgMTEsMjggQyAxMCwyOCAxMS4xOSwyOS4yMyAxMCwzMCBDIDksMzAgNS45OTcsMzEgNiwyNiBDIDYsMjQgMTIsMTQgMTIsMTQgQyAxMiwxNCAxMy44OSwxMi4xIDE0LDEwLjUgQyAxMy4yNyw5LjUwNiAxMy41LDguNSAxMy41LDcuNSBDIDE0LjUsNi41IDE2LjUsMTAgMTYuNSwxMCBMIDE4LjUsMTAgQyAxOC41LDEwIDE5LjI4LDguMDA4IDIxLDcgQyAyMiw3IDIyLDEwIDIyLDEwXCIsIHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gOS41IDI1LjUgQSAwLjUgMC41IDAgMSAxIDguNSwyNS41IEEgMC41IDAuNSAwIDEgMSA5LjUgMjUuNSB6XCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIiwgdHJhbnNmb3JtOiBcIm1hdHJpeCgwLjg2NiwwLjUsLTAuNSwwLjg2Niw5LjY5MywtNS4xNzMpXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjQuNTUsMTAuNCBMIDI0LjEsMTEuODUgTCAyNC42LDEyIEMgMjcuNzUsMTMgMzAuMjUsMTQuNDkgMzIuNSwxOC43NSBDIDM0Ljc1LDIzLjAxIDM1Ljc1LDI5LjA2IDM1LjI1LDM5IEwgMzUuMiwzOS41IEwgMzcuNDUsMzkuNSBMIDM3LjUsMzkgQyAzOCwyOC45NCAzNi42MiwyMi4xNSAzNC4yNSwxNy42NiBDIDMxLjg4LDEzLjE3IDI4LjQ2LDExLjAyIDI1LjA2LDEwLjUgTCAyNC41NSwxMC40IHogXCIsIHN0eWxlOiB7IGZpbGw6IFwiI2ZmZmZmZlwiLCBzdHJva2U6IFwibm9uZVwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYkI6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7IGZpbGw6IFwiIzAwMDAwMFwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMzYgQyAxMi4zOSwzNS4wMyAxOS4xMSwzNi40MyAyMi41LDM0IEMgMjUuODksMzYuNDMgMzIuNjEsMzUuMDMgMzYsMzYgQyAzNiwzNiAzNy42NSwzNi41NCAzOSwzOCBDIDM4LjMyLDM4Ljk3IDM3LjM1LDM4Ljk5IDM2LDM4LjUgQyAzMi42MSwzNy41MyAyNS44OSwzOC45NiAyMi41LDM3LjUgQyAxOS4xMSwzOC45NiAxMi4zOSwzNy41MyA5LDM4LjUgQyA3LjY1LDM4Ljk5IDYuNjgsMzguOTcgNiwzOCBDIDcuMzUsMzYuNTQgOSwzNiA5LDM2IHpcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDI1IDggQSAyLjUgMi41IDAgMSAxICAyMCw4IEEgMi41IDIuNSAwIDEgMSAgMjUgOCB6XCIgfSldIH0pKSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiI2ZmZmZmZlwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0gfSldIH0pKSB9KSkpLFxyXG4gICAgYlE6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHdpZHRoOiBcIjQ1XCIsIGhlaWdodDogXCI0NVwiIH0sIHsgY2hpbGRyZW46IGpzeHMoXCJnXCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzAwMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMS41XCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMjYgQyAxNy41LDI0LjUgMzAsMjQuNSAzNiwyNiBMIDM4LjUsMTMuNSBMIDMxLDI1IEwgMzAuNywxMC45IEwgMjUuNSwyNC41IEwgMjIuNSwxMCBMIDE5LjUsMjQuNSBMIDE0LjMsMTAuOSBMIDE0LDI1IEwgNi41LDEzLjUgTCA5LDI2IHpcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsIGZpbGw6IFwiIzAwMDAwMFwiIH0gfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gOSwyNiBjIDAsMiAxLjUsMiAyLjUsNCAxLDEuNSAxLDEgMC41LDMuNSAtMS41LDEgLTEsMi41IC0xLDIuNSAtMS41LDEuNSAwLDIuNSAwLDIuNSA2LjUsMSAxNi41LDEgMjMsMCAwLDAgMS41LC0xIDAsLTIuNSAwLDAgMC41LC0xLjUgLTEsLTIuNSAtMC41LC0yLjUgLTAuNSwtMiAwLjUsLTMuNSAxLC0yIDIuNSwtMiAyLjUsLTQgLTguNSwtMS41IC0xOC41LC0xLjUgLTI3LDAgelwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLjUsMzAgQyAxNSwyOSAzMCwyOSAzMy41LDMwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIm0gMTIsMzMuNSBjIDYsLTEgMTUsLTEgMjEsMFwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCI2XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIxNFwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3goXCJjaXJjbGVcIiwgeyBjeDogXCIyMi41XCIsIGN5OiBcIjhcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjMxXCIsIGN5OiBcIjlcIiwgcjogXCIyXCIgfSksIGpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjM5XCIsIGN5OiBcIjEyXCIsIHI6IFwiMlwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDM4LjUgQSAzNSwzNSAxIDAgMCAzNCwzOC41XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIiB9IH0pLCBqc3hzKFwiZ1wiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwyOSBBIDM1LDM1IDEgMCAxIDM0LDI5XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIuNSwzMS41IEwgMzIuNSwzMS41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzNC41IEEgMzUsMzUgMSAwIDAgMzMuNSwzNC41XCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTAuNSwzNy41IEEgMzUsMzUgMSAwIDAgMzQuNSwzNy41XCIgfSldIH0pKV0gfSkpIH0pKSksXHJcbiAgICBiSzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgd2lkdGg6IFwiNDVcIiwgaGVpZ2h0OiBcIjQ1XCIgfSwgeyBjaGlsZHJlbjoganN4cyhcImdcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxLjVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiBcIjRcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDExLjYzIEwgMjIuNSw2XCIsIHN0eWxlOiB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiIzAwMDAwMFwiLCBzdHJva2VMaW5lam9pbjogXCJtaXRlclwiIH0sIGlkOiBcInBhdGg2NTcwXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjIuNSwyNSBDIDIyLjUsMjUgMjcsMTcuNSAyNS41LDE0LjUgQyAyNS41LDE0LjUgMjQuNSwxMiAyMi41LDEyIEMgMjAuNSwxMiAxOS41LDE0LjUgMTkuNSwxNC41IEMgMTgsMTcuNSAyMi41LDI1IDIyLjUsMjVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogXCIjMDAwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBcIjFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJidXR0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcIm1pdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDM3IEMgMTgsNDAuNSAyNyw0MC41IDMyLjUsMzcgTCAzMi41LDMwIEMgMzIuNSwzMCA0MS41LDI1LjUgMzguNSwxOS41IEMgMzQuNSwxMyAyNSwxNiAyMi41LDIzLjUgTCAyMi41LDI3IEwgMjIuNSwyMy41IEMgMjAsMTYgMTAuNSwxMyA2LjUsMTkuNSBDIDMuNSwyNS41IDEyLjUsMzAgMTIuNSwzMCBMIDEyLjUsMzdcIiwgc3R5bGU6IHsgZmlsbDogXCIjMDAwMDAwXCIsIHN0cm9rZTogXCIjMDAwMDAwXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMCw4IEwgMjUsOFwiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIiB9IH0pLCBqc3goXCJwYXRoXCIsIHsgZDogXCJNIDMyLDI5LjUgQyAzMiwyOS41IDQwLjUsMjUuNSAzOC4wMywxOS44NSBDIDM0LjE1LDE0IDI1LDE4IDIyLjUsMjQuNSBMIDIyLjUsMjYuNiBMIDIyLjUsMjQuNSBDIDIwLDE4IDEwLjg1LDE0IDYuOTcsMTkuODUgQyA0LjUsMjUuNSAxMywyOS41IDEzLDI5LjVcIiwgc3R5bGU6IHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCIjZmZmZmZmXCIgfSB9KSwganN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMCBNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjUgTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcIiNmZmZmZmZcIiB9IH0pXSB9KSkgfSkpKSxcclxufTtcblxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgY29vcmRpbmF0ZXMgYXQgdGhlIGNlbnRyZSBvZiB0aGUgcmVxdWVzdGVkIHNxdWFyZSwgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IG9mIHRoZSBib2FyZCAoMCwgMCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBzcXVhcmUpIHtcclxuICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfQ09MVU1OX1ZBTFVFUyA6IEJMQUNLX0NPTFVNTl9WQUxVRVM7XHJcbiAgICBjb25zdCByb3dzID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiID8gV0hJVEVfUk9XUyA6IEJMQUNLX1JPV1M7XHJcbiAgICBjb25zdCB4ID0gY29sdW1uc1tzcXVhcmVbMF1dICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICBjb25zdCB5ID0gcm93c1twYXJzZUludChzcXVhcmVbMV0sIDEwKSAtIDFdICogc3F1YXJlV2lkdGggKyBzcXVhcmVXaWR0aCAvIDI7XHJcbiAgICByZXR1cm4geyB4LCB5IH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcGFzc2VkIHBvc2l0aW9uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBzdGFydCBwb3NpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGlzRGlmZmVyZW50RnJvbVN0YXJ0KG5ld1Bvc2l0aW9uKSB7XHJcbiAgICBsZXQgaXNEaWZmZXJlbnQgPSBmYWxzZTtcclxuICAgIE9iamVjdC5rZXlzKFNUQVJUX1BPU0lUSU9OX09CSkVDVCkuZm9yRWFjaCgoc3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1Bvc2l0aW9uW3NxdWFyZV0gIT09IFNUQVJUX1BPU0lUSU9OX09CSkVDVFtzcXVhcmVdKVxyXG4gICAgICAgICAgICBpc0RpZmZlcmVudCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoU1RBUlRfUE9TSVRJT05fT0JKRUNUW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGlzRGlmZmVyZW50ID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzRGlmZmVyZW50O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoYXQgcGllY2VzIGhhdmUgYmVlbiBhZGRlZCBhbmQgd2hhdCBwaWVjZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYmV0d2VlbiBib2FyZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB7XHJcbiAgICAgICAgcmVtb3ZlZDoge30sXHJcbiAgICAgICAgYWRkZWQ6IHt9LFxyXG4gICAgfTtcclxuICAgIC8vIHJlbW92ZWQgZnJvbSBjdXJyZW50XHJcbiAgICBPYmplY3Qua2V5cyhjdXJyZW50UG9zaXRpb24pLmZvckVhY2goKHNxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmIChuZXdQb3NpdGlvbltzcXVhcmVdICE9PSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSlcclxuICAgICAgICAgICAgZGlmZmVyZW5jZS5yZW1vdmVkW3NxdWFyZV0gPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgIH0pO1xyXG4gICAgLy8gYWRkZWQgZnJvbSBuZXdcclxuICAgIE9iamVjdC5rZXlzKG5ld1Bvc2l0aW9uKS5mb3JFYWNoKChzcXVhcmUpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uW3NxdWFyZV0gIT09IG5ld1Bvc2l0aW9uW3NxdWFyZV0pXHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UuYWRkZWRbc3F1YXJlXSA9IG5ld1Bvc2l0aW9uW3NxdWFyZV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGZlbiBzdHJpbmcgb3IgZXhpc3RpbmcgcG9zaXRpb24gb2JqZWN0IHRvIGEgcG9zaXRpb24gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pIHtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFNUQVJUX1BPU0lUSU9OX09CSkVDVDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAvLyBhdHRlbXB0IHRvIGNvbnZlcnQgZmVuIHRvIHBvc2l0aW9uIG9iamVjdFxyXG4gICAgICAgIHJldHVybiBmZW5Ub09iaihwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZmVuIHN0cmluZyB0byBhIHBvc2l0aW9uIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvT2JqKGZlbikge1xyXG4gICAgaWYgKCFpc1ZhbGlkRmVuKGZlbikpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgLy8gY3V0IG9mZiBhbnkgbW92ZSwgY2FzdGxpbmcsIGV0YyBpbmZvIGZyb20gdGhlIGVuZC4gd2UncmUgb25seSBpbnRlcmVzdGVkIGluIHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICBmZW4gPSBmZW4ucmVwbGFjZSgvIC4rJC8sIFwiXCIpO1xyXG4gICAgY29uc3Qgcm93cyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xyXG4gICAgbGV0IGN1cnJlbnRSb3cgPSA4O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcclxuICAgICAgICBjb25zdCByb3cgPSByb3dzW2ldLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgIGxldCBjb2xJZHggPSAwO1xyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBpbiB0aGUgRkVOIHNlY3Rpb25cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAvLyBudW1iZXIgLyBlbXB0eSBzcXVhcmVzXHJcbiAgICAgICAgICAgIGlmIChyb3dbal0uc2VhcmNoKC9bMS04XS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbnVtRW1wdHlTcXVhcmVzID0gcGFyc2VJbnQocm93W2pdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBjb2xJZHggPSBjb2xJZHggKyBudW1FbXB0eVNxdWFyZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwaWVjZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gQ09MVU1OU1tjb2xJZHhdICsgY3VycmVudFJvdztcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uW3NxdWFyZV0gPSBmZW5Ub1BpZWNlQ29kZShyb3dbal0pO1xyXG4gICAgICAgICAgICAgICAgY29sSWR4ID0gY29sSWR4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Um93ID0gY3VycmVudFJvdyAtIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBzdHJpbmcgaXMgdmFsaWQgZmVuIG5vdGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZEZlbihmZW4pIHtcclxuICAgIC8vIGN1dCBvZmYgYW55IG1vdmUsIGNhc3RsaW5nLCBldGMgaW5mbyBmcm9tIHRoZSBlbmQuIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgZmVuID0gZmVuLnJlcGxhY2UoLyAuKyQvLCBcIlwiKTtcclxuICAgIC8vIGV4cGFuZCB0aGUgZW1wdHkgc3F1YXJlIG51bWJlcnMgdG8ganVzdCAxc1xyXG4gICAgZmVuID0gZXhwYW5kRmVuRW1wdHlTcXVhcmVzKGZlbik7XHJcbiAgICAvLyBmZW4gc2hvdWxkIGJlIDggc2VjdGlvbnMgc2VwYXJhdGVkIGJ5IHNsYXNoZXNcclxuICAgIGNvbnN0IGNodW5rcyA9IGZlbi5zcGxpdChcIi9cIik7XHJcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAhPT0gOClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBjaGVjayBlYWNoIHNlY3Rpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNodW5rc1tpXS5sZW5ndGggIT09IDggfHwgY2h1bmtzW2ldLnNlYXJjaCgvW15rcXJuYnBLUVJOQlAxXS8pICE9PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEV4cGFuZCBvdXQgZmVuIG5vdGF0aW9uIHRvIGNvdW50YWJsZSBjaGFyYWN0ZXJzIGZvciB2YWxpZGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBleHBhbmRGZW5FbXB0eVNxdWFyZXMoZmVuKSB7XHJcbiAgICByZXR1cm4gZmVuXHJcbiAgICAgICAgLnJlcGxhY2UoLzgvZywgXCIxMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC83L2csIFwiMTExMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC82L2csIFwiMTExMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzUvZywgXCIxMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC80L2csIFwiMTExMVwiKVxyXG4gICAgICAgIC5yZXBsYWNlKC8zL2csIFwiMTExXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoLzIvZywgXCIxMVwiKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBmZW4gcGllY2UgY29kZSB0byBjYW1lbCBjYXNlIG5vdGF0aW9uLiBlLmcuIGJQLCB3Sy5cclxuICovXHJcbmZ1bmN0aW9uIGZlblRvUGllY2VDb2RlKHBpZWNlKSB7XHJcbiAgICAvLyBibGFjayBwaWVjZVxyXG4gICAgaWYgKHBpZWNlLnRvTG93ZXJDYXNlKCkgPT09IHBpZWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIChcImJcIiArIHBpZWNlLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgLy8gd2hpdGUgcGllY2VcclxuICAgIHJldHVybiAoXCJ3XCIgKyBwaWVjZS50b1VwcGVyQ2FzZSgpKTtcclxufVxuXG5jb25zdCB1c2VBcnJvd3MgPSAoY3VzdG9tQXJyb3dzLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgb25BcnJvd3NDaGFuZ2UsIGN1c3RvbUFycm93Q29sb3IpID0+IHtcclxuICAgIC8vIGFycm93cyBwYXNzZWQgcHJvZ3JhbWF0aWNhbGx5IHRvIGBDaGVzc0JvYXJkYCBhcyBhIHJlYWN0IHByb3BcclxuICAgIGNvbnN0IFtjdXN0b21BcnJvd3NTZXQsIHNldEN1c3RvbUFycm93c10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgICAvLyBhcnJvd3MgZHJhd24gd2l0aCBtb3VzZSBieSB1c2VyIG9uIHRoZSBib2FyZFxyXG4gICAgY29uc3QgW2Fycm93cywgc2V0QXJyb3dzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIGFjdGl2ZSBhcnJvdyB3aGljaCB1c2VyIGRyYXdzIHdoaWxlIGRyYWdnaW5nIG1vdXNlXHJcbiAgICBjb25zdCBbbmV3QXJyb3csIHNldE5ld0Fycm93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBoYW5kbGUgZXh0ZXJuYWwgYGN1c3RvbUFycm93c2AgcHJvcHMgY2hhbmdlc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21BcnJvd3MpKSB7XHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgY3VzdG9tIGFycm93cyBvdmVyd3JpdGUgdGVtcG9yYXJ5IGFycm93c1xyXG4gICAgICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgICAgICBzZXRDdXN0b21BcnJvd3MoXHJcbiAgICAgICAgICAgIC8vZmlsdGVyIG91dCBhcnJvd3Mgd2hpY2ggc3RhcnRzIGFuZCBlbmRzIGluIHRoZSBzYW1lIHNxdWFyZVxyXG4gICAgICAgICAgICBjdXN0b21BcnJvd3MgPT09IG51bGwgfHwgY3VzdG9tQXJyb3dzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21BcnJvd3MuZmlsdGVyKChhcnJvdykgPT4gYXJyb3dbMF0gIT09IGFycm93WzFdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1c3RvbUFycm93c10pO1xyXG4gICAgLy8gY2FsbGJhY2sgd2hlbiBhcnJvd3MgY2hhbmdlZCBhZnRlciB1c2VyIGludGVyYWN0aW9uXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIG9uQXJyb3dzQ2hhbmdlID09PSBudWxsIHx8IG9uQXJyb3dzQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkFycm93c0NoYW5nZShhcnJvd3MpO1xyXG4gICAgfSwgW2Fycm93c10pO1xyXG4gICAgLy8gZnVuY3Rpb24gY2xlYXJzIGFsbCBhcnJvd3MgZHJhd2VkIGJ5IHVzZXJcclxuICAgIGZ1bmN0aW9uIGNsZWFyQXJyb3dzKCkge1xyXG4gICAgICAgIHNldEFycm93cyhbXSk7XHJcbiAgICAgICAgc2V0TmV3QXJyb3codW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRyYXdOZXdBcnJvdyA9IChmcm9tU3F1YXJlLCB0b1NxdWFyZSkgPT4ge1xyXG4gICAgICAgIGlmICghYXJlQXJyb3dzQWxsb3dlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHNldE5ld0Fycm93KFtmcm9tU3F1YXJlLCB0b1NxdWFyZSwgY3VzdG9tQXJyb3dDb2xvcl0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGFsbEJvYXJkQXJyb3dzID0gWy4uLmFycm93cywgLi4uY3VzdG9tQXJyb3dzU2V0XTtcclxuICAgIGNvbnN0IG9uQXJyb3dEcmF3RW5kID0gKGZyb21TcXVhcmUsIHRvU3F1YXJlKSA9PiB7XHJcbiAgICAgICAgaWYgKGZyb21TcXVhcmUgPT09IHRvU3F1YXJlIHx8ICFhcmVBcnJvd3NBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGFycm93c0NvcHk7XHJcbiAgICAgICAgY29uc3QgbmV3QXJyb3cgPSBbZnJvbVNxdWFyZSwgdG9TcXVhcmUsIGN1c3RvbUFycm93Q29sb3JdO1xyXG4gICAgICAgIGNvbnN0IGlzTmV3QXJyb3dVbmlxdWUgPSBhbGxCb2FyZEFycm93cy5ldmVyeSgoW2Fycm93RnJvbSwgYXJyb3dUb10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBhZGQgdGhlIG5ld0Fycm93IHRvIGFycm93cyBhcnJheSBpZiBpdCBpcyB1bmlxdWVcclxuICAgICAgICBpZiAoaXNOZXdBcnJvd1VuaXF1ZSkge1xyXG4gICAgICAgICAgICBhcnJvd3NDb3B5ID0gWy4uLmFycm93cywgbmV3QXJyb3ddO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgYm9hcmQgaWYgd2UgYWxyZWFkeSBoYXZlIHNhbWUgYXJyb3cgaW4gYXJyb3dzIGFycmF5XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFycm93c0NvcHkgPSBhcnJvd3MuZmlsdGVyKChbYXJyb3dGcm9tLCBhcnJvd1RvXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoYXJyb3dGcm9tID09PSBmcm9tU3F1YXJlICYmIGFycm93VG8gPT09IHRvU3F1YXJlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE5ld0Fycm93KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc2V0QXJyb3dzKGFycm93c0NvcHkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXJyb3dzOiBhbGxCb2FyZEFycm93cyxcclxuICAgICAgICBuZXdBcnJvdyxcclxuICAgICAgICBjbGVhckFycm93cyxcclxuICAgICAgICBkcmF3TmV3QXJyb3csXHJcbiAgICAgICAgc2V0QXJyb3dzLFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgfTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcclxuY29uc3QgdXNlQ2hlc3Nib2FyZCA9ICgpID0+IHVzZUNvbnRleHQoQ2hlc3Nib2FyZENvbnRleHQpO1xyXG5jb25zdCBDaGVzc2JvYXJkUHJvdmlkZXIgPSBmb3J3YXJkUmVmKCh7IGFsbG93RHJhZ091dHNpZGVCb2FyZCA9IHRydWUsIGFuaW1hdGlvbkR1cmF0aW9uID0gMzAwLCBhcmVBcnJvd3NBbGxvd2VkID0gdHJ1ZSwgYXJlUGllY2VzRHJhZ2dhYmxlID0gdHJ1ZSwgYXJlUHJlbW92ZXNBbGxvd2VkID0gZmFsc2UsIGF1dG9Qcm9tb3RlVG9RdWVlbiA9IGZhbHNlLCBib2FyZE9yaWVudGF0aW9uID0gXCJ3aGl0ZVwiLCBib2FyZFdpZHRoLCBjaGlsZHJlbiwgY2xlYXJQcmVtb3Zlc09uUmlnaHRDbGljayA9IHRydWUsIGN1c3RvbUFycm93cywgY3VzdG9tQXJyb3dDb2xvciA9IFwicmdiKDI1NSwxNzAsMClcIiwgY3VzdG9tQm9hcmRTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgY3VzdG9tRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0I1ODg2M1wiIH0sIGN1c3RvbURyb3BTcXVhcmVTdHlsZSA9IHtcclxuICAgIGJveFNoYWRvdzogXCJpbnNldCAwIDAgMXB4IDZweCByZ2JhKDI1NSwyNTUsMjU1LDAuNzUpXCIsXHJcbn0sIGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUgPSB7IGJhY2tncm91bmRDb2xvcjogXCIjRjBEOUI1XCIgfSwgY3VzdG9tUGllY2VzLCBjdXN0b21QcmVtb3ZlRGFya1NxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0E0MjMyM1wiIH0sIGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlID0geyBiYWNrZ3JvdW5kQ29sb3I6IFwiI0JEMjgyOFwiIH0sIGN1c3RvbVNxdWFyZSA9IFwiZGl2XCIsIGN1c3RvbVNxdWFyZVN0eWxlcywgZHJvcE9mZkJvYXJkQWN0aW9uID0gXCJzbmFwYmFja1wiLCBpZCA9IDAsIGlzRHJhZ2dhYmxlUGllY2UgPSAoKSA9PiB0cnVlLCBnZXRQb3NpdGlvbk9iamVjdCA9ICgpID0+IHsgfSwgb25BcnJvd3NDaGFuZ2UgPSAoKSA9PiB7IH0sIG9uRHJhZ092ZXJTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdXRTcXVhcmUgPSAoKSA9PiB7IH0sIG9uTW91c2VPdmVyU3F1YXJlID0gKCkgPT4geyB9LCBvblBpZWNlQ2xpY2sgPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnQmVnaW4gPSAoKSA9PiB7IH0sIG9uUGllY2VEcmFnRW5kID0gKCkgPT4geyB9LCBvblBpZWNlRHJvcCA9ICgpID0+IHRydWUsIG9uUGllY2VEcm9wT2ZmQm9hcmQgPSAoKSA9PiB7IH0sIG9uUHJvbW90aW9uQ2hlY2sgPSAoc291cmNlU3F1YXJlLCB0YXJnZXRTcXVhcmUsIHBpZWNlKSA9PiB7XHJcbiAgICByZXR1cm4gKCgocGllY2UgPT09IFwid1BcIiAmJlxyXG4gICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCI3XCIgJiZcclxuICAgICAgICB0YXJnZXRTcXVhcmVbMV0gPT09IFwiOFwiKSB8fFxyXG4gICAgICAgIChwaWVjZSA9PT0gXCJiUFwiICYmXHJcbiAgICAgICAgICAgIHNvdXJjZVNxdWFyZVsxXSA9PT0gXCIyXCIgJiZcclxuICAgICAgICAgICAgdGFyZ2V0U3F1YXJlWzFdID09PSBcIjFcIikpICYmXHJcbiAgICAgICAgTWF0aC5hYnMoc291cmNlU3F1YXJlLmNoYXJDb2RlQXQoMCkgLSB0YXJnZXRTcXVhcmUuY2hhckNvZGVBdCgwKSkgPD0gMSk7XHJcbn0sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPSAoKSA9PiB0cnVlLCBvblNwYXJlUGllY2VEcm9wID0gKCkgPT4gdHJ1ZSwgb25TcXVhcmVDbGljayA9ICgpID0+IHsgfSwgb25TcXVhcmVSaWdodENsaWNrID0gKCkgPT4geyB9LCBwb3NpdGlvbiA9IFwic3RhcnRcIiwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9IFwiZGVmYXVsdFwiLCBwcm9tb3Rpb25Ub1NxdWFyZSA9IG51bGwsIHNob3dCb2FyZE5vdGF0aW9uID0gdHJ1ZSwgc2hvd1Byb21vdGlvbkRpYWxvZyA9IGZhbHNlLCBzbmFwVG9DdXJzb3IgPSB0cnVlLCB9LCByZWYpID0+IHtcclxuICAgIC8vIHBvc2l0aW9uIHN0b3JlZCBhbmQgZGlzcGxheWVkIG9uIGJvYXJkXHJcbiAgICBjb25zdCBbY3VycmVudFBvc2l0aW9uLCBzZXRDdXJyZW50UG9zaXRpb25dID0gdXNlU3RhdGUoY29udmVydFBvc2l0aW9uVG9PYmplY3QocG9zaXRpb24pKTtcclxuICAgIC8vIGNhbGN1bGF0ZWQgZGlmZmVyZW5jZXMgYmV0d2VlbiBjdXJyZW50IGFuZCBpbmNvbWluZyBwb3NpdGlvbnNcclxuICAgIGNvbnN0IFtwb3NpdGlvbkRpZmZlcmVuY2VzLCBzZXRQb3NpdGlvbkRpZmZlcmVuY2VzXSA9IHVzZVN0YXRlKHsgcmVtb3ZlZDoge30sIGFkZGVkOiB7fSB9KTtcclxuICAgIC8vIGNvbG91ciBvZiBsYXN0IHBpZWNlIG1vdmVkIHRvIGRldGVybWluZSBpZiBwcmVtb3ZpbmdcclxuICAgIGNvbnN0IFtsYXN0UGllY2VDb2xvdXIsIHNldExhc3RQaWVjZUNvbG91cl0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgLy8gc2hvdyAvIGhpZGUgcHJvbW90aW9uIGRpYWxvZ1xyXG4gICAgY29uc3QgW3Nob3dQcm9tb3RlRGlhbG9nLCBzZXRTaG93UHJvbW90ZURpYWxvZ10gPSB1c2VTdGF0ZShzaG93UHJvbW90aW9uRGlhbG9nICYmICFhdXRvUHJvbW90ZVRvUXVlZW4pO1xyXG4gICAgLy8gd2hpY2ggc3F1YXJlIGEgcGF3biBpcyBiZWluZyBwcm9tb3RlZCB0b1xyXG4gICAgY29uc3QgW3Byb21vdGVGcm9tU3F1YXJlLCBzZXRQcm9tb3RlRnJvbVNxdWFyZV0gPSB1c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtwcm9tb3RlVG9TcXVhcmUsIHNldFByb21vdGVUb1NxdWFyZV0gPSB1c2VTdGF0ZShwcm9tb3Rpb25Ub1NxdWFyZSk7XHJcbiAgICAvLyBjdXJyZW50IHByZW1vdmVzXHJcbiAgICBjb25zdCBbcHJlbW92ZXMsIHNldFByZW1vdmVzXSA9IHVzZVN0YXRlKFtdKTtcclxuICAgIC8vIHJlZiB1c2VkIHRvIGFjY2VzcyBjdXJyZW50IHZhbHVlIGR1cmluZyB0aW1lb3V0cyAoY2xvc3VyZXMpXHJcbiAgICBjb25zdCBwcmVtb3Zlc1JlZiA9IHVzZVJlZihwcmVtb3Zlcyk7XHJcbiAgICAvLyBjdXJyZW50IHJpZ2h0IG1vdXNlIGRvd24gc3F1YXJlXHJcbiAgICBjb25zdCBbY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd25dID0gdXNlU3RhdGUoKTtcclxuICAgIC8vIGNoZXNzIHBpZWNlcy9zdHlsaW5nXHJcbiAgICBjb25zdCBbY2hlc3NQaWVjZXMsIHNldENoZXNzUGllY2VzXSA9IHVzZVN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBpZWNlcyksIGN1c3RvbVBpZWNlcykpO1xyXG4gICAgLy8gd2hldGhlciB0aGUgbGFzdCBtb3ZlIHdhcyBhIG1hbnVhbCBkcm9wIG9yIG5vdFxyXG4gICAgY29uc3QgW3dhc01hbnVhbERyb3AsIHNldFdhc01hbnVhbERyb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgLy8gdGhlIG1vc3QgcmVjZW50IHRpbWVvdXQgd2hpbHN0IHdhaXRpbmcgZm9yIGFuaW1hdGlvbiB0byBjb21wbGV0ZVxyXG4gICAgY29uc3QgW3ByZXZpb3VzVGltZW91dCwgc2V0UHJldmlvdXNUaW1lb3V0XSA9IHVzZVN0YXRlKCk7XHJcbiAgICAvLyBpZiBjdXJyZW50bHkgd2FpdGluZyBmb3IgYW4gYW5pbWF0aW9uIHRvIGZpbmlzaFxyXG4gICAgY29uc3QgW2lzV2FpdGluZ0ZvckFuaW1hdGlvbiwgc2V0SXNXYWl0aW5nRm9yQW5pbWF0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vIGxhc3Qgc3F1YXJlIGRyYWdnZWQgb3ZlciBmb3IgY2hlY2tpbmcgaW4gdG91Y2ggZXZlbnRzXHJcbiAgICBjb25zdCBbbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXJdID0gdXNlU3RhdGUobnVsbCk7XHJcbiAgICAvLyBvcGVuIGNsZWFyUHJlbW92ZXMoKSB0byBhbGxvdyB1c2VyIHRvIGNhbGwgb24gdW5kby9yZXNldC93aGVuZXZlclxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+ICh7XHJcbiAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91cik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pKTtcclxuICAgIC8vIGhhbmRsZSBjdXN0b20gcGllY2VzIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRDaGVzc1BpZWNlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQaWVjZXMpLCBjdXN0b21QaWVjZXMpKTtcclxuICAgIH0sIFtjdXN0b21QaWVjZXNdKTtcclxuICAgIC8vIGhhbmRsZSBwcm9tb3RlIGNoYW5nZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coc2hvd1Byb21vdGlvbkRpYWxvZyk7XHJcbiAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHByb21vdGlvblRvU3F1YXJlKTtcclxuICAgIH0sIFtwcm9tb3Rpb25Ub1NxdWFyZSwgc2hvd1Byb21vdGlvbkRpYWxvZ10pO1xyXG4gICAgLy8gaGFuZGxlIGV4dGVybmFsIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAvLyBjbGVhciBhbnkgb3BlbiBwcm9tb3Rpb24gZGlhbG9nc1xyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBjb252ZXJ0UG9zaXRpb25Ub09iamVjdChwb3NpdGlvbik7XHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZXMgPSBnZXRQb3NpdGlvbkRpZmZlcmVuY2VzKGN1cnJlbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24pO1xyXG4gICAgICAgIGNvbnN0IG5ld1BpZWNlQ29sb3VyID0gKChfYSA9IE9iamVjdC5rZXlzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPD0gMlxyXG4gICAgICAgICAgICA/IChfYyA9IChfYiA9IE9iamVjdC5lbnRyaWVzKGRpZmZlcmVuY2VzLmFkZGVkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMV1bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gZXh0ZXJuYWwgbW92ZSBoYXMgY29tZSBpbiBiZWZvcmUgYW5pbWF0aW9uIGlzIG92ZXJcclxuICAgICAgICAvLyBjYW5jZWwgYW5pbWF0aW9uIGFuZCBpbW1lZGlhdGVseSB1cGRhdGUgcG9zaXRpb25cclxuICAgICAgICBpZiAoaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHNldElzV2FpdGluZ0ZvckFuaW1hdGlvbihmYWxzZSk7XHJcbiAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHdhcyBtYWRlIHVzaW5nIGRyYWcgYW5kIGRyb3BcclxuICAgICAgICAgICAgaWYgKHdhc01hbnVhbERyb3ApIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkICYmIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgd2FzIG1hZGUgYnkgZXh0ZXJuYWwgcG9zaXRpb24gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBwb3NpdGlvbiA9PT0gc3RhcnQgdGhlbiBkb24ndCBvdmVycmlkZSBuZXdQaWVjZUNvbG91clxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgaXNEaWZmZXJlbnRGcm9tU3RhcnQgaW4gc2NlbmFyaW8gd2hlcmUgcHJlbW92ZXMgaGF2ZSBiZWVuIGNsZWFyZWQgdXBvbiBib2FyZCByZXNldCBidXQgZmlyc3QgbW92ZSBpcyBtYWRlIGJ5IGNvbXB1dGVyLCB0aGUgbGFzdCBtb3ZlIGNvbG91ciB3b3VsZCBuZWVkIHRvIGJlIHVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0RpZmZlcmVudEZyb21TdGFydChuZXdQb3NpdGlvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UGllY2VDb2xvdXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaWZmZXJlbnRGcm9tU3RhcnQobmV3UG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb24gPT09IHN0YXJ0LCBsaWtlbHkgYSBib2FyZCByZXNldC4gc2V0IHRvIGJsYWNrIHRvIGFsbG93IGJsYWNrIHRvIG1ha2UgcHJlbW92ZXMgb24gZmlyc3QgbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RQaWVjZUNvbG91cihcImJcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uRGlmZmVyZW5jZXMoZGlmZmVyZW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSBleHRlcm5hbCBtb3ZlXHJcbiAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJc1dhaXRpbmdGb3JBbmltYXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZVByZW1vdmVzQWxsb3dlZCAmJiBhdHRlbXB0UHJlbW92ZShuZXdQaWVjZUNvbG91cik7XHJcbiAgICAgICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c1RpbWVvdXQobmV3VGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXQgbWFudWFsIGRyb3AsIHJlYWR5IGZvciBuZXh0IG1vdmUgdG8gYmUgbWFkZSBieSB1c2VyIG9yIGV4dGVybmFsXHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcChmYWxzZSk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld1Bvc2l0aW9uKTtcclxuICAgICAgICAvLyBjbGVhciBhcnJvd3NcclxuICAgICAgICBjbGVhckFycm93cygpO1xyXG4gICAgICAgIC8vIGNsZWFyIHRpbWVvdXQgb24gdW5tb3VudFxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChwcmV2aW91c1RpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcG9zaXRpb25dKTtcclxuICAgIGNvbnN0IHsgYXJyb3dzLCBuZXdBcnJvdywgY2xlYXJBcnJvd3MsIGRyYXdOZXdBcnJvdywgb25BcnJvd0RyYXdFbmQgfSA9IHVzZUFycm93cyhjdXN0b21BcnJvd3MsIGFyZUFycm93c0FsbG93ZWQsIG9uQXJyb3dzQ2hhbmdlLCBjdXN0b21BcnJvd0NvbG9yKTtcclxuICAgIC8vIGhhbmRsZSBkcm9wIHBvc2l0aW9uIGNoYW5nZVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU2V0UG9zaXRpb24oc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSwgd2FzTWFudWFsRHJvcE92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gaWYgZHJvcHBlZCBiYWNrIGRvd24sIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICAgICAgaWYgKHNvdXJjZVNxID09PSB0YXJnZXRTcSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyQXJyb3dzKCk7XHJcbiAgICAgICAgLy8gaWYgc2Vjb25kIG1vdmUgaXMgbWFkZSBmb3Igc2FtZSBjb2xvdXIsIG9yIHRoZXJlIGFyZSBzdGlsbCBwcmVtb3ZlcyBxdWV1ZWQsIHRoZW4gdGhpcyBtb3ZlIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHByZW1vdmUgcXVldWUgaW5zdGVhZCBvZiBwbGF5ZWRcclxuICAgICAgICAvLyBwcmVtb3ZlcyBsZW5ndGggY2hlY2sgZm9yIGNvbG91ciBpcyBhZGRlZCBpbiBiZWNhdXNlIHdoaXRlIGNvdWxkIG1ha2UgMyBwcmVtb3ZlcywgYW5kIHRoZW4gYmxhY2sgcmVzcG9uZHMgdG8gdGhlIGZpcnN0IG1vdmUgKGNoYW5naW5nIHRoZSBsYXN0IHBpZWNlIGNvbG91cikgYW5kIHRoZW4gd2hpdGUgcHJlLW1vdmVzIGFnYWluXHJcbiAgICAgICAgaWYgKChhcmVQcmVtb3Zlc0FsbG93ZWQgJiYgaXNXYWl0aW5nRm9yQW5pbWF0aW9uKSB8fFxyXG4gICAgICAgICAgICAoYXJlUHJlbW92ZXNBbGxvd2VkICYmXHJcbiAgICAgICAgICAgICAgICAobGFzdFBpZWNlQ29sb3VyID09PSBwaWVjZVswXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQuZmlsdGVyKChwKSA9PiBwLnBpZWNlWzBdID09PSBwaWVjZVswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCA+IDApKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRQcmVtb3ZlcyA9IFsuLi5wcmVtb3Zlc1JlZi5jdXJyZW50XTtcclxuICAgICAgICAgICAgb2xkUHJlbW92ZXMucHVzaCh7IHNvdXJjZVNxLCB0YXJnZXRTcSwgcGllY2UgfSk7XHJcbiAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgc2V0UHJlbW92ZXMoWy4uLm9sZFByZW1vdmVzXSk7XHJcbiAgICAgICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdHJhbnNpdGlvbmluZywgZG9uJ3QgYWxsb3cgbmV3IGRyb3BcclxuICAgICAgICBpZiAoIWFyZVByZW1vdmVzQWxsb3dlZCAmJiBpc1dhaXRpbmdGb3JBbmltYXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBuZXdPbkRyb3BQb3NpdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgc2V0V2FzTWFudWFsRHJvcCghIXdhc01hbnVhbERyb3BPdmVycmlkZSk7XHJcbiAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHBpZWNlWzBdKTtcclxuICAgICAgICAvLyBpZiBvblBpZWNlRHJvcCBmdW5jdGlvbiBwcm92aWRlZCwgZXhlY3V0ZSBpdCwgcG9zaXRpb24gbXVzdCBiZSB1cGRhdGVkIGV4dGVybmFsbHkgYW5kIGNhcHR1cmVkIGJ5IHVzZUVmZmVjdCBhYm92ZSBmb3IgdGhpcyBtb3ZlIHRvIHNob3cgb24gYm9hcmRcclxuICAgICAgICBpZiAob25QaWVjZURyb3AubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRNb3ZlID0gb25QaWVjZURyb3Aoc291cmNlU3EsIHRhcmdldFNxLCBwaWVjZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyUHJlbW92ZXMoKTtcclxuICAgICAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgc291cmNlIHBpZWNlXHJcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdPbkRyb3BQb3NpdGlvbltzb3VyY2VTcV07XHJcbiAgICAgICAgICAgIC8vIGFkZCBwaWVjZSBpbiBuZXcgcG9zaXRpb25cclxuICAgICAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdPbkRyb3BQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyUHJvbW90aW9uKCk7XHJcbiAgICAgICAgLy8gaW5mb3JtIGxhdGVzdCBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgIGdldFBvc2l0aW9uT2JqZWN0KG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UG9zaXRpb24pO1xyXG4gICAgICAgIGRlbGV0ZSBwb3NpdGlvbkNvcHlbc3F1YXJlXTtcclxuICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24ocG9zaXRpb25Db3B5KTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QocG9zaXRpb25Db3B5KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0dGVtcHRQcmVtb3ZlKG5ld1BpZWNlQ29sb3VyKSB7XHJcbiAgICAgICAgaWYgKHByZW1vdmVzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gZ2V0IGN1cnJlbnQgdmFsdWUgb2YgcHJlbW92ZSBhcyB0aGlzIGlzIGNhbGxlZCBpbiBhIHRpbWVvdXQgc28gdmFsdWUgbWF5IGhhdmUgY2hhbmdlZCBzaW5jZSB0aW1lb3V0IHdhcyBzZXRcclxuICAgICAgICBjb25zdCBwcmVtb3ZlID0gcHJlbW92ZXNSZWYuY3VycmVudFswXTtcclxuICAgICAgICAvLyBpZiBwcmVtb3ZlIGlzIGEgZGlmZmVyaW5nIGNvbG91ciB0byBsYXN0IG1vdmUgbWFkZSwgdGhlbiB0aGlzIG1vdmUgY2FuIGJlIG1hZGVcclxuICAgICAgICBpZiAocHJlbW92ZS5waWVjZVswXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHByZW1vdmUucGllY2VbMF0gIT09IG5ld1BpZWNlQ29sb3VyICYmXHJcbiAgICAgICAgICAgIG9uUGllY2VEcm9wLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZXRMYXN0UGllY2VDb2xvdXIocHJlbW92ZS5waWVjZVswXSk7XHJcbiAgICAgICAgICAgIHNldFdhc01hbnVhbERyb3AodHJ1ZSk7IC8vIHByZS1tb3ZlIGRvZXNuJ3QgbmVlZCBhbmltYXRpb25cclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZE1vdmUgPSBvblBpZWNlRHJvcChwcmVtb3ZlLnNvdXJjZVNxLCBwcmVtb3ZlLnRhcmdldFNxLCBwcmVtb3ZlLnBpZWNlKTtcclxuICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgY2FuIGJlIHJlbW92ZWQgZnJvbSBxdWV1ZVxyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFByZW1vdmVzID0gWy4uLnByZW1vdmVzUmVmLmN1cnJlbnRdO1xyXG4gICAgICAgICAgICAgICAgb2xkUHJlbW92ZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHByZW1vdmVzUmVmLmN1cnJlbnQgPSBvbGRQcmVtb3ZlcztcclxuICAgICAgICAgICAgICAgIHNldFByZW1vdmVzKFsuLi5vbGRQcmVtb3Zlc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlbW92ZSB3YXNuJ3Qgc3VjY2Vzc2Z1bCwgY2xlYXIgcHJlbW92ZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgY2xlYXJQcmVtb3ZlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3BhcmVQaWVjZURyb3AocGllY2UsIHRhcmdldFNxKSB7XHJcbiAgICAgICAgY29uc3QgaXNWYWxpZERyb3AgPSBvblNwYXJlUGllY2VEcm9wKHBpZWNlLCB0YXJnZXRTcSk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkRHJvcClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG5ld09uRHJvcFBvc2l0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBhZGQgcGllY2UgaW4gbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgbmV3T25Ecm9wUG9zaXRpb25bdGFyZ2V0U3FdID0gcGllY2U7XHJcbiAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld09uRHJvcFBvc2l0aW9uKTtcclxuICAgICAgICAvLyBpbmZvcm0gbGF0ZXN0IHBvc2l0aW9uIGluZm9ybWF0aW9uXHJcbiAgICAgICAgZ2V0UG9zaXRpb25PYmplY3QobmV3T25Ecm9wUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJQcmVtb3ZlcyhjbGVhckxhc3RQaWVjZUNvbG91ciA9IHRydWUpIHtcclxuICAgICAgICAvLyBkb24ndCBjbGVhciB3aGVuIHJpZ2h0IGNsaWNraW5nIHRvIGNsZWFyLCBvdGhlcndpc2UgeW91IHdvbid0IGJlIGFibGUgdG8gcHJlbW92ZSBhZ2FpbiBiZWZvcmUgbmV4dCBnb1xyXG4gICAgICAgIGlmIChjbGVhckxhc3RQaWVjZUNvbG91cilcclxuICAgICAgICAgICAgc2V0TGFzdFBpZWNlQ29sb3VyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcHJlbW92ZXNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICAgIHNldFByZW1vdmVzKFtdKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyUHJvbW90aW9uKCkge1xyXG4gICAgICAgIHNldFByb21vdGVGcm9tU3F1YXJlKG51bGwpO1xyXG4gICAgICAgIHNldFByb21vdGVUb1NxdWFyZShudWxsKTtcclxuICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bihzcXVhcmUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25SaWdodENsaWNrVXAoc3F1YXJlKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRSaWdodENsaWNrRG93bikge1xyXG4gICAgICAgICAgICAvLyBzYW1lIHNxdWFyZSwgZG9uJ3QgZHJhdyBhbiBhcnJvdywgYnV0IGRvIGNsZWFyIHByZW1vdmVzIGFuZCBydW4gb25TcXVhcmVSaWdodENsaWNrXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24gPT09IHNxdWFyZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFJpZ2h0Q2xpY2tEb3duKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclByZW1vdmVzT25SaWdodENsaWNrICYmIGNsZWFyUHJlbW92ZXMoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgb25TcXVhcmVSaWdodENsaWNrKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzZXRDdXJyZW50UmlnaHRDbGlja0Rvd24odW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duKCkge1xyXG4gICAgICAgIHNldEN1cnJlbnRSaWdodENsaWNrRG93bih1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgQ2hlc3Nib2FyZFByb3ZpZGVyQ29udGV4dFZhbHVlID0ge1xyXG4gICAgICAgIGFsbG93RHJhZ091dHNpZGVCb2FyZCxcclxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbixcclxuICAgICAgICBhcmVQaWVjZXNEcmFnZ2FibGUsXHJcbiAgICAgICAgYXJlUHJlbW92ZXNBbGxvd2VkLFxyXG4gICAgICAgIGFycm93cyxcclxuICAgICAgICBhdXRvUHJvbW90ZVRvUXVlZW4sXHJcbiAgICAgICAgYm9hcmRPcmllbnRhdGlvbixcclxuICAgICAgICBib2FyZFdpZHRoLFxyXG4gICAgICAgIGNoZXNzUGllY2VzLFxyXG4gICAgICAgIGNsZWFyQXJyb3dzLFxyXG4gICAgICAgIGNsZWFyQ3VycmVudFJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBjdXJyZW50UmlnaHRDbGlja0Rvd24sXHJcbiAgICAgICAgY3VzdG9tQXJyb3dDb2xvcixcclxuICAgICAgICBjdXN0b21Cb2FyZFN0eWxlLFxyXG4gICAgICAgIGN1c3RvbURhcmtTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ecm9wU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSxcclxuICAgICAgICBjdXN0b21Ob3RhdGlvblN0eWxlLFxyXG4gICAgICAgIGN1c3RvbVByZW1vdmVEYXJrU3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsXHJcbiAgICAgICAgY3VzdG9tU3F1YXJlLFxyXG4gICAgICAgIGN1c3RvbVNxdWFyZVN0eWxlcyxcclxuICAgICAgICBkZWxldGVQaWVjZUZyb21TcXVhcmUsXHJcbiAgICAgICAgZHJhd05ld0Fycm93LFxyXG4gICAgICAgIGRyb3BPZmZCb2FyZEFjdGlvbixcclxuICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbixcclxuICAgICAgICBoYW5kbGVTcGFyZVBpZWNlRHJvcCxcclxuICAgICAgICBpZCxcclxuICAgICAgICBpc0RyYWdnYWJsZVBpZWNlLFxyXG4gICAgICAgIGlzV2FpdGluZ0ZvckFuaW1hdGlvbixcclxuICAgICAgICBsYXN0UGllY2VDb2xvdXIsXHJcbiAgICAgICAgbGFzdFNxdWFyZURyYWdnZWRPdmVyLFxyXG4gICAgICAgIG5ld0Fycm93LFxyXG4gICAgICAgIG9uQXJyb3dEcmF3RW5kLFxyXG4gICAgICAgIG9uRHJhZ092ZXJTcXVhcmUsXHJcbiAgICAgICAgb25Nb3VzZU91dFNxdWFyZSxcclxuICAgICAgICBvbk1vdXNlT3ZlclNxdWFyZSxcclxuICAgICAgICBvblBpZWNlQ2xpY2ssXHJcbiAgICAgICAgb25QaWVjZURyYWdCZWdpbixcclxuICAgICAgICBvblBpZWNlRHJhZ0VuZCxcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBvblBpZWNlRHJvcE9mZkJvYXJkLFxyXG4gICAgICAgIG9uUHJvbW90aW9uQ2hlY2ssXHJcbiAgICAgICAgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCxcclxuICAgICAgICBvblJpZ2h0Q2xpY2tEb3duLFxyXG4gICAgICAgIG9uUmlnaHRDbGlja1VwLFxyXG4gICAgICAgIG9uU3BhcmVQaWVjZURyb3AsXHJcbiAgICAgICAgb25TcXVhcmVDbGljayxcclxuICAgICAgICBwb3NpdGlvbkRpZmZlcmVuY2VzLFxyXG4gICAgICAgIHByZW1vdmVzLFxyXG4gICAgICAgIHByb21vdGVGcm9tU3F1YXJlLFxyXG4gICAgICAgIHByb21vdGVUb1NxdWFyZSxcclxuICAgICAgICBwcm9tb3Rpb25EaWFsb2dWYXJpYW50LFxyXG4gICAgICAgIHNldExhc3RTcXVhcmVEcmFnZ2VkT3ZlcixcclxuICAgICAgICBzZXRQcm9tb3RlRnJvbVNxdWFyZSxcclxuICAgICAgICBzZXRQcm9tb3RlVG9TcXVhcmUsXHJcbiAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc2hvd0JvYXJkTm90YXRpb24sXHJcbiAgICAgICAgc2hvd1Byb21vdGVEaWFsb2csXHJcbiAgICAgICAgc25hcFRvQ3Vyc29yLFxyXG4gICAgfTtcclxuICAgIHJldHVybiAoanN4KENoZXNzYm9hcmRDb250ZXh0LlByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgdmFsdWU6IENoZXNzYm9hcmRQcm92aWRlckNvbnRleHRWYWx1ZSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpO1xyXG59KTtcblxuZnVuY3Rpb24gTm90YXRpb24oeyByb3csIGNvbCB9KSB7XHJcbiAgICBjb25zdCB7IGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tTm90YXRpb25TdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHdoaXRlQ29sb3IgPSBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGNvbnN0IGJsYWNrQ29sb3IgPSBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgY29uc3QgaXNSb3cgPSBjb2wgPT09IDA7XHJcbiAgICBjb25zdCBpc0NvbHVtbiA9IHJvdyA9PT0gNztcclxuICAgIGNvbnN0IGlzQm90dG9tTGVmdFNxdWFyZSA9IGlzUm93ICYmIGlzQ29sdW1uO1xyXG4gICAgZnVuY3Rpb24gZ2V0Um93KCkge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCIgPyA4IC0gcm93IDogcm93ICsgMTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbHVtbigpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gQ09MVU1OU1s3IC0gY29sXSA6IENPTFVNTlNbY29sXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckJvdHRvbUxlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgekluZGV4OiAzLCBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiIH0sIHsgY29sb3I6IHdoaXRlQ29sb3IgfSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpLCBqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB6SW5kZXg6IDMsIHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSwgeyBjb2xvcjogd2hpdGVDb2xvciB9KSwgYWxwaGFTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Q29sdW1uKCkgfSkpXSB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJMZXR0ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCB7IGNvbG9yOiBjb2wgJSAyICE9PSAwID8gYmxhY2tDb2xvciA6IHdoaXRlQ29sb3IgfSksIGFscGhhU3R5bGUoYm9hcmRXaWR0aCwgY3VzdG9tTm90YXRpb25TdHlsZSkpIH0sIHsgY2hpbGRyZW46IGdldENvbHVtbigpIH0pKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJOdW1iZXJzKCkge1xyXG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdXNlclNlbGVjdDogXCJub25lXCIsIHpJbmRleDogMywgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9LCAoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICA/IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9XHJcbiAgICAgICAgICAgICAgICA6IHsgY29sb3I6IHJvdyAlIDIgPT09IDAgPyBibGFja0NvbG9yIDogd2hpdGVDb2xvciB9KSksIG51bWVyaWNTdHlsZShib2FyZFdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSkgfSwgeyBjaGlsZHJlbjogZ2V0Um93KCkgfSkpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0JvdHRvbUxlZnRTcXVhcmUpIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyQm90dG9tTGVmdCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ29sdW1uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckxldHRlcnMoKTtcclxuICAgIH1cclxuICAgIGlmIChpc1Jvdykge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJOdW1iZXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5jb25zdCBhbHBoYVN0eWxlID0gKHdpZHRoLCBjdXN0b21Ob3RhdGlvblN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbih7IGFsaWduU2VsZjogXCJmbGV4LWVuZFwiLCBwYWRkaW5nTGVmdDogd2lkdGggLyA4IC0gd2lkdGggLyA0OCwgZm9udFNpemU6IHdpZHRoIC8gNDggfSwgY3VzdG9tTm90YXRpb25TdHlsZSkpO1xyXG5jb25zdCBudW1lcmljU3R5bGUgPSAod2lkdGgsIGN1c3RvbU5vdGF0aW9uU3R5bGUpID0+IChPYmplY3QuYXNzaWduKHsgYWxpZ25TZWxmOiBcImZsZXgtc3RhcnRcIiwgcGFkZGluZ1JpZ2h0OiB3aWR0aCAvIDggLSB3aWR0aCAvIDQ4LCBmb250U2l6ZTogd2lkdGggLyA0OCB9LCBjdXN0b21Ob3RhdGlvblN0eWxlKSk7XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBSZWFjdCBDb250ZXh0XG4gKi8gY29uc3QgRG5kQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGRyYWdEcm9wTWFuYWdlcjogdW5kZWZpbmVkXG59KTtcblxuLyoqXG4gKiBBZGFwdGVkIGZyb20gUmVhY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS5qc1xuICpcbiAqIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIHRocm93IGVycm9yIGNhbGxzLiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbiAqIGR1cmluZyBidWlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gXCJNaW5pZmllZCBSZWR1eCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPVwiICsgY29kZSArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59XG5cbi8vIElubGluZWQgdmVyc2lvbiBvZiB0aGUgYHN5bWJvbC1vYnNlcnZhYmxlYCBwb2x5ZmlsbFxudmFyICQkb2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSkoKTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbn07XG5cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogXCJAQHJlZHV4L0lOSVRcIiArIHJhbmRvbVN0cmluZygpLFxuICBSRVBMQUNFOiBcIkBAcmVkdXgvUkVQTEFDRVwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiBmdW5jdGlvbiBQUk9CRV9VTktOT1dOX0FDVElPTigpIHtcbiAgICByZXR1cm4gXCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXCIgKyByYW5kb21TdHJpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IG9iajtcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8vIElubGluZWQgLyBzaG9ydGVuZWQgdmVyc2lvbiBvZiBga2luZE9mYCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2tpbmQtb2ZcbmZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICB2YXIgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcblxuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfSAvLyBvdGhlclxuXG5cbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn1cblxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgdmFyIHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihlbmhhbmNlcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IFwiRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKHJlZHVjZXIpICsgXCInXCIpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihsaXN0ZW5lcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBcIkFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnXCIgKyBraW5kT2YoYWN0aW9uKSArIFwiJy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiAnUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cblxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YobmV4dFJlZHVjZXIpKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKG9ic2VydmVyKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBzZXR0aW5nIG1vZGUgdG8gcHJvZHVjdGlvbiBpbiB3ZWJwYWNrIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL21vZGUvKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncykge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24oKSkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMSAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgICAgICA7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUHJvZHVjdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydOT0RFX0VOViddID09PSAncHJvZHVjdGlvbic7XG59XG5cbi8vIGNoZWFwIGxvZGFzaCByZXBsYWNlbWVudHNcbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5nZXRcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gKi8gZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKGEsIGMpPT5hICYmIGFbY10gPyBhW2NdIDogZGVmYXVsdFZhbHVlIHx8IG51bGxcbiAgICAsIG9iaik7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQkMShpdGVtcywgaXRlbSkge1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGkpPT5pICE9PSBpdGVtXG4gICAgKTtcbn1cbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy5pc1N0cmluZ1xuICogQHBhcmFtIGlucHV0XG4gKi8gZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogcmVwbGFjZW1lbnQgZm9yIF8ueG9yXG4gKiBAcGFyYW0gaXRlbXNBXG4gKiBAcGFyYW0gaXRlbXNCXG4gKi8gZnVuY3Rpb24geG9yKGl0ZW1zQSwgaXRlbXNCKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGluc2VydEl0ZW0gPSAoaXRlbSk9PntcbiAgICAgICAgbWFwLnNldChpdGVtLCBtYXAuaGFzKGl0ZW0pID8gbWFwLmdldChpdGVtKSArIDEgOiAxKTtcbiAgICB9O1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChjb3VudCwga2V5KT0+e1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiByZXBsYWNlbWVudCBmb3IgXy5pbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSBpdGVtc0FcbiAqIEBwYXJhbSBpdGVtc0JcbiAqLyBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oaXRlbXNBLCBpdGVtc0IpIHtcbiAgICByZXR1cm4gaXRlbXNBLmZpbHRlcigodCk9Pml0ZW1zQi5pbmRleE9mKHQpID4gLTFcbiAgICApO1xufVxuXG5jb25zdCBJTklUX0NPT1JEUyA9ICdkbmQtY29yZS9JTklUX0NPT1JEUyc7XG5jb25zdCBCRUdJTl9EUkFHID0gJ2RuZC1jb3JlL0JFR0lOX0RSQUcnO1xuY29uc3QgUFVCTElTSF9EUkFHX1NPVVJDRSA9ICdkbmQtY29yZS9QVUJMSVNIX0RSQUdfU09VUkNFJztcbmNvbnN0IEhPVkVSID0gJ2RuZC1jb3JlL0hPVkVSJztcbmNvbnN0IERST1AgPSAnZG5kLWNvcmUvRFJPUCc7XG5jb25zdCBFTkRfRFJBRyA9ICdkbmQtY29yZS9FTkRfRFJBRyc7XG5cbmZ1bmN0aW9uIHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IElOSVRfQ09PUkRTLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3QgUmVzZXRDb29yZGluYXRlc0FjdGlvbiA9IHtcbiAgICB0eXBlOiBJTklUX0NPT1JEUyxcbiAgICBwYXlsb2FkOiB7XG4gICAgICAgIGNsaWVudE9mZnNldDogbnVsbCxcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBudWxsXG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJlZ2luRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJlZ2luRHJhZyhzb3VyY2VJZHMgPSBbXSwgb3B0aW9ucyA9IHtcbiAgICAgICAgcHVibGlzaFNvdXJjZTogdHJ1ZVxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaXNoU291cmNlID10cnVlICwgY2xpZW50T2Zmc2V0ICwgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ICwgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb29yZGluYXRlcyB1c2luZyB0aGUgY2xpZW50IG9mZnNldFxuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQpKTtcbiAgICAgICAgdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICAvLyBHZXQgdGhlIGRyYWdnYWJsZSBzb3VyY2VcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKTtcbiAgICAgICAgaWYgKHNvdXJjZUlkID09IG51bGwpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuZGlzcGF0Y2goUmVzZXRDb29yZGluYXRlc0FjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VyY2UgY2xpZW50IG9mZnNldFxuICAgICAgICBsZXQgc291cmNlQ2xpZW50T2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgaWYgKCFnZXRTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlcmlmeUdldFNvdXJjZUNsaWVudE9mZnNldElzRnVuY3Rpb24oZ2V0U291cmNlQ2xpZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudE9mZnNldCA9IGdldFNvdXJjZUNsaWVudE9mZnNldChzb3VyY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnVsbCBjb29yZGluYXRlc1xuICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKHNldENsaWVudE9mZnNldChjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSByZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBjb25zdCBpdGVtID0gc291cmNlLmJlZ2luRHJhZyhtb25pdG9yLCBzb3VyY2VJZCk7XG4gICAgICAgIC8vIElmIHNvdXJjZS5iZWdpbkRyYWcgcmV0dXJucyBudWxsLCB0aGlzIGlzIGFuIGluZGljYXRvciB0byBjYW5jZWwgdGhlIGRyYWdcbiAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSk7XG4gICAgICAgIHJlZ2lzdHJ5LnBpblNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gcmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBCRUdJTl9EUkFHLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIGl0ZW1UeXBlLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBjbGllbnRPZmZzZXQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzb3VyY2VDbGllbnRPZmZzZXQ6IHNvdXJjZUNsaWVudE9mZnNldCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiAhIXB1Ymxpc2hTb3VyY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5SW52YXJpYW50cyQxKHNvdXJjZUlkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuaXNEcmFnZ2luZygpLCAnQ2Fubm90IGNhbGwgYmVnaW5EcmFnIHdoaWxlIGRyYWdnaW5nLicpO1xuICAgIHNvdXJjZUlkcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUlkKSB7XG4gICAgICAgIGludmFyaWFudChyZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQpLCAnRXhwZWN0ZWQgc291cmNlSWRzIHRvIGJlIHJlZ2lzdGVyZWQuJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlHZXRTb3VyY2VDbGllbnRPZmZzZXRJc0Z1bmN0aW9uKGdldFNvdXJjZUNsaWVudE9mZnNldCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID09PSAnZnVuY3Rpb24nLCAnV2hlbiBjbGllbnRPZmZzZXQgaXMgcHJvdmlkZWQsIGdldFNvdXJjZUNsaWVudE9mZnNldCBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJdGVtSXNPYmplY3QoaXRlbSkge1xuICAgIGludmFyaWFudChpc09iamVjdChpdGVtKSwgJ0l0ZW0gbXVzdCBiZSBhbiBvYmplY3QuJyk7XG59XG5mdW5jdGlvbiBnZXREcmFnZ2FibGVTb3VyY2Uoc291cmNlSWRzLCBtb25pdG9yKSB7XG4gICAgbGV0IHNvdXJjZUlkID0gbnVsbDtcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBpZiAobW9uaXRvci5jYW5EcmFnU291cmNlKHNvdXJjZUlkc1tpXSkpIHtcbiAgICAgICAgICAgIHNvdXJjZUlkID0gc291cmNlSWRzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZUlkO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkNChvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSQ0KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY3JlYXRlRHJvcChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRyb3Aob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUludmFyaWFudHMobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IGdldERyb3BwYWJsZVRhcmdldHMobW9uaXRvcik7XG4gICAgICAgIC8vIE11bHRpcGxlIGFjdGlvbnMgYXJlIGRpc3BhdGNoZWQgaGVyZSwgd2hpY2ggaXMgd2h5IHRoaXMgZG9lc24ndCByZXR1cm4gYW4gYWN0aW9uXG4gICAgICAgIHRhcmdldElkcy5mb3JFYWNoKCh0YXJnZXRJZCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBkcm9wUmVzdWx0ID0gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBEUk9QLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcFJlc3VsdDogX29iamVjdFNwcmVhZCQ0KHt9LCBvcHRpb25zLCBkcm9wUmVzdWx0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnZhcmlhbnRzKG1vbml0b3IpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBkcm9wIHdoaWxlIG5vdCBkcmFnZ2luZy4nKTtcbiAgICBpbnZhcmlhbnQoIW1vbml0b3IuZGlkRHJvcCgpLCAnQ2Fubm90IGNhbGwgZHJvcCB0d2ljZSBkdXJpbmcgb25lIGRyYWcgb3BlcmF0aW9uLicpO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lRHJvcFJlc3VsdCh0YXJnZXRJZCwgaW5kZXgsIHJlZ2lzdHJ5LCBtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICBsZXQgZHJvcFJlc3VsdCA9IHRhcmdldCA/IHRhcmdldC5kcm9wKG1vbml0b3IsIHRhcmdldElkKSA6IHVuZGVmaW5lZDtcbiAgICB2ZXJpZnlEcm9wUmVzdWx0VHlwZShkcm9wUmVzdWx0KTtcbiAgICBpZiAodHlwZW9mIGRyb3BSZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRyb3BSZXN1bHQgPSBpbmRleCA9PT0gMCA/IHt9IDogbW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIHJldHVybiBkcm9wUmVzdWx0O1xufVxuZnVuY3Rpb24gdmVyaWZ5RHJvcFJlc3VsdFR5cGUoZHJvcFJlc3VsdCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgZHJvcFJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNPYmplY3QoZHJvcFJlc3VsdCksICdEcm9wIHJlc3VsdCBtdXN0IGVpdGhlciBiZSBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkLicpO1xufVxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlVGFyZ2V0cyhtb25pdG9yKSB7XG4gICAgY29uc3QgdGFyZ2V0SWRzID0gbW9uaXRvci5nZXRUYXJnZXRJZHMoKS5maWx0ZXIobW9uaXRvci5jYW5Ecm9wT25UYXJnZXQsIG1vbml0b3IpO1xuICAgIHRhcmdldElkcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHRhcmdldElkcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcik7XG4gICAgICAgIGNvbnN0IHNvdXJjZUlkID0gbW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBpZiAoc291cmNlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gcmVnaXN0cnkuZ2V0U291cmNlKHNvdXJjZUlkLCB0cnVlKTtcbiAgICAgICAgICAgIHNvdXJjZS5lbmREcmFnKG1vbml0b3IsIHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnVucGluU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEVORF9EUkFHXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUlzRHJhZ2dpbmcobW9uaXRvcikge1xuICAgIGludmFyaWFudChtb25pdG9yLmlzRHJhZ2dpbmcoKSwgJ0Nhbm5vdCBjYWxsIGVuZERyYWcgd2hpbGUgbm90IGRyYWdnaW5nLicpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzVHlwZSh0YXJnZXRUeXBlLCBkcmFnZ2VkSXRlbVR5cGUpIHtcbiAgICBpZiAoZHJhZ2dlZEl0ZW1UeXBlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRUeXBlID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXRUeXBlKSA/IHRhcmdldFR5cGUuc29tZSgodCk9PnQgPT09IGRyYWdnZWRJdGVtVHlwZVxuICAgICkgOiB0YXJnZXRUeXBlID09PSBkcmFnZ2VkSXRlbVR5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaG92ZXIodGFyZ2V0SWRzQXJnLCB7IGNsaWVudE9mZnNldCAgfSA9IHt9KSB7XG4gICAgICAgIHZlcmlmeVRhcmdldElkc0lzQXJyYXkodGFyZ2V0SWRzQXJnKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzID0gdGFyZ2V0SWRzQXJnLnNsaWNlKDApO1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSBtb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSk7XG4gICAgICAgIGNoZWNrSW52YXJpYW50cyh0YXJnZXRJZHMsIG1vbml0b3IsIHJlZ2lzdHJ5KTtcbiAgICAgICAgaG92ZXJBbGxUYXJnZXRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSE9WRVIsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzLFxuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogY2xpZW50T2Zmc2V0IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5VGFyZ2V0SWRzSXNBcnJheSh0YXJnZXRJZHNBcmcpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh0YXJnZXRJZHNBcmcpLCAnRXhwZWN0ZWQgdGFyZ2V0SWRzIHRvIGJlIGFuIGFycmF5LicpO1xufVxuZnVuY3Rpb24gY2hlY2tJbnZhcmlhbnRzKHRhcmdldElkcywgbW9uaXRvciwgcmVnaXN0cnkpIHtcbiAgICBpbnZhcmlhbnQobW9uaXRvci5pc0RyYWdnaW5nKCksICdDYW5ub3QgY2FsbCBob3ZlciB3aGlsZSBub3QgZHJhZ2dpbmcuJyk7XG4gICAgaW52YXJpYW50KCFtb25pdG9yLmRpZERyb3AoKSwgJ0Nhbm5vdCBjYWxsIGhvdmVyIGFmdGVyIGRyb3AuJyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRhcmdldElkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdGFyZ2V0SWRzW2ldO1xuICAgICAgICBpbnZhcmlhbnQodGFyZ2V0SWRzLmxhc3RJbmRleE9mKHRhcmdldElkKSA9PT0gaSwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSB1bmlxdWUgaW4gdGhlIHBhc3NlZCBhcnJheS4nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVnaXN0cnkuZ2V0VGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgaW52YXJpYW50KHRhcmdldCwgJ0V4cGVjdGVkIHRhcmdldElkcyB0byBiZSByZWdpc3RlcmVkLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vbk1hdGNoaW5nVGFyZ2V0SWRzKHRhcmdldElkcywgcmVnaXN0cnksIGRyYWdnZWRJdGVtVHlwZSkge1xuICAgIC8vIFJlbW92ZSB0aG9zZSB0YXJnZXRJZHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgdGFyZ2V0VHlwZS4gIFRoaXNcbiAgICAvLyBmaXhlcyBzaGFsbG93IGlzT3ZlciB3aGljaCB3b3VsZCBvbmx5IGJlIG5vbi1zaGFsbG93IGJlY2F1c2Ugb2ZcbiAgICAvLyBub24tbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICBmb3IobGV0IGkgPSB0YXJnZXRJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldElkc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBpZiAoIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHRhcmdldElkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBob3ZlckFsbFRhcmdldHModGFyZ2V0SWRzLCBtb25pdG9yLCByZWdpc3RyeSkge1xuICAgIC8vIEZpbmFsbHkgY2FsbCBob3ZlciBvbiBhbGwgbWF0Y2hpbmcgdGFyZ2V0cy5cbiAgICB0YXJnZXRJZHMuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRJZCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSByZWdpc3RyeS5nZXRUYXJnZXQodGFyZ2V0SWQpO1xuICAgICAgICB0YXJnZXQuaG92ZXIobW9uaXRvciwgdGFyZ2V0SWQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQdWJsaXNoRHJhZ1NvdXJjZShtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHB1Ymxpc2hEcmFnU291cmNlKCkge1xuICAgICAgICBjb25zdCBtb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIGlmIChtb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQVUJMSVNIX0RSQUdfU09VUkNFXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFnRHJvcEFjdGlvbnMobWFuYWdlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZ2luRHJhZzogY3JlYXRlQmVnaW5EcmFnKG1hbmFnZXIpLFxuICAgICAgICBwdWJsaXNoRHJhZ1NvdXJjZTogY3JlYXRlUHVibGlzaERyYWdTb3VyY2UobWFuYWdlciksXG4gICAgICAgIGhvdmVyOiBjcmVhdGVIb3ZlcihtYW5hZ2VyKSxcbiAgICAgICAgZHJvcDogY3JlYXRlRHJvcChtYW5hZ2VyKSxcbiAgICAgICAgZW5kRHJhZzogY3JlYXRlRW5kRHJhZyhtYW5hZ2VyKVxuICAgIH07XG59XG5cbmNsYXNzIERyYWdEcm9wTWFuYWdlckltcGwge1xuICAgIHJlY2VpdmVCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0TW9uaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9uaXRvcjtcbiAgICB9XG4gICAgZ2V0QmFja2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZDtcbiAgICB9XG4gICAgZ2V0UmVnaXN0cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbml0b3IucmVnaXN0cnk7XG4gICAgfVxuICAgIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyAqLyBjb25zdCBtYW5hZ2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkaXNwYXRjaCAgfSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25DcmVhdG9yLmFwcGx5KG1hbmFnZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGNyZWF0ZURyYWdEcm9wQWN0aW9ucyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGlvbnMpLnJlZHVjZSgoYm91bmRBY3Rpb25zLCBrZXkpPT57XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW2tleV07XG4gICAgICAgICAgICBib3VuZEFjdGlvbnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRBY3Rpb25zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0b3JlLCBtb25pdG9yKXtcbiAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmQ291bnRDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2V0VXAgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkucmVmQ291bnQgPiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTZXRVcCAmJiAhdGhpcy5pc1NldFVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2VuZC5zZXR1cCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2V0VXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNob3VsZFNldFVwICYmIHRoaXMuaXNTZXRVcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2tlbmQudGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICAgIHN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZVJlZkNvdW50Q2hhbmdlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29vcmRpbmF0ZSBhZGRpdGlvblxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgY29vcmRpbmF0ZVxuICovIGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogYS54ICsgYi54LFxuICAgICAgICB5OiBhLnkgKyBiLnlcbiAgICB9O1xufVxuLyoqXG4gKiBDb29yZGluYXRlIHN1YnRyYWN0aW9uXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgY29vcmRpbmF0ZVxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBjb29yZGluYXRlXG4gKi8gZnVuY3Rpb24gc3VidHJhY3QoYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGEueCAtIGIueCxcbiAgICAgICAgeTogYS55IC0gYi55XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY2FydGVzaWFuIGRpc3RhbmNlIG9mIHRoZSBkcmFnIHNvdXJjZSBjb21wb25lbnQncyBwb3NpdGlvbiwgYmFzZWQgb24gaXRzIHBvc2l0aW9uXG4gKiBhdCB0aGUgdGltZSB3aGVuIHRoZSBjdXJyZW50IGRyYWcgb3BlcmF0aW9uIGhhcyBzdGFydGVkLCBhbmQgdGhlIG1vdmVtZW50IGRpZmZlcmVuY2UuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIG5vIGl0ZW0gaXMgYmVpbmcgZHJhZ2dlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgVGhlIG9mZnNldCBzdGF0ZSB0byBjb21wdXRlIGZyb21cbiAqLyBmdW5jdGlvbiBnZXRTb3VyY2VDbGllbnRPZmZzZXQoc3RhdGUpIHtcbiAgICBjb25zdCB7IGNsaWVudE9mZnNldCAsIGluaXRpYWxDbGllbnRPZmZzZXQgLCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0ICB9ID0gc3RhdGU7XG4gICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIWluaXRpYWxDbGllbnRPZmZzZXQgfHwgIWluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdWJ0cmFjdChhZGQoY2xpZW50T2Zmc2V0LCBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KSwgaW5pdGlhbENsaWVudE9mZnNldCk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHgseSBvZmZzZXQgYmV0d2VlbiB0aGUgY2xpZW50IG9mZnNldCBhbmQgdGhlIGluaXRpYWwgY2xpZW50IG9mZnNldFxuICpcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgb2Zmc2V0IHN0YXRlIHRvIGNvbXB1dGUgZnJvbVxuICovIGZ1bmN0aW9uIGdldERpZmZlcmVuY2VGcm9tSW5pdGlhbE9mZnNldChzdGF0ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50T2Zmc2V0ICwgaW5pdGlhbENsaWVudE9mZnNldCAgfSA9IHN0YXRlO1xuICAgIGlmICghY2xpZW50T2Zmc2V0IHx8ICFpbml0aWFsQ2xpZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VidHJhY3QoY2xpZW50T2Zmc2V0LCBpbml0aWFsQ2xpZW50T2Zmc2V0KTtcbn1cblxuY29uc3QgTk9ORSA9IFtdO1xuY29uc3QgQUxMID0gW107XG5OT05FLl9fSVNfTk9ORV9fID0gdHJ1ZTtcbkFMTC5fX0lTX0FMTF9fID0gdHJ1ZTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gaGFuZGxlciBJRHMgYXJlIGRpcnR5IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZGlydHlJZHMgVGhlIHNldCBvZiBkaXJ0eSBoYW5kbGVyIGlkc1xuICogQHBhcmFtIGhhbmRsZXJJZHMgVGhlIHNldCBvZiBoYW5kbGVyIGlkcyB0byBjaGVja1xuICovIGZ1bmN0aW9uIGFyZURpcnR5KGRpcnR5SWRzLCBoYW5kbGVySWRzKSB7XG4gICAgaWYgKGRpcnR5SWRzID09PSBOT05FKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpcnR5SWRzID09PSBBTEwgfHwgdHlwZW9mIGhhbmRsZXJJZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25JZHMgPSBpbnRlcnNlY3Rpb24oaGFuZGxlcklkcywgZGlydHlJZHMpO1xuICAgIHJldHVybiBjb21tb25JZHMubGVuZ3RoID4gMDtcbn1cblxuY2xhc3MgRHJhZ0Ryb3BNb25pdG9ySW1wbCB7XG4gICAgc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShsaXN0ZW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlcklkcyAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicsICdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgaGFuZGxlcklkcyA9PT0gJ3VuZGVmaW5lZCcgfHwgQXJyYXkuaXNBcnJheShoYW5kbGVySWRzKSwgJ2hhbmRsZXJJZHMsIHdoZW4gc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGxldCBwcmV2U3RhdGVJZCA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5zdGF0ZUlkO1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVJZCA9IHN0YXRlLnN0YXRlSWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhblNraXBMaXN0ZW5lciA9IGN1cnJlbnRTdGF0ZUlkID09PSBwcmV2U3RhdGVJZCB8fCBjdXJyZW50U3RhdGVJZCA9PT0gcHJldlN0YXRlSWQgKyAxICYmICFhcmVEaXJ0eShzdGF0ZS5kaXJ0eUhhbmRsZXJJZHMsIGhhbmRsZXJJZHMpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHByZXZTdGF0ZUlkID0gY3VycmVudFN0YXRlSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcikge1xuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLCAnbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgICAgICBsZXQgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT2Zmc2V0O1xuICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoKT0+e1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSBwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2UpO1xuICAgIH1cbiAgICBjYW5EcmFnU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIGlmICghc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlZ2lzdHJ5LmdldFNvdXJjZShzb3VyY2VJZCk7XG4gICAgICAgIGludmFyaWFudChzb3VyY2UsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgc291cmNlLiBzb3VyY2VJZD0ke3NvdXJjZUlkfWApO1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmNhbkRyYWcodGhpcywgc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIG9uIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldCh0YXJnZXRJZCk7XG4gICAgICAgIGludmFyaWFudCh0YXJnZXQsIGBFeHBlY3RlZCB0byBmaW5kIGEgdmFsaWQgdGFyZ2V0LiB0YXJnZXRJZD0ke3RhcmdldElkfWApO1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpIHx8IHRoaXMuZGlkRHJvcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkgJiYgdGFyZ2V0LmNhbkRyb3AodGhpcywgdGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldEl0ZW1UeXBlKCkpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5yZWdpc3RyeS5nZXRTb3VyY2Uoc291cmNlSWQsIHRydWUpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCBgRXhwZWN0ZWQgdG8gZmluZCBhIHZhbGlkIHNvdXJjZS4gc291cmNlSWQ9JHtzb3VyY2VJZH1gKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5pc1NvdXJjZVB1YmxpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlVHlwZSA9IHRoaXMucmVnaXN0cnkuZ2V0U291cmNlVHlwZShzb3VyY2VJZCk7XG4gICAgICAgIGNvbnN0IGRyYWdnZWRJdGVtVHlwZSA9IHRoaXMuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgaWYgKHNvdXJjZVR5cGUgIT09IGRyYWdnZWRJdGVtVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UuaXNEcmFnZ2luZyh0aGlzLCBzb3VyY2VJZCk7XG4gICAgfVxuICAgIGlzT3ZlclRhcmdldCh0YXJnZXRJZCwgb3B0aW9ucyA9IHtcbiAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICB9KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBvbiBpbml0aWFsIHJlbmRlclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ICB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSB0aGlzLnJlZ2lzdHJ5LmdldFRhcmdldFR5cGUodGFyZ2V0SWQpO1xuICAgICAgICBjb25zdCBkcmFnZ2VkSXRlbVR5cGUgPSB0aGlzLmdldEl0ZW1UeXBlKCk7XG4gICAgICAgIGlmIChkcmFnZ2VkSXRlbVR5cGUgJiYgIW1hdGNoZXNUeXBlKHRhcmdldFR5cGUsIGRyYWdnZWRJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZHMgPSB0aGlzLmdldFRhcmdldElkcygpO1xuICAgICAgICBpZiAoIXRhcmdldElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHRhcmdldElkcy5pbmRleE9mKHRhcmdldElkKTtcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gdGFyZ2V0SWRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLml0ZW1UeXBlO1xuICAgIH1cbiAgICBnZXRJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uaXRlbTtcbiAgICB9XG4gICAgZ2V0U291cmNlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5zb3VyY2VJZDtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24udGFyZ2V0SWRzO1xuICAgIH1cbiAgICBnZXREcm9wUmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPcGVyYXRpb24uZHJvcFJlc3VsdDtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS5kcmFnT3BlcmF0aW9uLmRpZERyb3A7XG4gICAgfVxuICAgIGlzU291cmNlUHVibGljKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09wZXJhdGlvbi5pc1NvdXJjZVB1YmxpYyk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkuZHJhZ09mZnNldC5pbml0aWFsQ2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQuY2xpZW50T2Zmc2V0O1xuICAgIH1cbiAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRTb3VyY2VDbGllbnRPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQodGhpcy5zdG9yZS5nZXRTdGF0ZSgpLmRyYWdPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSwgcmVnaXN0cnkpe1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB9XG59XG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBvciBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cbi8qIGdsb2JhbHMgc2VsZiAqLyBjb25zdCBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjtcbmNvbnN0IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIGNvbnN0IGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRvZ2dsZSA9IDE7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuY29uc3QgbWFrZVJlcXVlc3RDYWxsID0gdHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nID8gLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xubWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIgOiAvLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuY2xhc3MgQXNhcFF1ZXVlIHtcbiAgICAvLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4gICAgLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuICAgIC8vIGV2ZW50cyBpbiBicm93c2Vycy5cbiAgICAvL1xuICAgIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4gICAgLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4gICAgLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuICAgIC8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4gICAgLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgZW5xdWV1ZVRhc2sodGFzaykge1xuICAgICAgICBjb25zdCB7IHF1ZXVlOiBxICwgcmVxdWVzdEZsdXNoICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICBxW3EubGVuZ3RoXSA9IHRhc2s7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuICAgICAgICAvLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbiAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzID0gW107XG4gICAgICAgIC8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbiAgICAgICAgLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4gICAgICAgIC8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuICAgICAgICAvLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4gICAgICAgIC8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gMTAyNDtcbiAgICAgICAgLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbiAgICAgICAgLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbiAgICAgICAgLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4gICAgICAgIC8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuICAgICAgICAvLyBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICB0aGlzLmZsdXNoID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgcXVldWU6IHEgIH0gPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pbmRleCA8IHEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgIHFbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxLmxlbmd0aCAtIHRoaXMuaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBxW3NjYW5dID0gcVtzY2FuICsgdGhpcy5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcS5sZW5ndGggLT0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgIHRoaXMucmVnaXN0ZXJQZW5kaW5nRXJyb3IgPSAoZXJyKT0+e1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4gICAgICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuICAgICAgICAvLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbiAgICAgICAgLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG4gICAgICAgIC8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuICAgICAgICAvLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG4gICAgICAgIHRoaXMucmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsKHRoaXMuZmx1c2gpO1xuICAgICAgICB0aGlzLnJlcXVlc3RFcnJvclRocm93ID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKCgpPT57XG4gICAgICAgICAgICAvLyBUaHJvdyBmaXJzdCBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSAvLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbiAvLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4gLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAvLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4gLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbiAvLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuIC8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuIC8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuIC8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuIC8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuIC8vICAgICB9O1xuIC8vIH1cbiAvLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbiAvLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbiAvLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuIC8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4gLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbiAvLyBjbG9zdXJlLlxuIC8vIE5ldmVyIGZvcmdldC5cbiAvLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAvLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gLy8gICAgIH07XG4gLy8gfVxuIC8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuIC8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuIC8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4gLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuIC8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuIC8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuIC8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3RcbiAvLyBldmVuIHRoZW4uXG4gLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4gLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbiAvLyAvLyBpdHMgZXhpc3RlbmNlLlxuIC8vIHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyXG4gLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4gLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbiAvLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbiAvLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4gLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmNsYXNzIFJhd1Rhc2sge1xuICAgIGNhbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRhc2sgJiYgdGhpcy50YXNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9uRXJyb3IsIHJlbGVhc2Upe1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICB0aGlzLnJlbGVhc2UgPSByZWxlYXNlO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbn1cblxuY2xhc3MgVGFza0ZhY3Rvcnkge1xuICAgIGNyZWF0ZSh0YXNrKSB7XG4gICAgICAgIGNvbnN0IHRhc2tzID0gdGhpcy5mcmVlVGFza3M7XG4gICAgICAgIGNvbnN0IHQxID0gdGFza3MubGVuZ3RoID8gdGFza3MucG9wKCkgOiBuZXcgUmF3VGFzayh0aGlzLm9uRXJyb3IsICh0KT0+dGFza3NbdGFza3MubGVuZ3RoXSA9IHRcbiAgICAgICAgKTtcbiAgICAgICAgdDEudGFzayA9IHRhc2s7XG4gICAgICAgIHJldHVybiB0MTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob25FcnJvcil7XG4gICAgICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgIHRoaXMuZnJlZVRhc2tzID0gW107XG4gICAgfVxufVxuXG5jb25zdCBhc2FwUXVldWUgPSBuZXcgQXNhcFF1ZXVlKCk7XG5jb25zdCB0YXNrRmFjdG9yeSA9IG5ldyBUYXNrRmFjdG9yeShhc2FwUXVldWUucmVnaXN0ZXJQZW5kaW5nRXJyb3IpO1xuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovIGZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIGFzYXBRdWV1ZS5lbnF1ZXVlVGFzayh0YXNrRmFjdG9yeS5jcmVhdGUodGFzaykpO1xufVxuXG5jb25zdCBBRERfU09VUkNFID0gJ2RuZC1jb3JlL0FERF9TT1VSQ0UnO1xuY29uc3QgQUREX1RBUkdFVCA9ICdkbmQtY29yZS9BRERfVEFSR0VUJztcbmNvbnN0IFJFTU9WRV9TT1VSQ0UgPSAnZG5kLWNvcmUvUkVNT1ZFX1NPVVJDRSc7XG5jb25zdCBSRU1PVkVfVEFSR0VUID0gJ2RuZC1jb3JlL1JFTU9WRV9UQVJHRVQnO1xuZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogQUREX1NPVVJDRSxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc291cmNlSWRcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRUYXJnZXQodGFyZ2V0SWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBBRERfVEFSR0VULFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICB0YXJnZXRJZFxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJFTU9WRV9TT1VSQ0UsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHNvdXJjZUlkXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUkVNT1ZFX1RBUkdFVCxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgdGFyZ2V0SWRcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlQ29udHJhY3Qoc291cmNlKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiBzb3VyY2UuY2FuRHJhZyA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIGNhbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5iZWdpbkRyYWcgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBiZWdpbkRyYWcgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNvdXJjZS5lbmREcmFnID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgZW5kRHJhZyB0byBiZSBhIGZ1bmN0aW9uLicpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRDb250cmFjdCh0YXJnZXQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5jYW5Ecm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgY2FuRHJvcCB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIGludmFyaWFudCh0eXBlb2YgdGFyZ2V0LmhvdmVyID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgaG92ZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICBpbnZhcmlhbnQodHlwZW9mIHRhcmdldC5kcm9wID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgYmVnaW5EcmFnIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSwgYWxsb3dBcnJheSkge1xuICAgIGlmIChhbGxvd0FycmF5ICYmIEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZS5mb3JFYWNoKCh0KT0+dmFsaWRhdGVUeXBlKHQsIGZhbHNlKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnLCBhbGxvd0FycmF5ID8gJ1R5cGUgY2FuIG9ubHkgYmUgYSBzdHJpbmcsIGEgc3ltYm9sLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuJyA6ICdUeXBlIGNhbiBvbmx5IGJlIGEgc3RyaW5nIG9yIGEgc3ltYm9sLicpO1xufVxuXG52YXIgSGFuZGxlclJvbGU7XG4oZnVuY3Rpb24oSGFuZGxlclJvbGUpIHtcbiAgICBIYW5kbGVyUm9sZVtcIlNPVVJDRVwiXSA9IFwiU09VUkNFXCI7XG4gICAgSGFuZGxlclJvbGVbXCJUQVJHRVRcIl0gPSBcIlRBUkdFVFwiO1xufSkoSGFuZGxlclJvbGUgfHwgKEhhbmRsZXJSb2xlID0ge30pKTtcblxubGV0IG5leHRVbmlxdWVJZCA9IDA7XG5mdW5jdGlvbiBnZXROZXh0VW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIG5leHRVbmlxdWVJZCsrO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SGFuZGxlcklkKHJvbGUpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRVbmlxdWVJZCgpLnRvU3RyaW5nKCk7XG4gICAgc3dpdGNoKHJvbGUpe1xuICAgICAgICBjYXNlIEhhbmRsZXJSb2xlLlNPVVJDRTpcbiAgICAgICAgICAgIHJldHVybiBgUyR7aWR9YDtcbiAgICAgICAgY2FzZSBIYW5kbGVyUm9sZS5UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gYFQke2lkfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSGFuZGxlciBSb2xlOiAke3JvbGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpIHtcbiAgICBzd2l0Y2goaGFuZGxlcklkWzBdKXtcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICByZXR1cm4gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHJldHVybiBIYW5kbGVyUm9sZS5UQVJHRVQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBoYW5kbGVyIElEOiAke2hhbmRsZXJJZH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDb250YWluc1ZhbHVlKG1hcCwgc2VhcmNoVmFsdWUpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gbWFwLmVudHJpZXMoKTtcbiAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCB7IGRvbmUgLCB2YWx1ZTogWywgdmFsdWVdICwgIH0gPSBlbnRyaWVzLm5leHQoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBzZWFyY2hWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaXNEb25lID0gISFkb25lO1xuICAgIH13aGlsZSAoIWlzRG9uZSlcbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBIYW5kbGVyUmVnaXN0cnlJbXBsIHtcbiAgICBhZGRTb3VyY2UodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZSh0eXBlKTtcbiAgICAgICAgdmFsaWRhdGVTb3VyY2VDb250cmFjdChzb3VyY2UpO1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMuYWRkSGFuZGxlcihIYW5kbGVyUm9sZS5TT1VSQ0UsIHR5cGUsIHNvdXJjZSk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goYWRkU291cmNlKHNvdXJjZUlkKSk7XG4gICAgICAgIHJldHVybiBzb3VyY2VJZDtcbiAgICB9XG4gICAgYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCkge1xuICAgICAgICB2YWxpZGF0ZVR5cGUodHlwZSwgdHJ1ZSk7XG4gICAgICAgIHZhbGlkYXRlVGFyZ2V0Q29udHJhY3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSB0aGlzLmFkZEhhbmRsZXIoSGFuZGxlclJvbGUuVEFSR0VULCB0eXBlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKGFkZFRhcmdldCh0YXJnZXRJZCkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGNvbnRhaW5zSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBtYXBDb250YWluc1ZhbHVlKHRoaXMuZHJhZ1NvdXJjZXMsIGhhbmRsZXIpIHx8IG1hcENvbnRhaW5zVmFsdWUodGhpcy5kcm9wVGFyZ2V0cywgaGFuZGxlcik7XG4gICAgfVxuICAgIGdldFNvdXJjZShzb3VyY2VJZCwgaW5jbHVkZVBpbm5lZCA9IGZhbHNlKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzU291cmNlSWQoc291cmNlSWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCBzb3VyY2UgSUQuJyk7XG4gICAgICAgIGNvbnN0IGlzUGlubmVkID0gaW5jbHVkZVBpbm5lZCAmJiBzb3VyY2VJZCA9PT0gdGhpcy5waW5uZWRTb3VyY2VJZDtcbiAgICAgICAgY29uc3Qgc291cmNlID0gaXNQaW5uZWQgPyB0aGlzLnBpbm5lZFNvdXJjZSA6IHRoaXMuZHJhZ1NvdXJjZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmlzVGFyZ2V0SWQodGFyZ2V0SWQpLCAnRXhwZWN0ZWQgYSB2YWxpZCB0YXJnZXQgSUQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXRzLmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldFNvdXJjZVR5cGUoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuaXNTb3VyY2VJZChzb3VyY2VJZCksICdFeHBlY3RlZCBhIHZhbGlkIHNvdXJjZSBJRC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0VHlwZSh0YXJnZXRJZCkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5pc1RhcmdldElkKHRhcmdldElkKSwgJ0V4cGVjdGVkIGEgdmFsaWQgdGFyZ2V0IElELicpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlcy5nZXQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBpc1NvdXJjZUlkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFO1xuICAgIH1cbiAgICBpc1RhcmdldElkKGhhbmRsZXJJZCkge1xuICAgICAgICBjb25zdCByb2xlID0gcGFyc2VSb2xlRnJvbUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICByZXR1cm4gcm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUO1xuICAgIH1cbiAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuZ2V0U291cmNlKHNvdXJjZUlkKSwgJ0V4cGVjdGVkIGFuIGV4aXN0aW5nIHNvdXJjZS4nKTtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChyZW1vdmVTb3VyY2Uoc291cmNlSWQpKTtcbiAgICAgICAgYXNhcCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy50eXBlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0KHRhcmdldElkKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmdldFRhcmdldCh0YXJnZXRJZCksICdFeHBlY3RlZCBhbiBleGlzdGluZyB0YXJnZXQuJyk7XG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gocmVtb3ZlVGFyZ2V0KHRhcmdldElkKSk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgdGhpcy50eXBlcy5kZWxldGUodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBwaW5Tb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRTb3VyY2Uoc291cmNlSWQpO1xuICAgICAgICBpbnZhcmlhbnQoc291cmNlLCAnRXhwZWN0ZWQgYW4gZXhpc3Rpbmcgc291cmNlLicpO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZUlkID0gc291cmNlSWQ7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICB1bnBpblNvdXJjZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMucGlubmVkU291cmNlLCAnTm8gc291cmNlIGlzIHBpbm5lZCBhdCB0aGUgdGltZS4nKTtcbiAgICAgICAgdGhpcy5waW5uZWRTb3VyY2VJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihyb2xlLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0TmV4dEhhbmRsZXJJZChyb2xlKTtcbiAgICAgICAgdGhpcy50eXBlcy5zZXQoaWQsIHR5cGUpO1xuICAgICAgICBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuU09VUkNFKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAocm9sZSA9PT0gSGFuZGxlclJvbGUuVEFSR0VUKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRzLnNldChpZCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSl7XG4gICAgICAgIHRoaXMudHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGlubmVkU291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbm5lZFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG59XG5cbmNvbnN0IHN0cmljdEVxdWFsaXR5ID0gKGEsIGIpPT5hID09PSBiXG47XG4vKipcbiAqIERldGVybWluZSBpZiB0d28gY2FydGVzaWFuIGNvb3JkaW5hdGUgb2Zmc2V0cyBhcmUgZXF1YWxcbiAqIEBwYXJhbSBvZmZzZXRBXG4gKiBAcGFyYW0gb2Zmc2V0QlxuICovIGZ1bmN0aW9uIGFyZUNvb3Jkc0VxdWFsKG9mZnNldEEsIG9mZnNldEIpIHtcbiAgICBpZiAoIW9mZnNldEEgJiYgIW9mZnNldEIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghb2Zmc2V0QSB8fCAhb2Zmc2V0Qikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldEEueCA9PT0gb2Zmc2V0Qi54ICYmIG9mZnNldEEueSA9PT0gb2Zmc2V0Qi55O1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gYXJyYXlzIG9mIGl0ZW1zIGFyZSBlcXVhbFxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IG9mIGl0ZW1zXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGFycmF5IG9mIGl0ZW1zXG4gKi8gZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCA9IHN0cmljdEVxdWFsaXR5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYgKCFpc0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZSQ1KC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbl9zdGF0ZSA9IE5PTkUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSE9WRVI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBRERfU09VUkNFOlxuICAgICAgICBjYXNlIEFERF9UQVJHRVQ6XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICAgICAgcmV0dXJuIE5PTkU7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgY2FzZSBQVUJMSVNIX0RSQUdfU09VUkNFOlxuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQUxMO1xuICAgIH1cbiAgICBjb25zdCB7IHRhcmdldElkcyA9W10gLCBwcmV2VGFyZ2V0SWRzID1bXSAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHhvcih0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGNvbnN0IGRpZENoYW5nZSA9IHJlc3VsdC5sZW5ndGggPiAwIHx8ICFhcmVBcnJheXNFcXVhbCh0YXJnZXRJZHMsIHByZXZUYXJnZXRJZHMpO1xuICAgIGlmICghZGlkQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBOT05FO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGlkcyBhdCB0aGUgaW5uZXJtb3N0IHBvc2l0aW9uLiBJZiB0aGV5IGFyZSB2YWxpZCwgYWRkIHRoZW1cbiAgICAvLyB0byB0aGUgcmVzdWx0XG4gICAgY29uc3QgcHJldklubmVybW9zdFRhcmdldElkID0gcHJldlRhcmdldElkc1twcmV2VGFyZ2V0SWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGlubmVybW9zdFRhcmdldElkID0gdGFyZ2V0SWRzW3RhcmdldElkcy5sZW5ndGggLSAxXTtcbiAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkICE9PSBpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICBpZiAocHJldklubmVybW9zdFRhcmdldElkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcmV2SW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lcm1vc3RUYXJnZXRJZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5uZXJtb3N0VGFyZ2V0SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQzKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDModGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUkMSA9IHtcbiAgICBpbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0OiBudWxsLFxuICAgIGluaXRpYWxDbGllbnRPZmZzZXQ6IG51bGwsXG4gICAgY2xpZW50T2Zmc2V0OiBudWxsXG59O1xuZnVuY3Rpb24gcmVkdWNlJDQoc3RhdGUgPSBpbml0aWFsU3RhdGUkMSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgSU5JVF9DT09SRFM6XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldDogcGF5bG9hZC5zb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbENsaWVudE9mZnNldDogcGF5bG9hZC5jbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIGlmIChhcmVDb29yZHNFcXVhbChzdGF0ZS5jbGllbnRPZmZzZXQsIHBheWxvYWQuY2xpZW50T2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBwYXlsb2FkLmNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgRU5EX0RSQUc6XG4gICAgICAgIGNhc2UgRFJPUDpcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsU3RhdGUkMTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQyKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX2RlZmluZVByb3BlcnR5JDIodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgaXRlbVR5cGU6IG51bGwsXG4gICAgaXRlbTogbnVsbCxcbiAgICBzb3VyY2VJZDogbnVsbCxcbiAgICB0YXJnZXRJZHM6IFtdLFxuICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgZGlkRHJvcDogZmFsc2UsXG4gICAgaXNTb3VyY2VQdWJsaWM6IG51bGxcbn07XG5mdW5jdGlvbiByZWR1Y2UkMyhzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkICB9ID0gYWN0aW9uO1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQkVHSU5fRFJBRzpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgaXRlbVR5cGU6IHBheWxvYWQuaXRlbVR5cGUsXG4gICAgICAgICAgICAgICAgaXRlbTogcGF5bG9hZC5pdGVtLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXlsb2FkLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiBwYXlsb2FkLmlzU291cmNlUHVibGljLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFBVQkxJU0hfRFJBR19TT1VSQ0U6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGlzU291cmNlUHVibGljOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDIoe30sIHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBwYXlsb2FkLnRhcmdldElkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgUkVNT1ZFX1RBUkdFVDpcbiAgICAgICAgICAgIGlmIChzdGF0ZS50YXJnZXRJZHMuaW5kZXhPZihwYXlsb2FkLnRhcmdldElkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldElkczogd2l0aG91dCQxKHN0YXRlLnRhcmdldElkcywgcGF5bG9hZC50YXJnZXRJZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIERST1A6XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQyKHt9LCBzdGF0ZSwge1xuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IHBheWxvYWQuZHJvcFJlc3VsdCxcbiAgICAgICAgICAgICAgICBkaWREcm9wOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldElkczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIEVORF9EUkFHOlxuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkMih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGRyb3BSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlkRHJvcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNTb3VyY2VQdWJsaWM6IG51bGwsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWRzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UkMihzdGF0ZSA9IDAsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUREX1NPVVJDRTpcbiAgICAgICAgY2FzZSBBRERfVEFSR0VUOlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlICsgMTtcbiAgICAgICAgY2FzZSBSRU1PVkVfU09VUkNFOlxuICAgICAgICBjYXNlIFJFTU9WRV9UQVJHRVQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgLSAxO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlJDEoc3RhdGUgPSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlICsgMTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkkMSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHJlZHVjZShzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXJ0eUhhbmRsZXJJZHM6IHJlZHVjZSQ1KHN0YXRlLmRpcnR5SGFuZGxlcklkcywge1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkOiBfb2JqZWN0U3ByZWFkJDEoe30sIGFjdGlvbi5wYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgcHJldlRhcmdldElkczogZ2V0KHN0YXRlLCAnZHJhZ09wZXJhdGlvbi50YXJnZXRJZHMnLCBbXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBkcmFnT2Zmc2V0OiByZWR1Y2UkNChzdGF0ZS5kcmFnT2Zmc2V0LCBhY3Rpb24pLFxuICAgICAgICByZWZDb3VudDogcmVkdWNlJDIoc3RhdGUucmVmQ291bnQsIGFjdGlvbiksXG4gICAgICAgIGRyYWdPcGVyYXRpb246IHJlZHVjZSQzKHN0YXRlLmRyYWdPcGVyYXRpb24sIGFjdGlvbiksXG4gICAgICAgIHN0YXRlSWQ6IHJlZHVjZSQxKHN0YXRlLnN0YXRlSWQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmRGYWN0b3J5LCBnbG9iYWxDb250ZXh0ID0gdW5kZWZpbmVkLCBiYWNrZW5kT3B0aW9ucyA9IHt9LCBkZWJ1Z01vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0b3JlID0gbWFrZVN0b3JlSW5zdGFuY2UoZGVidWdNb2RlKTtcbiAgICBjb25zdCBtb25pdG9yID0gbmV3IERyYWdEcm9wTW9uaXRvckltcGwoc3RvcmUsIG5ldyBIYW5kbGVyUmVnaXN0cnlJbXBsKHN0b3JlKSk7XG4gICAgY29uc3QgbWFuYWdlciA9IG5ldyBEcmFnRHJvcE1hbmFnZXJJbXBsKHN0b3JlLCBtb25pdG9yKTtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZEZhY3RvcnkobWFuYWdlciwgZ2xvYmFsQ29udGV4dCwgYmFja2VuZE9wdGlvbnMpO1xuICAgIG1hbmFnZXIucmVjZWl2ZUJhY2tlbmQoYmFja2VuZCk7XG4gICAgcmV0dXJuIG1hbmFnZXI7XG59XG5mdW5jdGlvbiBtYWtlU3RvcmVJbnN0YW5jZShkZWJ1Z01vZGUpIHtcbiAgICAvLyBUT0RPOiBpZiB3ZSBldmVyIG1ha2UgYSByZWFjdC1uYXRpdmUgdmVyc2lvbiBvZiB0aGlzLFxuICAgIC8vIHdlJ2xsIG5lZWQgdG8gY29uc2lkZXIgaG93IHRvIHB1bGwgb2ZmIGRldi10b29saW5nXG4gICAgY29uc3QgcmVkdXhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fO1xuICAgIHJldHVybiBjcmVhdGVTdG9yZShyZWR1Y2UsIGRlYnVnTW9kZSAmJiByZWR1eERldlRvb2xzICYmIHJlZHV4RGV2VG9vbHMoe1xuICAgICAgICBuYW1lOiAnZG5kLWNvcmUnLFxuICAgICAgICBpbnN0YW5jZUlkOiAnZG5kLWNvcmUnXG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5sZXQgcmVmQ291bnQgPSAwO1xuY29uc3QgSU5TVEFOQ0VfU1lNID0gU3ltYm9sLmZvcignX19SRUFDVF9ETkRfQ09OVEVYVF9JTlNUQU5DRV9fJyk7XG52YXIgRG5kUHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovIG1lbW8oZnVuY3Rpb24gRG5kUHJvdmlkZXIoX3BhcmFtKSB7XG4gICAgdmFyIHsgY2hpbGRyZW4gIH0gPSBfcGFyYW0sIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1xuICAgICAgICBcImNoaWxkcmVuXCJcbiAgICBdKTtcbiAgICBjb25zdCBbbWFuYWdlciwgaXNHbG9iYWxJbnN0YW5jZV0gPSBnZXREbmRDb250ZXh0VmFsdWUocHJvcHMpIC8vIG1lbW9pemVkIGZyb20gcHJvcHNcbiAgICA7XG4gICAgLyoqXG5cdFx0ICogSWYgdGhlIGdsb2JhbCBjb250ZXh0IHdhcyB1c2VkIHRvIHN0b3JlIHRoZSBETkQgY29udGV4dFxuXHRcdCAqIHRoZW4gd2hlcmUgdGhlcmVzIG5vIG1vcmUgcmVmZXJlbmNlcyB0byBpdCB3ZSBzaG91bGRcblx0XHQgKiBjbGVhbiBpdCB1cCB0byBhdm9pZCBtZW1vcnkgbGVha3Ncblx0XHQgKi8gdXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChpc0dsb2JhbEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gZ2V0R2xvYmFsQ29udGV4dCgpO1xuICAgICAgICAgICAgKytyZWZDb3VudDtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICgtLXJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRbSU5TVEFOQ0VfU1lNXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIGpzeChEbmRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBtYW5hZ2VyLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2V0RG5kQ29udGV4dFZhbHVlKHByb3BzKSB7XG4gICAgaWYgKCdtYW5hZ2VyJyBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0ge1xuICAgICAgICAgICAgZHJhZ0Ryb3BNYW5hZ2VyOiBwcm9wcy5tYW5hZ2VyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYW5hZ2VyLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgbWFuYWdlciA9IGNyZWF0ZVNpbmdsZXRvbkRuZENvbnRleHQocHJvcHMuYmFja2VuZCwgcHJvcHMuY29udGV4dCwgcHJvcHMub3B0aW9ucywgcHJvcHMuZGVidWdNb2RlKTtcbiAgICBjb25zdCBpc0dsb2JhbEluc3RhbmNlID0gIXByb3BzLmNvbnRleHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFuYWdlcixcbiAgICAgICAgaXNHbG9iYWxJbnN0YW5jZVxuICAgIF07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25EbmRDb250ZXh0KGJhY2tlbmQsIGNvbnRleHQgPSBnZXRHbG9iYWxDb250ZXh0KCksIG9wdGlvbnMsIGRlYnVnTW9kZSkge1xuICAgIGNvbnN0IGN0eCA9IGNvbnRleHQ7XG4gICAgaWYgKCFjdHhbSU5TVEFOQ0VfU1lNXSkge1xuICAgICAgICBjdHhbSU5TVEFOQ0VfU1lNXSA9IHtcbiAgICAgICAgICAgIGRyYWdEcm9wTWFuYWdlcjogY3JlYXRlRHJhZ0Ryb3BNYW5hZ2VyKGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGN0eFtJTlNUQU5DRV9TWU1dO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG59XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxuLy8gc3VwcHJlc3MgdGhlIHVzZUxheW91dEVmZmVjdCB3YXJuaW5nIG9uIHNlcnZlciBzaWRlLlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gbW9uaXRvciBUaGUgbW9uaXRvciB0byBjb2xsZWN0IHN0YXRlIGZyb21cbiAqIEBwYXJhbSBjb2xsZWN0IFRoZSBjb2xsZWN0aW5nIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb25VcGRhdGUgQSBtZXRob2QgdG8gaW52b2tlIHdoZW4gdXBkYXRlcyBvY2N1clxuICovIGZ1bmN0aW9uIHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvblVwZGF0ZSkge1xuICAgIGNvbnN0IFtjb2xsZWN0ZWQsIHNldENvbGxlY3RlZF0gPSB1c2VTdGF0ZSgoKT0+Y29sbGVjdChtb25pdG9yKVxuICAgICk7XG4gICAgY29uc3QgdXBkYXRlQ29sbGVjdGVkID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY29sbGVjdChtb25pdG9yKTtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhIGRlZXAtZXF1YWxpdHkgY2hlY2sgYmVjYXVzZSBzb21lIG1vbml0b3ItY29sbGVjdGVkIHZhbHVlc1xuICAgICAgICAvLyBpbmNsdWRlIFhZQ29vcmQgb2JqZWN0cyB0aGF0IG1heSBiZSBlcXVpdmFsZW50LCBidXQgZG8gbm90IGhhdmUgaW5zdGFuY2UgZXF1YWxpdHkuXG4gICAgICAgIGlmICghZmFzdERlZXBFcXVhbChjb2xsZWN0ZWQsIG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHNldENvbGxlY3RlZChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgY29sbGVjdGVkLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBvblVwZGF0ZVxuICAgIF0pO1xuICAgIC8vIHVwZGF0ZSB0aGUgY29sbGVjdGVkIHByb3BlcnRpZXMgYWZ0ZXIgcmVhY3QgcmVuZGVycy5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIFwiRHVzdGJpbiBTdHJlc3MgVGVzdFwiIGZhaWxzIGlmIHRoaXMgaXMgbm90XG4gICAgLy8gZG9uZSB3aGVuIHRoZSBjb21wb25lbnQgdXBkYXRlc1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QodXBkYXRlQ29sbGVjdGVkKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb2xsZWN0ZWQsXG4gICAgICAgIHVwZGF0ZUNvbGxlY3RlZFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHVzZU1vbml0b3JPdXRwdXQobW9uaXRvciwgY29sbGVjdCwgb25Db2xsZWN0KSB7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0LCBvbkNvbGxlY3QpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gc3Vic2NyaWJlVG9Nb25pdG9yU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJJZCA9IG1vbml0b3IuZ2V0SGFuZGxlcklkKCk7XG4gICAgICAgIGlmIChoYW5kbGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkLCB7XG4gICAgICAgICAgICBoYW5kbGVySWRzOiBbXG4gICAgICAgICAgICAgICAgaGFuZGxlcklkXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgbW9uaXRvcixcbiAgICAgICAgdXBkYXRlQ29sbGVjdGVkXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29sbGVjdGVkUHJvcHMoY29sbGVjdG9yLCBtb25pdG9yLCBjb25uZWN0b3IpIHtcbiAgICByZXR1cm4gdXNlTW9uaXRvck91dHB1dChtb25pdG9yLCBjb2xsZWN0b3IgfHwgKCgpPT4oe30pXG4gICAgKSwgKCk9PmNvbm5lY3Rvci5yZWNvbm5lY3QoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHVzZU9wdGlvbmFsRmFjdG9yeShhcmcsIGRlcHMpIHtcbiAgICBjb25zdCBtZW1vRGVwcyA9IFtcbiAgICAgICAgLi4uZGVwcyB8fCBbXVxuICAgIF07XG4gICAgaWYgKGRlcHMgPT0gbnVsbCAmJiB0eXBlb2YgYXJnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1lbW9EZXBzLnB1c2goYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcoKSA6IGFyZztcbiAgICB9LCBtZW1vRGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbm5lY3REcmFnU291cmNlKGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1NvdXJjZSgpXG4gICAgLCBbXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xufVxuZnVuY3Rpb24gdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3Rvcikge1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5jb25uZWN0b3IuaG9va3MuZHJhZ1ByZXZpZXcoKVxuICAgICwgW1xuICAgICAgICBjb25uZWN0b3JcbiAgICBdKTtcbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbmxldCBpc0NhbGxpbmdJc0RyYWdnaW5nID0gZmFsc2U7XG5jbGFzcyBEcmFnU291cmNlTW9uaXRvckltcGwge1xuICAgIHJlY2VpdmVIYW5kbGVySWQoc291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJZCA9IHNvdXJjZUlkO1xuICAgIH1cbiAgICBnZXRIYW5kbGVySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUlkO1xuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyYWcsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJhZygpIGluc2lkZSB5b3VyIGNhbkRyYWcoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcmFnLXNvdXJjZS1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5EcmFnU291cmNlKHRoaXMuc291cmNlSWQpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5EcmFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFpc0NhbGxpbmdJc0RyYWdnaW5nLCAnWW91IG1heSBub3QgY2FsbCBtb25pdG9yLmlzRHJhZ2dpbmcoKSBpbnNpZGUgeW91ciBpc0RyYWdnaW5nKCkgaW1wbGVtZW50YXRpb24uICcgKyAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy9hcGkvZHJhZy1zb3VyY2UtbW9uaXRvcicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKTtcbiAgICB9XG4gICAgaXNPdmVyVGFyZ2V0KHRhcmdldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc092ZXJUYXJnZXQodGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRUYXJnZXRJZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRUYXJnZXRJZHMoKTtcbiAgICB9XG4gICAgaXNTb3VyY2VQdWJsaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc1NvdXJjZVB1YmxpYygpO1xuICAgIH1cbiAgICBnZXRTb3VyY2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5zdWJzY3JpYmVUb09mZnNldENoYW5nZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNhbkRyYWdTb3VyY2Uoc291cmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyYWdTb3VyY2Uoc291cmNlSWQpO1xuICAgIH1cbiAgICBjYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyb3BPblRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGdldEl0ZW1UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbVR5cGUoKTtcbiAgICB9XG4gICAgZ2V0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW0oKTtcbiAgICB9XG4gICAgZ2V0RHJvcFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9XG4gICAgZGlkRHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmRpZERyb3AoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0U291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldENsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlcil7XG4gICAgICAgIHRoaXMuc291cmNlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVybmFsTW9uaXRvciA9IG1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgIH1cbn1cblxubGV0IGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbmNsYXNzIERyb3BUYXJnZXRNb25pdG9ySW1wbCB7XG4gICAgcmVjZWl2ZUhhbmRsZXJJZCh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgfVxuICAgIGdldEhhbmRsZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0SWQ7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UobGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYW5Ecm9wKCkge1xuICAgICAgICAvLyBDdXQgb3V0IGVhcmx5IGlmIHRoZSB0YXJnZXQgaWQgaGFzIG5vdCBiZWVuIHNldC4gVGhpcyBzaG91bGQgcHJldmVudCBlcnJvcnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIHVzZXIgaGFzIGFuIG9sZGVyIHZlcnNpb24gb2YgZG5kLWNvcmUgbGlrZSBpblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvMTMxMFxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQoIWlzQ2FsbGluZ0NhbkRyb3AsICdZb3UgbWF5IG5vdCBjYWxsIG1vbml0b3IuY2FuRHJvcCgpIGluc2lkZSB5b3VyIGNhbkRyb3AoKSBpbXBsZW1lbnRhdGlvbi4gJyArICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzL2FwaS9kcm9wLXRhcmdldC1tb25pdG9yJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5Ecm9wT25UYXJnZXQodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlzQ2FsbGluZ0NhbkRyb3AgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc092ZXIob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNPdmVyVGFyZ2V0KHRoaXMudGFyZ2V0SWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXRJdGVtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfVxuICAgIGdldEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtKCk7XG4gICAgfVxuICAgIGdldERyb3BSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfVxuICAgIGRpZERyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfVxuICAgIGdldFNvdXJjZUNsaWVudE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpO1xuICAgIH1cbiAgICBnZXRDbGllbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRDbGllbnRPZmZzZXQoKTtcbiAgICB9XG4gICAgZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIpe1xuICAgICAgICB0aGlzLnRhcmdldElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbE1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0KHR5cGUsIHRhcmdldCwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHRhcmdldElkID0gcmVnaXN0cnkuYWRkVGFyZ2V0KHR5cGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGFyZ2V0SWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVUYXJnZXQodGFyZ2V0SWQpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlKHR5cGUsIHNvdXJjZSwgbWFuYWdlcikge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIGNvbnN0IHNvdXJjZUlkID0gcmVnaXN0cnkuYWRkU291cmNlKHR5cGUsIHNvdXJjZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlSWQsXG4gICAgICAgICgpPT5yZWdpc3RyeS5yZW1vdmVTb3VyY2Uoc291cmNlSWQpXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gICAgbGV0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcbiAgICBpZiAoY29tcGFyZVJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiAhIWNvbXBhcmVSZXN1bHQ7XG4gICAgfVxuICAgIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCAhb2JqQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gICAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgICBmb3IobGV0IGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4Kyspe1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzQVtpZHhdO1xuICAgICAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSBvYmpCW2tleV07XG4gICAgICAgIGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IGZhbHNlIHx8IGNvbXBhcmVSZXN1bHQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1JlZihvYmopIHtcbiAgICByZXR1cm4oLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY3VycmVudCcpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vIEN1c3RvbSBjb21wb25lbnRzIGNhbiBubyBsb25nZXIgYmUgd3JhcHBlZCBkaXJlY3RseSBpbiBSZWFjdCBEbkQgMi4wXG4gICAgLy8gc28gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIGRlcGVuZCBvbiBmaW5kRE9NTm9kZSgpIGZyb20gcmVhY3QtZG9tLlxuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICd0aGUgY29tcG9uZW50JztcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbmF0aXZlIGVsZW1lbnQgbm9kZXMgY2FuIG5vdyBiZSBwYXNzZWQgdG8gUmVhY3QgRG5EIGNvbm5lY3RvcnMuJyArIGBZb3UgY2FuIGVpdGhlciB3cmFwICR7ZGlzcGxheU5hbWV9IGludG8gYSA8ZGl2Piwgb3IgdHVybiBpdCBpbnRvIGEgYCArICdkcmFnIHNvdXJjZSBvciBhIGRyb3AgdGFyZ2V0IGl0c2VsZi4nKTtcbn1cbmZ1bmN0aW9uIHdyYXBIb29rVG9SZWNvZ25pemVFbGVtZW50KGhvb2spIHtcbiAgICByZXR1cm4gKGVsZW1lbnRPck5vZGUgPSBudWxsLCBvcHRpb25zID0gbnVsbCk9PntcbiAgICAgICAgLy8gV2hlbiBwYXNzZWQgYSBub2RlLCBjYWxsIHRoZSBob29rIHN0cmFpZ2h0IGF3YXkuXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudE9yTm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50T3JOb2RlO1xuICAgICAgICAgICAgaG9vayhub2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbm9kZSBzbyBpdCBjYW4gYmUgY2hhaW5lZCAoZS5nLiB3aGVuIHdpdGhpbiBjYWxsYmFjayByZWZzXG4gICAgICAgICAgICAvLyA8ZGl2IHJlZj17bm9kZSA9PiBjb25uZWN0RHJhZ1NvdXJjZShjb25uZWN0RHJvcFRhcmdldChub2RlKSl9Lz5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhc3NlZCBhIFJlYWN0RWxlbWVudCwgY2xvbmUgaXQgYW5kIGF0dGFjaCB0aGlzIGZ1bmN0aW9uIGFzIGEgcmVmLlxuICAgICAgICAvLyBUaGlzIGhlbHBzIHVzIGFjaGlldmUgYSBuZWF0IEFQSSB3aGVyZSB1c2VyIGRvZXNuJ3QgZXZlbiBrbm93IHRoYXQgcmVmc1xuICAgICAgICAvLyBhcmUgYmVpbmcgdXNlZCB1bmRlciB0aGUgaG9vZC5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRPck5vZGU7XG4gICAgICAgIHRocm93SWZDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAvLyBXaGVuIG5vIG9wdGlvbnMgYXJlIHBhc3NlZCwgdXNlIHRoZSBob29rIGRpcmVjdGx5XG4gICAgICAgIGNvbnN0IHJlZiA9IG9wdGlvbnMgPyAobm9kZSk9Pmhvb2sobm9kZSwgb3B0aW9ucylcbiAgICAgICAgIDogaG9vaztcbiAgICAgICAgcmV0dXJuIGNsb25lV2l0aFJlZihlbGVtZW50LCByZWYpO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwQ29ubmVjdG9ySG9va3MoaG9va3MpIHtcbiAgICBjb25zdCB3cmFwcGVkSG9va3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhob29rcykuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBjb25zdCBob29rID0gaG9va3Nba2V5XTtcbiAgICAgICAgLy8gcmVmIG9iamVjdHMgc2hvdWxkIGJlIHBhc3NlZCBzdHJhaWdodCB0aHJvdWdoIHdpdGhvdXQgd3JhcHBpbmdcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnUmVmJykpIHtcbiAgICAgICAgICAgIHdyYXBwZWRIb29rc1trZXldID0gaG9va3Nba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gd3JhcEhvb2tUb1JlY29nbml6ZUVsZW1lbnQoaG9vayk7XG4gICAgICAgICAgICB3cmFwcGVkSG9va3Nba2V5XSA9ICgpPT53cmFwcGVkSG9va1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rcztcbn1cbmZ1bmN0aW9uIHNldFJlZihyZWYsIG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lV2l0aFJlZihlbGVtZW50LCBuZXdSZWYpIHtcbiAgICBjb25zdCBwcmV2aW91c1JlZiA9IGVsZW1lbnQucmVmO1xuICAgIGludmFyaWFudCh0eXBlb2YgcHJldmlvdXNSZWYgIT09ICdzdHJpbmcnLCAnQ2Fubm90IGNvbm5lY3QgUmVhY3QgRG5EIHRvIGFuIGVsZW1lbnQgd2l0aCBhbiBleGlzdGluZyBzdHJpbmcgcmVmLiAnICsgJ1BsZWFzZSBjb252ZXJ0IGl0IHRvIHVzZSBhIGNhbGxiYWNrIHJlZiBpbnN0ZWFkLCBvciB3cmFwIGl0IGludG8gYSA8c3Bhbj4gb3IgPGRpdj4uICcgKyAnUmVhZCBtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVmcy1hbmQtdGhlLWRvbS5odG1sI2NhbGxiYWNrLXJlZnMnKTtcbiAgICBpZiAoIXByZXZpb3VzUmVmKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcmVmIG9uIHRoZSBlbGVtZW50LCB1c2UgdGhlIG5ldyByZWYgZGlyZWN0bHlcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICByZWY6IG5ld1JlZlxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHJlZjogKG5vZGUpPT57XG4gICAgICAgICAgICAgICAgc2V0UmVmKHByZXZpb3VzUmVmLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZXRSZWYobmV3UmVmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBTb3VyY2VDb25uZWN0b3Ige1xuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXJJZCA9PT0gbmV3SGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBjb25uZWN0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU291cmNlO1xuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTb3VyY2VPcHRpb25zSW50ZXJuYWw7XG4gICAgfVxuICAgIHNldCBkcmFnU291cmNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBkcmFnUHJldmlld09wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3T3B0aW9uc0ludGVybmFsO1xuICAgIH1cbiAgICBzZXQgZHJhZ1ByZXZpZXdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gdGhpcy5yZWNvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RHJhZ1ByZXZpZXcoZGlkQ2hhbmdlKTtcbiAgICB9XG4gICAgcmVjb25uZWN0RHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgZHJhZ1NvdXJjZSA9IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWRDb25uZWN0ZWREcmFnU291cmNlQ2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnU291cmNlT3B0aW9uc0NoYW5nZSgpO1xuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIGRpZENoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBkcmFnU291cmNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1NvdXJjZU9wdGlvbnMgPSB0aGlzLmRyYWdTb3VyY2VPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyYWdTb3VyY2UodGhpcy5oYW5kbGVySWQsIGRyYWdTb3VyY2UsIHRoaXMuZHJhZ1NvdXJjZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWRDaGFuZ2U7XG4gICAgfVxuICAgIHJlY29ubmVjdERyYWdQcmV2aWV3KGZvcmNlRGlkQ2hhbmdlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXcgPSB0aGlzLmRyYWdQcmV2aWV3O1xuICAgICAgICAvLyBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkIHRoZW4gZG9uJ3QgcmVzdWJzY3JpYmVcbiAgICAgICAgY29uc3QgZGlkQ2hhbmdlID0gZm9yY2VEaWRDaGFuZ2UgfHwgdGhpcy5kaWRIYW5kbGVySWRDaGFuZ2UoKSB8fCB0aGlzLmRpZENvbm5lY3RlZERyYWdQcmV2aWV3Q2hhbmdlKCkgfHwgdGhpcy5kaWREcmFnUHJldmlld09wdGlvbnNDaGFuZ2UoKTtcbiAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmFnUHJldmlldykge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXcgPSBkcmFnUHJldmlldztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gZHJhZ1ByZXZpZXc7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMgPSB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSA9IHRoaXMuYmFja2VuZC5jb25uZWN0RHJhZ1ByZXZpZXcodGhpcy5oYW5kbGVySWQsIGRyYWdQcmV2aWV3LCB0aGlzLmRyYWdQcmV2aWV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1NvdXJjZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgIT09IHRoaXMuZHJhZ1NvdXJjZTtcbiAgICB9XG4gICAgZGlkQ29ubmVjdGVkRHJhZ1ByZXZpZXdDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlldyAhPT0gdGhpcy5kcmFnUHJldmlldztcbiAgICB9XG4gICAgZGlkRHJhZ1NvdXJjZU9wdGlvbnNDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2VPcHRpb25zLCB0aGlzLmRyYWdTb3VyY2VPcHRpb25zKTtcbiAgICB9XG4gICAgZGlkRHJhZ1ByZXZpZXdPcHRpb25zQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLmxhc3RDb25uZWN0ZWREcmFnUHJldmlld09wdGlvbnMsIHRoaXMuZHJhZ1ByZXZpZXdPcHRpb25zKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdERyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdTb3VyY2VVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnU291cmNlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZVVuc3Vic2NyaWJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3REcmFnUHJldmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1ByZXZpZXdVbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld1Vuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3VW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1NvdXJjZU5vZGUgfHwgdGhpcy5kcmFnU291cmNlUmVmICYmIHRoaXMuZHJhZ1NvdXJjZVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBnZXQgZHJhZ1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdQcmV2aWV3Tm9kZSB8fCB0aGlzLmRyYWdQcmV2aWV3UmVmICYmIHRoaXMuZHJhZ1ByZXZpZXdSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcmFnU291cmNlKCkge1xuICAgICAgICB0aGlzLmRyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJEcmFnUHJldmlldygpIHtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJhZ1NvdXJjZTogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VPcHRpb25zID0gb3B0aW9ucyB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTb3VyY2VSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NvdXJjZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmFnUHJldmlldzogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWdQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdSZWYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1ByZXZpZXdOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REcmFnUHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBudWxsO1xuICAgICAgICAvLyBUaGUgZHJvcCB0YXJnZXQgbWF5IGVpdGhlciBiZSBhdHRhY2hlZCB2aWEgcmVmIG9yIGNvbm5lY3QgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5kcmFnU291cmNlUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnU291cmNlT3B0aW9uc0ludGVybmFsID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyYWcgcHJldmlldyBtYXkgZWl0aGVyIGJlIGF0dGFjaGVkIHZpYSByZWYgb3IgY29ubmVjdCBmdW5jdGlvblxuICAgICAgICB0aGlzLmRyYWdQcmV2aWV3UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnUHJldmlld09wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcmFnU291cmNlT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyYWdQcmV2aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJhZ1ByZXZpZXdPcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICB9XG59XG5cbmNsYXNzIFRhcmdldENvbm5lY3RvciB7XG4gICAgZ2V0IGNvbm5lY3RUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXQ7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgLy8gaWYgbm90aGluZyBoYXMgY2hhbmdlZCB0aGVuIGRvbid0IHJlc3Vic2NyaWJlXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9IHRoaXMuZGlkSGFuZGxlcklkQ2hhbmdlKCkgfHwgdGhpcy5kaWREcm9wVGFyZ2V0Q2hhbmdlKCkgfHwgdGhpcy5kaWRPcHRpb25zQ2hhbmdlKCk7XG4gICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdERyb3BUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdGhpcy5kcm9wVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWRIYW5kbGVySWQgPSB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMgPSB0aGlzLmRyb3BUYXJnZXRPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB0aGlzLmJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQodGhpcy5oYW5kbGVySWQsIGRyb3BUYXJnZXQsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY2VpdmVIYW5kbGVySWQobmV3SGFuZGxlcklkKSB7XG4gICAgICAgIGlmIChuZXdIYW5kbGVySWQgPT09IHRoaXMuaGFuZGxlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVySWQgPSBuZXdIYW5kbGVySWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgfVxuICAgIGdldCBkcm9wVGFyZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbDtcbiAgICB9XG4gICAgc2V0IGRyb3BUYXJnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0T3B0aW9uc0ludGVybmFsID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGlkSGFuZGxlcklkQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29ubmVjdGVkSGFuZGxlcklkICE9PSB0aGlzLmhhbmRsZXJJZDtcbiAgICB9XG4gICAgZGlkRHJvcFRhcmdldENoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgIT09IHRoaXMuZHJvcFRhcmdldDtcbiAgICB9XG4gICAgZGlkT3B0aW9uc0NoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5sYXN0Q29ubmVjdGVkRHJvcFRhcmdldE9wdGlvbnMsIHRoaXMuZHJvcFRhcmdldE9wdGlvbnMpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0RHJvcFRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRHJvcFRhcmdldCgpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZURyb3BUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRyb3BUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BUYXJnZXROb2RlIHx8IHRoaXMuZHJvcFRhcmdldFJlZiAmJiB0aGlzLmRyb3BUYXJnZXRSZWYuY3VycmVudDtcbiAgICB9XG4gICAgY2xlYXJEcm9wVGFyZ2V0KCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmFja2VuZCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSB3cmFwQ29ubmVjdG9ySG9va3Moe1xuICAgICAgICAgICAgZHJvcFRhcmdldDogKG5vZGUsIG9wdGlvbnMpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyb3BUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wVGFyZ2V0UmVmID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BUYXJnZXROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcklkID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIGRyb3AgdGFyZ2V0IG1heSBlaXRoZXIgYmUgYXR0YWNoZWQgdmlhIHJlZiBvciBjb25uZWN0IGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuZHJvcFRhcmdldFJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldE9wdGlvbnNJbnRlcm5hbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZEhhbmRsZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENvbm5lY3RlZERyb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ZWREcm9wVGFyZ2V0T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgaG9vayB0byByZXRyaWV2ZSB0aGUgRHJhZ0Ryb3BNYW5hZ2VyIGZyb20gQ29udGV4dFxuICovIGZ1bmN0aW9uIHVzZURyYWdEcm9wTWFuYWdlcigpIHtcbiAgICBjb25zdCB7IGRyYWdEcm9wTWFuYWdlciAgfSA9IHVzZUNvbnRleHQoRG5kQ29udGV4dCk7XG4gICAgaW52YXJpYW50KGRyYWdEcm9wTWFuYWdlciAhPSBudWxsLCAnRXhwZWN0ZWQgZHJhZyBkcm9wIGNvbnRleHQnKTtcbiAgICByZXR1cm4gZHJhZ0Ryb3BNYW5hZ2VyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnU291cmNlQ29ubmVjdG9yKGRyYWdTb3VyY2VPcHRpb25zLCBkcmFnUHJldmlld09wdGlvbnMpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgY29ubmVjdG9yID0gdXNlTWVtbygoKT0+bmV3IFNvdXJjZUNvbm5lY3RvcihtYW5hZ2VyLmdldEJhY2tlbmQoKSlcbiAgICAsIFtcbiAgICAgICAgbWFuYWdlclxuICAgIF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgY29ubmVjdG9yLmRyYWdTb3VyY2VPcHRpb25zID0gZHJhZ1NvdXJjZU9wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1NvdXJjZSgpXG4gICAgICAgIDtcbiAgICB9LCBbXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgZHJhZ1NvdXJjZU9wdGlvbnNcbiAgICBdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGNvbm5lY3Rvci5kcmFnUHJldmlld09wdGlvbnMgPSBkcmFnUHJldmlld09wdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCk9PmNvbm5lY3Rvci5kaXNjb25uZWN0RHJhZ1ByZXZpZXcoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGRyYWdQcmV2aWV3T3B0aW9uc1xuICAgIF0pO1xuICAgIHJldHVybiBjb25uZWN0b3I7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2VNb25pdG9yKCkge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKT0+bmV3IERyYWdTb3VyY2VNb25pdG9ySW1wbChtYW5hZ2VyKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG59XG5cbmNsYXNzIERyYWdTb3VyY2VJbXBsIHtcbiAgICBiZWdpbkRyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWMuaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNwZWMuaXRlbTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5pdGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcGVjLml0ZW0obW9uaXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdm9pZCAwID8gcmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgY2FuRHJhZygpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjLmNhbkRyYWcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJhZztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYy5jYW5EcmFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5jYW5EcmFnKG1vbml0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNEcmFnZ2luZyhnbG9iYWxNb25pdG9yLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgY29uc3QgeyBpc0RyYWdnaW5nICB9ID0gc3BlYztcbiAgICAgICAgcmV0dXJuIGlzRHJhZ2dpbmcgPyBpc0RyYWdnaW5nKG1vbml0b3IpIDogdGFyZ2V0ID09PSBnbG9iYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdG9yO1xuICAgICAgICBjb25zdCB7IGVuZCAgfSA9IHNwZWM7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdG9yLnJlY29ubmVjdCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBtb25pdG9yLCBjb25uZWN0b3Ipe1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdTb3VyY2Uoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHVzZU1lbW8oKCk9Pm5ldyBEcmFnU291cmNlSW1wbChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvclxuICAgIF0pO1xuICAgIHVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBoYW5kbGVyLnNwZWMgPSBzcGVjO1xuICAgIH0sIFtcbiAgICAgICAgc3BlY1xuICAgIF0pO1xuICAgIHJldHVybiBoYW5kbGVyO1xufVxuXG5mdW5jdGlvbiB1c2VEcmFnVHlwZShzcGVjKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlYy50eXBlO1xuICAgICAgICBpbnZhcmlhbnQocmVzdWx0ICE9IG51bGwsICdzcGVjLnR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW1xuICAgICAgICBzcGVjXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdGVyZWREcmFnU291cmNlKHNwZWMsIG1vbml0b3IsIGNvbm5lY3Rvcikge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIGNvbnN0IGl0ZW1UeXBlID0gdXNlRHJhZ1R5cGUoc3BlYyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiByZWdpc3RlckRyYWdTb3VyY2UoKSB7XG4gICAgICAgIGlmIChpdGVtVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbaGFuZGxlcklkLCB1bnJlZ2lzdGVyXSA9IHJlZ2lzdGVyU291cmNlKGl0ZW1UeXBlLCBoYW5kbGVyLCBtYW5hZ2VyKTtcbiAgICAgICAgICAgIG1vbml0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlZ2lzdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9LCBbXG4gICAgICAgIG1hbmFnZXIsXG4gICAgICAgIG1vbml0b3IsXG4gICAgICAgIGNvbm5lY3RvcixcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgaXRlbVR5cGVcbiAgICBdKTtcbn1cblxuLyoqXG4gKiB1c2VEcmFnU291cmNlIGhvb2tcbiAqIEBwYXJhbSBzb3VyY2VTcGVjIFRoZSBkcmFnIHNvdXJjZSBzcGVjaWZpY2F0aW9uIChvYmplY3Qgb3IgZnVuY3Rpb24sIGZ1bmN0aW9uIHByZWZlcnJlZClcbiAqIEBwYXJhbSBkZXBzIFRoZSBtZW1vaXphdGlvbiBkZXBzIGFycmF5IHRvIHVzZSB3aGVuIGV2YWx1YXRpbmcgc3BlYyBjaGFuZ2VzXG4gKi8gZnVuY3Rpb24gdXNlRHJhZyhzcGVjQXJnLCBkZXBzKSB7XG4gICAgY29uc3Qgc3BlYyA9IHVzZU9wdGlvbmFsRmFjdG9yeShzcGVjQXJnLCBkZXBzKTtcbiAgICBpbnZhcmlhbnQoIXNwZWMuYmVnaW4sIGB1c2VEcmFnOjpzcGVjLmJlZ2luIHdhcyBkZXByZWNhdGVkIGluIHYxNC4gUmVwbGFjZSBzcGVjLmJlZ2luKCkgd2l0aCBzcGVjLml0ZW0oKS4gKHNlZSBtb3JlIGhlcmUgLSBodHRwczovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MvYXBpL3VzZS1kcmFnKWApO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcmFnU291cmNlTW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyYWdTb3VyY2VDb25uZWN0b3Ioc3BlYy5vcHRpb25zLCBzcGVjLnByZXZpZXdPcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJhZ1NvdXJjZShzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdTb3VyY2UoY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyYWdQcmV2aWV3KGNvbm5lY3RvciksIFxuICAgIF07XG59XG5cbi8qKlxuICogdXNlRHJhZ0xheWVyIEhvb2tcbiAqIEBwYXJhbSBjb2xsZWN0b3IgVGhlIHByb3BlcnR5IGNvbGxlY3RvclxuICovIGZ1bmN0aW9uIHVzZURyYWdMYXllcihjb2xsZWN0KSB7XG4gICAgY29uc3QgZHJhZ0Ryb3BNYW5hZ2VyID0gdXNlRHJhZ0Ryb3BNYW5hZ2VyKCk7XG4gICAgY29uc3QgbW9uaXRvciA9IGRyYWdEcm9wTWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgY29uc3QgW2NvbGxlY3RlZCwgdXBkYXRlQ29sbGVjdGVkXSA9IHVzZUNvbGxlY3Rvcihtb25pdG9yLCBjb2xsZWN0KTtcbiAgICB1c2VFZmZlY3QoKCk9Pm1vbml0b3Iuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgdXNlRWZmZWN0KCgpPT5tb25pdG9yLnN1YnNjcmliZVRvU3RhdGVDaGFuZ2UodXBkYXRlQ29sbGVjdGVkKVxuICAgICk7XG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcbn1cblxuZnVuY3Rpb24gdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PmNvbm5lY3Rvci5ob29rcy5kcm9wVGFyZ2V0KClcbiAgICAsIFtcbiAgICAgICAgY29ubmVjdG9yXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHVzZURyb3BUYXJnZXRDb25uZWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG1hbmFnZXIgPSB1c2VEcmFnRHJvcE1hbmFnZXIoKTtcbiAgICBjb25zdCBjb25uZWN0b3IgPSB1c2VNZW1vKCgpPT5uZXcgVGFyZ2V0Q29ubmVjdG9yKG1hbmFnZXIuZ2V0QmFja2VuZCgpKVxuICAgICwgW1xuICAgICAgICBtYW5hZ2VyXG4gICAgXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBjb25uZWN0b3IuZHJvcFRhcmdldE9wdGlvbnMgPSBvcHRpb25zIHx8IG51bGw7XG4gICAgICAgIGNvbm5lY3Rvci5yZWNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuICgpPT5jb25uZWN0b3IuZGlzY29ubmVjdERyb3BUYXJnZXQoKVxuICAgICAgICA7XG4gICAgfSwgW1xuICAgICAgICBvcHRpb25zXG4gICAgXSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rvcjtcbn1cblxuZnVuY3Rpb24gdXNlRHJvcFRhcmdldE1vbml0b3IoKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpPT5uZXcgRHJvcFRhcmdldE1vbml0b3JJbXBsKG1hbmFnZXIpXG4gICAgLCBbXG4gICAgICAgIG1hbmFnZXJcbiAgICBdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB1dGlsaXR5IGhvb2sgdG8gZ2V0IGFuIGFycmF5LXZlcnNpb24gb2Ygc3BlYy5hY2NlcHQuXG4gKiBUaGUgbWFpbiB1dGlsaXR5IGhlcmUgaXMgdGhhdCB3ZSBhcmVuJ3QgY3JlYXRpbmcgYSBuZXcgYXJyYXkgb24gZXZlcnkgcmVuZGVyIGlmIGEgbm9uLWFycmF5IHNwZWMuYWNjZXB0IGlzIHBhc3NlZCBpbi5cbiAqIEBwYXJhbSBzcGVjXG4gKi8gZnVuY3Rpb24gdXNlQWNjZXB0KHNwZWMpIHtcbiAgICBjb25zdCB7IGFjY2VwdCAgfSA9IHNwZWM7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCk9PntcbiAgICAgICAgaW52YXJpYW50KHNwZWMuYWNjZXB0ICE9IG51bGwsICdhY2NlcHQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFjY2VwdCkgPyBhY2NlcHQgOiBbXG4gICAgICAgICAgICBhY2NlcHRcbiAgICAgICAgXTtcbiAgICB9LCBbXG4gICAgICAgIGFjY2VwdFxuICAgIF0pO1xufVxuXG5jbGFzcyBEcm9wVGFyZ2V0SW1wbCB7XG4gICAgY2FuRHJvcCgpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJvcCA/IHNwZWMuY2FuRHJvcChtb25pdG9yLmdldEl0ZW0oKSwgbW9uaXRvcikgOiB0cnVlO1xuICAgIH1cbiAgICBob3ZlcigpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHRoaXMuc3BlYztcbiAgICAgICAgY29uc3QgbW9uaXRvciA9IHRoaXMubW9uaXRvcjtcbiAgICAgICAgaWYgKHNwZWMuaG92ZXIpIHtcbiAgICAgICAgICAgIHNwZWMuaG92ZXIobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIGNvbnN0IHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGNvbnN0IG1vbml0b3IgPSB0aGlzLm1vbml0b3I7XG4gICAgICAgIGlmIChzcGVjLmRyb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjLmRyb3AobW9uaXRvci5nZXRJdGVtKCksIG1vbml0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3BlYywgbW9uaXRvcil7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpIHtcbiAgICBjb25zdCBkcm9wVGFyZ2V0ID0gdXNlTWVtbygoKT0+bmV3IERyb3BUYXJnZXRJbXBsKHNwZWMsIG1vbml0b3IpXG4gICAgLCBbXG4gICAgICAgIG1vbml0b3JcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgZHJvcFRhcmdldC5zcGVjID0gc3BlYztcbiAgICB9LCBbXG4gICAgICAgIHNwZWNcbiAgICBdKTtcbiAgICByZXR1cm4gZHJvcFRhcmdldDtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0ZXJlZERyb3BUYXJnZXQoc3BlYywgbW9uaXRvciwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IHVzZURyYWdEcm9wTWFuYWdlcigpO1xuICAgIGNvbnN0IGRyb3BUYXJnZXQgPSB1c2VEcm9wVGFyZ2V0KHNwZWMsIG1vbml0b3IpO1xuICAgIGNvbnN0IGFjY2VwdCA9IHVzZUFjY2VwdChzcGVjKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHJlZ2lzdGVyRHJvcFRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgW2hhbmRsZXJJZCwgdW5yZWdpc3Rlcl0gPSByZWdpc3RlclRhcmdldChhY2NlcHQsIGRyb3BUYXJnZXQsIG1hbmFnZXIpO1xuICAgICAgICBtb25pdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgY29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKTtcbiAgICAgICAgcmV0dXJuIHVucmVnaXN0ZXI7XG4gICAgfSwgW1xuICAgICAgICBtYW5hZ2VyLFxuICAgICAgICBtb25pdG9yLFxuICAgICAgICBkcm9wVGFyZ2V0LFxuICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgIGFjY2VwdC5tYXAoKGEpPT5hLnRvU3RyaW5nKClcbiAgICAgICAgKS5qb2luKCd8JyksIFxuICAgIF0pO1xufVxuXG4vKipcbiAqIHVzZURyb3BUYXJnZXQgSG9va1xuICogQHBhcmFtIHNwZWMgVGhlIGRyb3AgdGFyZ2V0IHNwZWNpZmljYXRpb24gKG9iamVjdCBvciBmdW5jdGlvbiwgZnVuY3Rpb24gcHJlZmVycmVkKVxuICogQHBhcmFtIGRlcHMgVGhlIG1lbW9pemF0aW9uIGRlcHMgYXJyYXkgdG8gdXNlIHdoZW4gZXZhbHVhdGluZyBzcGVjIGNoYW5nZXNcbiAqLyBmdW5jdGlvbiB1c2VEcm9wKHNwZWNBcmcsIGRlcHMpIHtcbiAgICBjb25zdCBzcGVjID0gdXNlT3B0aW9uYWxGYWN0b3J5KHNwZWNBcmcsIGRlcHMpO1xuICAgIGNvbnN0IG1vbml0b3IgPSB1c2VEcm9wVGFyZ2V0TW9uaXRvcigpO1xuICAgIGNvbnN0IGNvbm5lY3RvciA9IHVzZURyb3BUYXJnZXRDb25uZWN0b3Ioc3BlYy5vcHRpb25zKTtcbiAgICB1c2VSZWdpc3RlcmVkRHJvcFRhcmdldChzcGVjLCBtb25pdG9yLCBjb25uZWN0b3IpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHVzZUNvbGxlY3RlZFByb3BzKHNwZWMuY29sbGVjdCwgbW9uaXRvciwgY29ubmVjdG9yKSxcbiAgICAgICAgdXNlQ29ubmVjdERyb3BUYXJnZXQoY29ubmVjdG9yKSwgXG4gICAgXTtcbn1cblxuLy8gY2hlYXAgbG9kYXNoIHJlcGxhY2VtZW50c1xuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IG1lbW9pemVkID0gKCk9PntcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG59XG4vKipcbiAqIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIF8ud2l0aG91dFxuICovIGZ1bmN0aW9uIHdpdGhvdXQoaXRlbXMsIGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChpKT0+aSAhPT0gaXRlbVxuICAgICk7XG59XG5mdW5jdGlvbiB1bmlvbihpdGVtc0EsIGl0ZW1zQikge1xuICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnNlcnRJdGVtID0gKGl0ZW0pPT5zZXQuYWRkKGl0ZW0pXG4gICAgO1xuICAgIGl0ZW1zQS5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGl0ZW1zQi5mb3JFYWNoKGluc2VydEl0ZW0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHNldC5mb3JFYWNoKChrZXkpPT5yZXN1bHQucHVzaChrZXkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jbGFzcyBFbnRlckxlYXZlQ291bnRlciB7XG4gICAgZW50ZXIoZW50ZXJpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNOb2RlRW50ZXJlZCA9IChub2RlKT0+dGhpcy5pc05vZGVJbkRvY3VtZW50KG5vZGUpICYmICghbm9kZS5jb250YWlucyB8fCBub2RlLmNvbnRhaW5zKGVudGVyaW5nTm9kZSkpXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gdW5pb24odGhpcy5lbnRlcmVkLmZpbHRlcihpc05vZGVFbnRlcmVkKSwgW1xuICAgICAgICAgICAgZW50ZXJpbmdOb2RlXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNMZW5ndGggPT09IDAgJiYgdGhpcy5lbnRlcmVkLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGxlYXZlKGxlYXZpbmdOb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gdGhpcy5lbnRlcmVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gd2l0aG91dCh0aGlzLmVudGVyZWQuZmlsdGVyKHRoaXMuaXNOb2RlSW5Eb2N1bWVudCksIGxlYXZpbmdOb2RlKTtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTGVuZ3RoID4gMCAmJiB0aGlzLmVudGVyZWQubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5lbnRlcmVkID0gW107XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzTm9kZUluRG9jdW1lbnQpe1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pc05vZGVJbkRvY3VtZW50ID0gaXNOb2RlSW5Eb2N1bWVudDtcbiAgICB9XG59XG5cbmNsYXNzIE5hdGl2ZURyYWdTb3VyY2Uge1xuICAgIGluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllcykuZm9yRWFjaCgocHJvcGVydHkpPT57XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pdGVtLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQnJvd3NlciBkb2Vzbid0IGFsbG93IHJlYWRpbmcgXCIke3Byb3BlcnR5fVwiIHVudGlsIHRoZSBkcm9wIGV2ZW50LmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmV4cG9zZVByb3BlcnRpZXMpLmZvckVhY2goKHByb3BlcnR5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5Rm4gPSB0aGlzLmNvbmZpZy5leHBvc2VQcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlGbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNbcHJvcGVydHldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3BlcnR5Rm4oZGF0YVRyYW5zZmVyLCB0aGlzLmNvbmZpZy5tYXRjaGVzVHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5pdGVtLCBuZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVnaW5EcmFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgIH1cbiAgICBpc0RyYWdnaW5nKG1vbml0b3IsIGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlID09PSBtb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgfVxuICAgIGVuZERyYWcoKSB7XG4gICAgLy8gZW1wdHlcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuaXRlbSA9IHt9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemVFeHBvc2VkUHJvcGVydGllcygpO1xuICAgIH1cbn1cblxuY29uc3QgRklMRSA9ICdfX05BVElWRV9GSUxFX18nO1xuY29uc3QgVVJMID0gJ19fTkFUSVZFX1VSTF9fJztcbmNvbnN0IFRFWFQgPSAnX19OQVRJVkVfVEVYVF9fJztcbmNvbnN0IEhUTUwgPSAnX19OQVRJVkVfSFRNTF9fJztcblxudmFyIE5hdGl2ZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBGSUxFOiBGSUxFLFxuICAgIEhUTUw6IEhUTUwsXG4gICAgVEVYVDogVEVYVCxcbiAgICBVUkw6IFVSTFxufSk7XG5cbmZ1bmN0aW9uIGdldERhdGFGcm9tRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgdHlwZXNUb1RyeSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHlwZXNUb1RyeS5yZWR1Y2UoKHJlc3VsdFNvRmFyLCB0eXBlVG9UcnkpPT5yZXN1bHRTb0ZhciB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSh0eXBlVG9UcnkpXG4gICAgLCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBuYXRpdmVUeXBlc0NvbmZpZyA9IHtcbiAgICBbRklMRV06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgZmlsZXM6IChkYXRhVHJhbnNmZXIpPT5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIuZmlsZXMpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBpdGVtczogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2Zlci5pdGVtc1xuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0ZpbGVzJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICBbSFRNTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgaHRtbDogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKVxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgZGF0YVRyYW5zZmVyOiAoZGF0YVRyYW5zZmVyKT0+ZGF0YVRyYW5zZmVyXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogW1xuICAgICAgICAgICAgJ0h0bWwnLFxuICAgICAgICAgICAgJ3RleHQvaHRtbCdcbiAgICAgICAgXVxuICAgIH0sXG4gICAgW1VSTF06IHtcbiAgICAgICAgZXhwb3NlUHJvcGVydGllczoge1xuICAgICAgICAgICAgdXJsczogKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzKT0+Z2V0RGF0YUZyb21EYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMsICcnKS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGRhdGFUcmFuc2ZlcjogKGRhdGFUcmFuc2Zlcik9PmRhdGFUcmFuc2ZlclxuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVzVHlwZXM6IFtcbiAgICAgICAgICAgICdVcmwnLFxuICAgICAgICAgICAgJ3RleHQvdXJpLWxpc3QnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIFtURVhUXToge1xuICAgICAgICBleHBvc2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB0ZXh0OiAoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMpPT5nZXREYXRhRnJvbURhdGFUcmFuc2ZlcihkYXRhVHJhbnNmZXIsIG1hdGNoZXNUeXBlcywgJycpXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBkYXRhVHJhbnNmZXI6IChkYXRhVHJhbnNmZXIpPT5kYXRhVHJhbnNmZXJcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1R5cGVzOiBbXG4gICAgICAgICAgICAnVGV4dCcsXG4gICAgICAgICAgICAndGV4dC9wbGFpbidcbiAgICAgICAgXVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZURyYWdTb3VyY2UodHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgY29uc3QgY29uZmlnID0gbmF0aXZlVHlwZXNDb25maWdbdHlwZV07XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYXRpdmUgdHlwZSAke3R5cGV9IGhhcyBubyBjb25maWd1cmF0aW9uYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBOYXRpdmVEcmFnU291cmNlKGNvbmZpZyk7XG4gICAgcmVzdWx0LmxvYWREYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpIHtcbiAgICBpZiAoIWRhdGFUcmFuc2Zlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YVRyYW5zZmVyVHlwZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhVHJhbnNmZXIudHlwZXMgfHwgW10pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhuYXRpdmVUeXBlc0NvbmZpZykuZmlsdGVyKChuYXRpdmVJdGVtVHlwZSk9PntcbiAgICAgICAgY29uc3QgdHlwZUNvbmZpZyA9IG5hdGl2ZVR5cGVzQ29uZmlnW25hdGl2ZUl0ZW1UeXBlXTtcbiAgICAgICAgaWYgKCEodHlwZUNvbmZpZyA9PT0gbnVsbCB8fCB0eXBlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlQ29uZmlnLm1hdGNoZXNUeXBlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZUNvbmZpZy5tYXRjaGVzVHlwZXMuc29tZSgodCk9PmRhdGFUcmFuc2ZlclR5cGVzLmluZGV4T2YodCkgPiAtMVxuICAgICAgICApO1xuICAgIH0pWzBdIHx8IG51bGw7XG59XG5cbmNvbnN0IGlzRmlyZWZveCA9IG1lbW9pemUoKCk9Pi9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuKTtcbmNvbnN0IGlzU2FmYXJpID0gbWVtb2l6ZSgoKT0+Qm9vbGVhbih3aW5kb3cuc2FmYXJpKVxuKTtcblxuY2xhc3MgTW9ub3RvbmljSW50ZXJwb2xhbnQge1xuICAgIGludGVycG9sYXRlKHgpIHtcbiAgICAgICAgY29uc3QgeyB4cyAsIHlzICwgYzFzICwgYzJzICwgYzNzICB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIHJpZ2h0bW9zdCBwb2ludCBpbiB0aGUgZGF0YXNldCBzaG91bGQgZ2l2ZSBhbiBleGFjdCByZXN1bHRcbiAgICAgICAgbGV0IGkgPSB4cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB5c1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBpbnRlcnZhbCB4IGlzIGluLCByZXR1cm5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgeSBpZiB4IGlzIG9uZSBvZiB0aGUgb3JpZ2luYWwgeHNcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gYzNzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBtaWQ7XG4gICAgICAgIHdoaWxlKGxvdyA8PSBoaWdoKXtcbiAgICAgICAgICAgIG1pZCA9IE1hdGguZmxvb3IoMC41ICogKGxvdyArIGhpZ2gpKTtcbiAgICAgICAgICAgIGNvbnN0IHhIZXJlID0geHNbbWlkXTtcbiAgICAgICAgICAgIGlmICh4SGVyZSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4SGVyZSA+IHgpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlzW21pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSA9IE1hdGgubWF4KDAsIGhpZ2gpO1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICBjb25zdCBkaWZmID0geCAtIHhzW2ldO1xuICAgICAgICBjb25zdCBkaWZmU3EgPSBkaWZmICogZGlmZjtcbiAgICAgICAgcmV0dXJuIHlzW2ldICsgYzFzW2ldICogZGlmZiArIGMyc1tpXSAqIGRpZmZTcSArIGMzc1tpXSAqIGRpZmYgKiBkaWZmU3E7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHhzLCB5cyl7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoICB9ID0geHM7XG4gICAgICAgIC8vIFJlYXJyYW5nZSB4cyBhbmQgeXMgc28gdGhhdCB4cyBpcyBzb3J0ZWRcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ZXMuc29ydCgoYSwgYik9PnhzW2FdIDwgeHNbYl0gPyAtMSA6IDFcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZHhzID0gW107XG4gICAgICAgIGNvbnN0IG1zID0gW107XG4gICAgICAgIGxldCBkeDtcbiAgICAgICAgbGV0IGR5O1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCBsZW5ndGggLSAxOyBpMSsrKXtcbiAgICAgICAgICAgIGR4ID0geHNbaTEgKyAxXSAtIHhzW2kxXTtcbiAgICAgICAgICAgIGR5ID0geXNbaTEgKyAxXSAtIHlzW2kxXTtcbiAgICAgICAgICAgIGR4cy5wdXNoKGR4KTtcbiAgICAgICAgICAgIG1zLnB1c2goZHkgLyBkeCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0xIGNvZWZmaWNpZW50c1xuICAgICAgICBjb25zdCBjMXMgPSBbXG4gICAgICAgICAgICBtc1swXVxuICAgICAgICBdO1xuICAgICAgICBmb3IobGV0IGkyID0gMDsgaTIgPCBkeHMubGVuZ3RoIC0gMTsgaTIrKyl7XG4gICAgICAgICAgICBjb25zdCBtMiA9IG1zW2kyXTtcbiAgICAgICAgICAgIGNvbnN0IG1OZXh0ID0gbXNbaTIgKyAxXTtcbiAgICAgICAgICAgIGlmIChtMiAqIG1OZXh0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBjMXMucHVzaCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSBkeHNbaTJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR4TmV4dCA9IGR4c1tpMiArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IGR4ICsgZHhOZXh0O1xuICAgICAgICAgICAgICAgIGMxcy5wdXNoKDMgKiBjb21tb24gLyAoKGNvbW1vbiArIGR4TmV4dCkgLyBtMiArIChjb21tb24gKyBkeCkgLyBtTmV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMxcy5wdXNoKG1zW21zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0yIGFuZCBkZWdyZWUtMyBjb2VmZmljaWVudHNcbiAgICAgICAgY29uc3QgYzJzID0gW107XG4gICAgICAgIGNvbnN0IGMzcyA9IFtdO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgZm9yKGxldCBpMyA9IDA7IGkzIDwgYzFzLmxlbmd0aCAtIDE7IGkzKyspe1xuICAgICAgICAgICAgbSA9IG1zW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gYzFzW2kzXTtcbiAgICAgICAgICAgIGNvbnN0IGludkR4ID0gMSAvIGR4c1tpM107XG4gICAgICAgICAgICBjb25zdCBjb21tb24gPSBjMSArIGMxc1tpMyArIDFdIC0gbSAtIG07XG4gICAgICAgICAgICBjMnMucHVzaCgobSAtIGMxIC0gY29tbW9uKSAqIGludkR4KTtcbiAgICAgICAgICAgIGMzcy5wdXNoKGNvbW1vbiAqIGludkR4ICogaW52RHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHMgPSB4cztcbiAgICAgICAgdGhpcy55cyA9IHlzO1xuICAgICAgICB0aGlzLmMxcyA9IGMxcztcbiAgICAgICAgdGhpcy5jMnMgPSBjMnM7XG4gICAgICAgIHRoaXMuYzNzID0gYzNzO1xuICAgIH1cbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFJDEgPSAxO1xuZnVuY3Rpb24gZ2V0Tm9kZUNsaWVudE9mZnNldCQxKG5vZGUpIHtcbiAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSQxID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHRvcCAsIGxlZnQgIH0gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3BcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICB5OiBlLmNsaWVudFlcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNJbWFnZU5vZGUobm9kZSkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdJTUcnICYmIChpc0ZpcmVmb3goKSB8fCAhKChyZWYgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmNvbnRhaW5zKG5vZGUpKSk7XG59XG5mdW5jdGlvbiBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpIHtcbiAgICBsZXQgZHJhZ1ByZXZpZXdXaWR0aCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy53aWR0aCA6IHNvdXJjZVdpZHRoO1xuICAgIGxldCBkcmFnUHJldmlld0hlaWdodCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy5oZWlnaHQgOiBzb3VyY2VIZWlnaHQ7XG4gICAgLy8gV29yayBhcm91bmQgQDJ4IGNvb3JkaW5hdGUgZGlzY3JlcGFuY2llcyBpbiBicm93c2Vyc1xuICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgZHJhZ1ByZXZpZXdIZWlnaHQgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGggLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRyYWdQcmV2aWV3V2lkdGgsXG4gICAgICAgIGRyYWdQcmV2aWV3SGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERyYWdQcmV2aWV3T2Zmc2V0KHNvdXJjZU5vZGUsIGRyYWdQcmV2aWV3LCBjbGllbnRPZmZzZXQsIGFuY2hvclBvaW50LCBvZmZzZXRQb2ludCkge1xuICAgIC8vIFRoZSBicm93c2VycyB3aWxsIHVzZSB0aGUgaW1hZ2UgaW50cmluc2ljIHNpemUgdW5kZXIgZGlmZmVyZW50IGNvbmRpdGlvbnMuXG4gICAgLy8gRmlyZWZveCBvbmx5IGNhcmVzIGlmIGl0J3MgYW4gaW1hZ2UsIGJ1dCBXZWJLaXQgYWxzbyB3YW50cyBpdCB0byBiZSBkZXRhY2hlZC5cbiAgICBjb25zdCBpc0ltYWdlID0gaXNJbWFnZU5vZGUoZHJhZ1ByZXZpZXcpO1xuICAgIGNvbnN0IGRyYWdQcmV2aWV3Tm9kZSA9IGlzSW1hZ2UgPyBzb3VyY2VOb2RlIDogZHJhZ1ByZXZpZXc7XG4gICAgY29uc3QgZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudCA9IGdldE5vZGVDbGllbnRPZmZzZXQkMShkcmFnUHJldmlld05vZGUpO1xuICAgIGNvbnN0IG9mZnNldEZyb21EcmFnUHJldmlldyA9IHtcbiAgICAgICAgeDogY2xpZW50T2Zmc2V0LnggLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LngsXG4gICAgICAgIHk6IGNsaWVudE9mZnNldC55IC0gZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudC55XG4gICAgfTtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiBzb3VyY2VXaWR0aCAsIG9mZnNldEhlaWdodDogc291cmNlSGVpZ2h0ICB9ID0gc291cmNlTm9kZTtcbiAgICBjb25zdCB7IGFuY2hvclggLCBhbmNob3JZICB9ID0gYW5jaG9yUG9pbnQ7XG4gICAgY29uc3QgeyBkcmFnUHJldmlld1dpZHRoICwgZHJhZ1ByZXZpZXdIZWlnaHQgIH0gPSBnZXREcmFnUHJldmlld1NpemUoaXNJbWFnZSwgZHJhZ1ByZXZpZXcsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVlPZmZzZXQgPSAoKT0+e1xuICAgICAgICBjb25zdCBpbnRlcnBvbGFudFkgPSBuZXcgTW9ub3RvbmljSW50ZXJwb2xhbnQoW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgdG9wXG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSxcbiAgICAgICAgICAgIC8vIEFsaWduIGF0IHRoZSBjZW50ZXJcbiAgICAgICAgICAgIChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LnkgKyBkcmFnUHJldmlld0hlaWdodCAtIHNvdXJjZUhlaWdodCwgXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgeSA9IGludGVycG9sYW50WS5pbnRlcnBvbGF0ZShhbmNob3JZKTtcbiAgICAgICAgLy8gV29yayBhcm91bmQgU2FmYXJpIDggcG9zaXRpb25pbmcgYnVnXG4gICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gd2FpdCBmb3IgQDN4IHRvIHNlZSBpZiB0aGlzIGlzIGVudGlyZWx5IGNvcnJlY3RcbiAgICAgICAgICAgIHkgKz0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSkgKiBkcmFnUHJldmlld0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbGN1bGF0ZVhPZmZzZXQgPSAoKT0+e1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gYW5jaG9yIHBvaW50XG4gICAgICAgIC8vIElmIHlvdSBrbm93IGEgc2ltcGxlciB3YXkgdG8gZG8gdGhpcywgbGV0IG1lIGtub3dcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhbnRYID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50KFtcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAxXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIG9mZnNldEZyb21EcmFnUHJldmlldy54LFxuICAgICAgICAgICAgLy8gQWxpZ24gYXQgdGhlIGNlbnRlclxuICAgICAgICAgICAgKG9mZnNldEZyb21EcmFnUHJldmlldy54IC8gc291cmNlV2lkdGgpICogZHJhZ1ByZXZpZXdXaWR0aCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueCArIGRyYWdQcmV2aWV3V2lkdGggLSBzb3VyY2VXaWR0aCwgXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhbnRYLmludGVycG9sYXRlKGFuY2hvclgpO1xuICAgIH07XG4gICAgLy8gRm9yY2Ugb2Zmc2V0cyBpZiBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMuXG4gICAgY29uc3QgeyBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IG9mZnNldFBvaW50O1xuICAgIGNvbnN0IGlzTWFudWFsT2Zmc2V0WCA9IG9mZnNldFggPT09IDAgfHwgb2Zmc2V0WDtcbiAgICBjb25zdCBpc01hbnVhbE9mZnNldFkgPSBvZmZzZXRZID09PSAwIHx8IG9mZnNldFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNNYW51YWxPZmZzZXRYID8gb2Zmc2V0WCA6IGNhbGN1bGF0ZVhPZmZzZXQoKSxcbiAgICAgICAgeTogaXNNYW51YWxPZmZzZXRZID8gb2Zmc2V0WSA6IGNhbGN1bGF0ZVlPZmZzZXQoKVxuICAgIH07XG59XG5cbmxldCBPcHRpb25zUmVhZGVyJDEgPSBjbGFzcyBPcHRpb25zUmVhZGVyIHtcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxDb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmdsb2JhbENvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxDb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2luZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5vcHRpb25zQXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYucm9vdEVsZW1lbnQpIHx8IHRoaXMud2luZG93O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxDb250ZXh0LCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5vd25lckRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcbiAgICAgICAgdGhpcy5vcHRpb25zQXJncyA9IG9wdGlvbnM7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgICAgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNsYXNzIEhUTUw1QmFja2VuZEltcGwge1xuICAgIC8qKlxuXHQgKiBHZW5lcmF0ZSBwcm9maWxpbmcgc3RhdGlzdGljcyBmb3IgdGhlIEhUTUw1QmFja2VuZC5cblx0ICovIHByb2ZpbGUoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZXM6IHRoaXMuc291cmNlUHJldmlld05vZGVzLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnM6IHRoaXMuc291cmNlUHJldmlld05vZGVPcHRpb25zLnNpemUsXG4gICAgICAgICAgICBzb3VyY2VOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5zaXplLFxuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIGRyYWdTdGFydFNvdXJjZUlkczogKChyZWYgPSB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgZHJvcFRhcmdldElkczogdGhpcy5kcm9wVGFyZ2V0SWRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdFbnRlclRhcmdldElkczogdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMubGVuZ3RoLFxuICAgICAgICAgICAgZHJhZ092ZXJUYXJnZXRJZHM6ICgocmVmMSA9IHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpID09PSBudWxsIHx8IHJlZjEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjEubGVuZ3RoKSB8fCAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmb3IgdGVzdFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud2luZG93O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBHZXQgdGhlIHJvb3QgZWxlbWVudCB0byB1c2UgZm9yIGV2ZW50IHN1YnNjcmlwdGlvbnNcblx0ICovIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICB9XG4gICAgc2V0dXAoKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIHR3byBIVE1MNSBiYWNrZW5kcyBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycyhyb290KTtcbiAgICB9XG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5fX2lzUmVhY3REbmRCYWNrZW5kU2V0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJvb3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICBpZiAodGhpcy5hc3luY0VuZERyYWdGcmFtZUlkKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgKHJlZiA9IHRoaXMud2luZG93KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFzeW5jRW5kRHJhZ0ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJhZ1NvdXJjZShzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZU5vZGVzLnNldChzb3VyY2VJZCwgbm9kZSk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMuc2V0KHNvdXJjZUlkLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGUpPT50aGlzLmhhbmRsZURyYWdTdGFydChlLCBzb3VyY2VJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+dGhpcy5oYW5kbGVTZWxlY3RTdGFydChlKVxuICAgICAgICA7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAndHJ1ZScpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBoYW5kbGVTZWxlY3RTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGhhbmRsZVNlbGVjdFN0YXJ0KTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCAnZmFsc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29ubmVjdERyb3BUYXJnZXQodGFyZ2V0SWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gKGUpPT50aGlzLmhhbmRsZURyYWdFbnRlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKT0+dGhpcy5oYW5kbGVEcmFnT3ZlcihlLCB0YXJnZXRJZClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBoYW5kbGVEcm9wID0gKGUpPT50aGlzLmhhbmRsZURyb3AoZSwgdGFyZ2V0SWQpXG4gICAgICAgIDtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVEcmFnRW50ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBoYW5kbGVEcm9wKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGhhbmRsZURyYWdFbnRlcik7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCkge1xuICAgICAgICAvLyBTU1IgRml4IChodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9wdWxsLzgxM1xuICAgICAgICBpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdFbnRlckNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgdGhpcy5oYW5kbGVUb3BEcmFnTGVhdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVUb3BEcmFnT3Zlcik7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3ApO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUsIHRydWUpO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQpIHtcbiAgICAgICAgLy8gU1NSIEZpeCAoaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC84MTNcbiAgICAgICAgaWYgKCF0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcERyYWdTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlVG9wRHJhZ0VuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5oYW5kbGVUb3BEcm9wKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3BDYXB0dXJlLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VJZCA9IHRoaXMubW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlT3B0aW9ucyA9IHRoaXMuc291cmNlTm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgZHJvcEVmZmVjdDogdGhpcy5hbHRLZXlQcmVzc2VkID8gJ2NvcHknIDogJ21vdmUnXG4gICAgICAgIH0sIHNvdXJjZU5vZGVPcHRpb25zIHx8IHt9KTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudERyb3BFZmZlY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgIC8vIEl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVmYXVsdCB0byAnY29weScgZm9yIG5hdGl2ZSByZXNvdXJjZXNcbiAgICAgICAgICAgIHJldHVybiAnY29weSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zKCkuZHJvcEVmZmVjdDtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSB0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKTtcbiAgICAgICAgY29uc3Qgc291cmNlUHJldmlld05vZGVPcHRpb25zID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgYW5jaG9yWDogMC41LFxuICAgICAgICAgICAgYW5jaG9yWTogMC41LFxuICAgICAgICAgICAgY2FwdHVyZURyYWdnaW5nU3RhdGU6IGZhbHNlXG4gICAgICAgIH0sIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyB8fCB7fSk7XG4gICAgfVxuICAgIGlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkge1xuICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHRoaXMubW9uaXRvci5nZXRJdGVtVHlwZSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoTmF0aXZlVHlwZXMpLnNvbWUoKGtleSk9Pk5hdGl2ZVR5cGVzW2tleV0gPT09IGl0ZW1UeXBlXG4gICAgICAgICk7XG4gICAgfVxuICAgIGJlZ2luRHJhZ05hdGl2ZUl0ZW0odHlwZSwgZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlU291cmNlID0gY3JlYXRlTmF0aXZlRHJhZ1NvdXJjZSh0eXBlLCBkYXRhVHJhbnNmZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUgPSB0aGlzLnJlZ2lzdHJ5LmFkZFNvdXJjZSh0eXBlLCB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpO1xuICAgICAgICB0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKFtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIEEgdGltZW91dCBvZiA+IDAgaXMgbmVjZXNzYXJ5IHRvIHJlc29sdmUgRmlyZWZveCBpc3N1ZSByZWZlcmVuY2VkXG4gICAgICAgIC8vIFNlZTpcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL3B1bGwvOTI4XG4gICAgICAgIC8vICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvODY5XG4gICAgICAgIGNvbnN0IE1PVVNFX01PVkVfVElNRU9VVCA9IDEwMDA7XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIG1vdXNlIGV2ZW50IGluIHRoZSBtaWRkbGUgb2YgYSBkcmFnZ2luZyBvcGVyYXRpb25cbiAgICAgICAgLy8gbWVhbnMgaXQgaGFzIGVuZGVkIGFuZCB0aGUgZHJhZyBzb3VyY2Ugbm9kZSBkaXNhcHBlYXJlZCBmcm9tIERPTSxcbiAgICAgICAgLy8gc28gdGhlIGJyb3dzZXIgZGlkbid0IGRpc3BhdGNoIHRoZSBkcmFnZW5kIGV2ZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgYmVmb3JlIHdlIHN0YXJ0IGxpc3RlbmluZyBmb3IgbW91c2Vtb3ZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgZHJhZyBwcmV2aWV3IG5lZWRzIHRvIGJlIGRyYXduIG9yIGVsc2UgaXQgZmlyZXMgYW4gJ21vdXNlbW92ZScgZXZlbnRcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgaW4gc29tZSBicm93c2Vycy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlOlxuICAgICAgICAvLyAgICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC85MjhcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL2lzc3Vlcy84NjlcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLnJvb3RFbGVtZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgfSwgTU9VU0VfTU9WRV9USU1FT1VUKTtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2xlYXJUaW1lb3V0KHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRHJhZ1N0YXJ0KGUsIHNvdXJjZUlkKSB7XG4gICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdTdGFydFNvdXJjZUlkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnRW50ZXIoX2UsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcmFnT3ZlcihfZSwgdGFyZ2V0SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH1cbiAgICBoYW5kbGVEcm9wKF9lLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGdsb2JhbENvbnRleHQsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZUhhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudERyYWdTb3VyY2VOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRLZXlQcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hc3luY0VuZERyYWdGcmFtZUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnT3ZlclRhcmdldElkcyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaG92ZXJSYWZJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQoc291cmNlSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSAmJiBnZXROb2RlQ2xpZW50T2Zmc2V0JDEoc291cmNlKSB8fCBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZERyYWdOYXRpdmVJdGVtID0gKCk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlbW92ZVNvdXJjZSh0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNOb2RlSW5Eb2N1bWVudCA9IChub2RlKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG5vZGUgZWl0aGVyIGluIHRoZSBtYWluIGRvY3VtZW50IG9yIGluIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG5vZGUgJiYgdGhpcy5kb2N1bWVudCAmJiB0aGlzLmRvY3VtZW50LmJvZHkgJiYgdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmREcmFnSWZTb3VyY2VXYXNSZW1vdmVkRnJvbURPTSA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IHRoaXMuaXNOb2RlSW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCkgJiYgdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVIb3ZlciA9IChkcmFnT3ZlclRhcmdldElkcyk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgPT09IG51bGwgJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihkcmFnT3ZlclRhcmdldElkcyB8fCBbXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5sYXN0Q2xpZW50T2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyUmFmSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbmNlbEhvdmVyID0gKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyUmFmSWQgIT09IG51bGwgJiYgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaG92ZXJSYWZJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3ZlclJhZklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnRDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkcmFnU3RhcnRTb3VyY2VJZHMgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQkMShlKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGNyYXNoaW5nIGlmIHdlIG1pc3NlZCBhIGRyb3AgZXZlbnQgb3Igb3VyIHByZXZpb3VzIGRyYWcgZGllZFxuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHB1Ymxpc2ggdGhlIHNvdXJjZSBqdXN0IHlldCAoc2VlIHdoeSBiZWxvdylcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcoZHJhZ1N0YXJ0U291cmNlSWRzIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFNvdXJjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0U291cmNlQ2xpZW50T2Zmc2V0OiB0aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCxcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhVHJhbnNmZXIgIH0gPSBlO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlVHlwZSA9IG1hdGNoTmF0aXZlSXRlbVR5cGUoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiB0eXBlb2YgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGRyYWcgaW1hZ2UgaWYgdXNlciBzcGVjaWZpZXMgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGNoaWxkIGRyYWcgc291cmNlIHJlZnVzZXMgZHJhZyBidXQgcGFyZW50IGFncmVlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBhcmVudCdzIG5vZGUgYXMgZHJhZyBpbWFnZS4gTmVpdGhlciB3b3JrcyBpbiBJRSB0aG91Z2guXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUlkID0gdGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSB0aGlzLnNvdXJjZU5vZGVzLmdldChzb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdQcmV2aWV3ID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuZ2V0KHNvdXJjZUlkKSB8fCBzb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yWCAsIGFuY2hvclkgLCBvZmZzZXRYICwgb2Zmc2V0WSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhZ1ByZXZpZXdPZmZzZXQgPSBnZXREcmFnUHJldmlld09mZnNldChzb3VyY2VOb2RlLCBkcmFnUHJldmlldywgY2xpZW50T2Zmc2V0LCBhbmNob3JQb2ludCwgb2Zmc2V0UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnUHJldmlldywgZHJhZ1ByZXZpZXdPZmZzZXQueCwgZHJhZ1ByZXZpZXdPZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCB3b24ndCBkcmFnIHdpdGhvdXQgc2V0dGluZyBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2ZlciA9PT0gbnVsbCB8fCBkYXRhVHJhbnNmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFUcmFuc2Zlci5zZXREYXRhKCdhcHBsaWNhdGlvbi9qc29uJywge30pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBNSU1FIHR5cGVzIGluIHNldERhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgZHJhZyBzb3VyY2Ugbm9kZSBzbyB3ZSBjYW4gY2hlY2sgd2hldGhlclxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHJlbW92ZWQgZnJvbSBET00gYW5kIHRyaWdnZXIgZW5kRHJhZyBtYW51YWxseS5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnREcmFnU291cmNlTm9kZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIGFyZSByZWFkeSB0byBwdWJsaXNoIHRoZSBkcmFnIHNvdXJjZS4uIG9yIGFyZSB3ZSBub3Q/XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYXB0dXJlRHJhZ2dpbmdTdGF0ZSAgfSA9IHRoaXMuZ2V0Q3VycmVudFNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghY2FwdHVyZURyYWdnaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB3ZSB3YW50IHRvIHB1Ymxpc2ggaXQgaW4gdGhlIG5leHQgdGljayBzbyB0aGF0IGJyb3dzZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYWJsZSB0byBzY3JlZW5zaG90IHRoZSBjdXJyZW50IChub3QgeWV0IGRyYWdnaW5nKSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgYWxzbyBuZWF0bHkgYXZvaWRzIGEgc2l0dWF0aW9uIHdoZXJlIHJlbmRlcigpIHJldHVybnMgbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSB0aWNrIGZvciB0aGUgc291cmNlIGVsZW1lbnQsIGFuZCBicm93c2VyIGZyZWFrcyBvdXQuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpXG4gICAgICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgdXNlciBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yLCBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHdvcmsgYXJvdW5kIElFIG5vdCBzdXBwb3J0aW5nIGN1c3RvbSBkcmFnIHByZXZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGEgY3VzdG9tIGRyYWcgbGF5ZXIsIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGRyYWcgcHJldmlldyBmcm9tIGRyYXdpbmcgaW4gSUUgaXMgdG8gc2NyZWVuc2hvdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHJhZ2dpbmcgc3RhdGUgaW4gd2hpY2ggdGhlIG5vZGUgaXRzZWxmIGhhcyB6ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGhlaWdodC4gSW4gdGhpcyBjYXNlLCB0aG91Z2gsIHJldHVybmluZyBudWxsIGZyb20gcmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBhYnJ1cHRseSBlbmQgdGhlIGRyYWdnaW5nLCB3aGljaCBpcyBub3Qgb2J2aW91cy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhc29uIHN1Y2ggYmVoYXZpb3IgaXMgc3RyaWN0bHkgb3B0LWluLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbnMucHVibGlzaERyYWdTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIFVSTCkgZHJhZ2dlZCBmcm9tIGluc2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFUcmFuc2ZlciAmJiAhZGF0YVRyYW5zZmVyLnR5cGVzICYmIChlLnRhcmdldCAmJiAhZS50YXJnZXQuaGFzQXR0cmlidXRlIHx8ICFlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpKSkge1xuICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgYSBTYWZhcmkgYnVnOiBkYXRhVHJhbnNmZXIudHlwZXMgaXMgbnVsbCwgYnV0IHRoZXJlIHdhcyBubyBkcmFnZ2FibGUuXG4gICAgICAgICAgICAgICAgLy8gSnVzdCBsZXQgaXQgZHJhZy4gSXQncyBhIG5hdGl2ZSB0eXBlIChVUkwgb3IgdGV4dCkgYW5kIHdpbGwgYmUgcGlja2VkIHVwIGluXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2VudGVyIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBieSB0aGlzIHRpbWUgbm8gZHJhZyBzb3VyY2UgcmVhY3RlZCwgdGVsbCBicm93c2VyIG5vdCB0byBkcmFnLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNhbiBkaXNwYXRjaCB0aGlzIGV2ZW50IGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAvLyBpZiBkcmFnZW5kIGhhbmRsZXIgZG9lcyBzb21ldGhpbmcgbGlrZSBzaG93aW5nIGFuIGFsZXJ0LlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB3ZSBoYXZlIG5vdCBoYW5kbGVkIGl0IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdFbnRlclRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgKHJlZiA9IHRoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYubG9hZERhdGFUcmFuc2ZlcihlLmRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0RW50ZXIgPSB0aGlzLmVudGVyTGVhdmVDb3VudGVyLmVudGVyKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNGaXJzdEVudGVyIHx8IHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFUcmFuc2ZlciAgfSA9IGU7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVUeXBlID0gbWF0Y2hOYXRpdmVJdGVtVHlwZShkYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBIG5hdGl2ZSBpdGVtIChzdWNoIGFzIGZpbGUgb3IgVVJMKSBkcmFnZ2VkIGZyb20gb3V0c2lkZSB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSwgZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnRW50ZXIgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ0VudGVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VudGVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWx0S2V5UHJlc3NlZCA9IGUuYWx0S2V5O1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBjaGFuZ2VzIHBvc2l0aW9uIGFzIHRoZSByZXN1bHQgb2YgYGRyYWdlbnRlcmAsIGBkcmFnb3ZlcmAgbWlnaHQgc3RpbGxcbiAgICAgICAgICAgIC8vIGdldCBkaXNwYXRjaGVkIGRlc3BpdGUgdGFyZ2V0IGJlaW5nIG5vIGxvbmdlciB0aGVyZS4gVGhlIGVhc3kgc29sdXRpb24gaXMgdG8gY2hlY2tcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgYWN0dWFsbHkgaXMgYSB0YXJnZXQgYmVmb3JlIGZpcmluZyBgaG92ZXJgLlxuICAgICAgICAgICAgaWYgKGRyYWdFbnRlclRhcmdldElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyYWdFbnRlclRhcmdldElkcywge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbkRyb3AgPSBkcmFnRW50ZXJUYXJnZXRJZHMuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgdGhpcyB0byBmaXJlIGRyYWdvdmVyIGV2ZW50c1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlID0gKGUpPT57XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAocmVmID0gdGhpcy5jdXJyZW50TmF0aXZlU291cmNlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sb2FkRGF0YVRyYW5zZmVyKGUuZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnT3ZlciA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnT3ZlclRhcmdldElkcyAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBcImRyb3AgYW5kIGJsb3cgYXdheSB0aGUgd2hvbGUgZG9jdW1lbnRcIiBhY3Rpb24uXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsdEtleVByZXNzZWQgPSBlLmFsdEtleTtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlSG92ZXIoZHJhZ092ZXJUYXJnZXRJZHMpO1xuICAgICAgICAgICAgY29uc3QgY2FuRHJvcCA9IChkcmFnT3ZlclRhcmdldElkcyB8fCBbXSkuc29tZSgodGFyZ2V0SWQpPT50aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYW5Ecm9wKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyB1c2VyLXNwZWNpZmllZCBkcm9wIGVmZmVjdC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSB0aGlzLmdldEN1cnJlbnREcm9wRWZmZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGEgbmljZSBjdXJzb3IgYnV0IHN0aWxsIHByZXZlbnQgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIFwiZHJvcCBhbmQgYmxvdyBhd2F5IHRoZSB3aG9sZSBkb2N1bWVudFwiIGFjdGlvbi5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdExlYXZlID0gdGhpcy5lbnRlckxlYXZlQ291bnRlci5sZWF2ZShlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWlzTGFzdExlYXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PnRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0oKVxuICAgICAgICAgICAgICAgICwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEhvdmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIChyZWYgPSB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmxvYWREYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaE5hdGl2ZUl0ZW1UeXBlKGUuZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIERyYWdnaW5nIHNvbWUgZWxlbWVudHMsIGxpa2UgPGE+IGFuZCA8aW1nPiBtYXkgc3RpbGwgYmVoYXZlIGxpa2UgYSBuYXRpdmUgZHJhZyBldmVudCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBjdXJyZW50IGRyYWcgZXZlbnQgbWF0Y2hlcyBhIHVzZXItZGVmaW5lZCB0eXBlLlxuICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiB3ZSdyZSBub3QgZXhwZWN0aW5nIGEgbmF0aXZlIGl0ZW0gdG8gYmUgZHJvcHBlZC5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVudGVyTGVhdmVDb3VudGVyLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBkcm9wVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmhvdmVyKGRyb3BUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGdldEV2ZW50Q2xpZW50T2Zmc2V0JDEoZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICAgICAgICAgIGRyb3BFZmZlY3Q6IHRoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmREcmFnTmF0aXZlSXRlbSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FuY2VsSG92ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAvLyBPbmx5IElFIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2F5XG4gICAgICAgICAgICAvLyB3ZSB3YW50IGRyYWcgZHJvcCBvcGVyYXRpb24gdG8gc3RhcnRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmRyYWdEcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5wdXRzIGFuZCB0ZXh0YXJlYXMgc2hvdWxkIGJlIHNlbGVjdGFibGVcbiAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHwgdGFyZ2V0LnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHRhcmdldHMsIGFzayBJRVxuICAgICAgICAgICAgLy8gdG8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRhcmdldC5kcmFnRHJvcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBuZXcgT3B0aW9uc1JlYWRlciQxKGdsb2JhbENvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSBtYW5hZ2VyLmdldFJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZW50ZXJMZWF2ZUNvdW50ZXIgPSBuZXcgRW50ZXJMZWF2ZUNvdW50ZXIodGhpcy5pc05vZGVJbkRvY3VtZW50KTtcbiAgICB9XG59XG5cbmxldCBlbXB0eUltYWdlO1xuZnVuY3Rpb24gZ2V0RW1wdHlJbWFnZSgpIHtcbiAgICBpZiAoIWVtcHR5SW1hZ2UpIHtcbiAgICAgICAgZW1wdHlJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBlbXB0eUltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eUltYWdlO1xufVxuXG5jb25zdCBIVE1MNUJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEhUTUw1QmFja2VuZEltcGwobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyk7XG59O1xuXG5mdW5jdGlvbiBQaWVjZSh7IGlzUHJlbW92ZWRQaWVjZSA9IGZhbHNlLCBwaWVjZSwgc3F1YXJlLCBzcXVhcmVzLCB9KSB7XHJcbiAgICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uLCBhcmVQaWVjZXNEcmFnZ2FibGUsIGJvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb24sIGNoZXNzUGllY2VzLCBjdXJyZW50UG9zaXRpb24sIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZSwgZHJvcE9mZkJvYXJkQWN0aW9uLCBpZCwgaXNEcmFnZ2FibGVQaWVjZSwgaXNXYWl0aW5nRm9yQW5pbWF0aW9uLCBvblBpZWNlQ2xpY2ssIG9uUGllY2VEcmFnQmVnaW4sIG9uUGllY2VEcmFnRW5kLCBvblBpZWNlRHJvcE9mZkJvYXJkLCBvblByb21vdGlvbkNoZWNrLCBwb3NpdGlvbkRpZmZlcmVuY2VzLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgW3BpZWNlU3R5bGUsIHNldFBpZWNlU3R5bGVdID0gdXNlU3RhdGUoe1xyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgekluZGV4OiA1LFxyXG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcclxuICAgICAgICBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgID8gXCItd2Via2l0LWdyYWJcIlxyXG4gICAgICAgICAgICA6IFwiZGVmYXVsdFwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbeyBjYW5EcmFnLCBpc0RyYWdnaW5nIH0sIGRyYWcsIGRyYWdQcmV2aWV3XSA9IHVzZURyYWcoKCkgPT4gKHtcclxuICAgICAgICB0eXBlOiBcInBpZWNlXCIsXHJcbiAgICAgICAgaXRlbTogKCkgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0JlZ2luKHBpZWNlLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBwaWVjZSwgc3F1YXJlLCBpZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiAoaXRlbSwgbW9uaXRvcikgPT4ge1xyXG4gICAgICAgICAgICBvblBpZWNlRHJhZ0VuZChwaWVjZSwgc3F1YXJlKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRHJvcE91dHNpZGVUaGVCb2FyZCA9ICFtb25pdG9yLmRpZERyb3AoKTtcclxuICAgICAgICAgICAgaWYgKHdhc0Ryb3BPdXRzaWRlVGhlQm9hcmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcm9wT2ZmQm9hcmRBY3Rpb24gPT09IFwidHJhc2hcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVBpZWNlRnJvbVNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb25QaWVjZURyb3BPZmZCb2FyZCA9PT0gbnVsbCB8fCBvblBpZWNlRHJvcE9mZkJvYXJkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblBpZWNlRHJvcE9mZkJvYXJkKHNxdWFyZSwgcGllY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0OiAobW9uaXRvcikgPT4gKHtcclxuICAgICAgICAgICAgY2FuRHJhZzogaXNEcmFnZ2FibGVQaWVjZSh7IHBpZWNlLCBzb3VyY2VTcXVhcmU6IHNxdWFyZSB9KSxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZzogISFtb25pdG9yLmlzRHJhZ2dpbmcoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbcGllY2UsIHNxdWFyZSwgY3VycmVudFBvc2l0aW9uLCBpZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICAvLyBoaWRlIHBpZWNlIG9uIGRyYWdcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0UGllY2VTdHlsZSgob2xkUGllY2VTdHlsZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkUGllY2VTdHlsZSksIHsgb3BhY2l0eTogaXNEcmFnZ2luZyA/IDAgOiAxIH0pKSk7XHJcbiAgICB9LCBbaXNEcmFnZ2luZ10pO1xyXG4gICAgLy8gbmV3IG1vdmUgaGFzIGNvbWUgaW5cclxuICAgIC8vIGlmIHdhaXRpbmcgZm9yIGFuaW1hdGlvbiwgdGhlbiBhbmltYXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHdlIGNhbiBwZXJmb3JtIGFuaW1hdGlvblxyXG4gICAgLy8gd2UgbmVlZCB0byBoZWFkIHRvd2FyZHMgd2hlcmUgd2UgbmVlZCB0byBnbywgd2UgYXJlIHRoZSBzb3VyY2UsIHdlIGFyZSBoZWFkaW5nIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFBpZWNlID0gKF9hID0gcG9zaXRpb25EaWZmZXJlbmNlcy5yZW1vdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbc3F1YXJlXTtcclxuICAgICAgICAvLyByZXR1cm4gYXMgbnVsbCBhbmQgbm90IGxvYWRlZCB5ZXRcclxuICAgICAgICBpZiAoIXBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQgfHwgIXJlbW92ZWRQaWVjZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHBpZWNlIG1hdGNoZXMgb3IgaWYgcmVtb3ZlZCBwaWVjZSB3YXMgYSBwYXduIGFuZCBuZXcgc3F1YXJlIGlzIG9uIDFzdCBvciA4dGggcmFuayAocHJvbW90aW9uKVxyXG4gICAgICAgIGNvbnN0IG5ld1NxdWFyZSA9IE9iamVjdC5lbnRyaWVzKHBvc2l0aW9uRGlmZmVyZW5jZXMuYWRkZWQpLmZpbmQoKFtzLCBwXSkgPT4gcCA9PT0gcmVtb3ZlZFBpZWNlIHx8IG9uUHJvbW90aW9uQ2hlY2soc3F1YXJlLCBzLCByZW1vdmVkUGllY2UpKTtcclxuICAgICAgICAvLyB3ZSBjYW4gcGVyZm9ybSBhbmltYXRpb24gaWYgb3VyIHNxdWFyZSB3YXMgaW4gcmVtb3ZlZCwgQU5EIHRoZSBtYXRjaGluZyBwaWVjZSBpcyBpbiBhZGRlZCBBTkQgdGhpcyBpc24ndCBhIHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgaWYgKGlzV2FpdGluZ0ZvckFuaW1hdGlvbiAmJlxyXG4gICAgICAgICAgICByZW1vdmVkUGllY2UgJiZcclxuICAgICAgICAgICAgbmV3U3F1YXJlICYmXHJcbiAgICAgICAgICAgICFpc1ByZW1vdmVkUGllY2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlU3EgPSBzcXVhcmU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNxID0gbmV3U3F1YXJlWzBdO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU3EgJiYgdGFyZ2V0U3EpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDg7XHJcbiAgICAgICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXRTcS5jaGFyQ29kZUF0KDApIC0gc291cmNlU3EuY2hhckNvZGVBdCgwKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weCwgJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiID8gLTEgOiAxKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChOdW1iZXIoc291cmNlU3FbMV0pIC0gTnVtYmVyKHRhcmdldFNxWzFdKSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weClgLCB0cmFuc2l0aW9uOiBgdHJhbnNmb3JtICR7YW5pbWF0aW9uRHVyYXRpb259bXNgLCB6SW5kZXg6IDYgfSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtwb3NpdGlvbkRpZmZlcmVuY2VzXSk7XHJcbiAgICAvLyB0cmFuc2xhdGUgdG8gdGhlaXIgb3duIHBvc2l0aW9ucyAocmVwYWludCBvbiB1bmRvKVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNvdXJjZVNxIH0gPSBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpO1xyXG4gICAgICAgIGlmIChzb3VyY2VTcSkge1xyXG4gICAgICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHswfXB4LCAkezB9cHgpYCwgdHJhbnNpdGlvbjogYHRyYW5zZm9ybSAkezB9bXNgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRQb3NpdGlvbl0pO1xyXG4gICAgLy8gdXBkYXRlIGlzIHBpZWNlIGRyYWdnYWJsZVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRQaWVjZVN0eWxlKChvbGRQaWVjZVN0eWxlKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRQaWVjZVN0eWxlKSwgeyBjdXJzb3I6IGFyZVBpZWNlc0RyYWdnYWJsZSAmJiBpc0RyYWdnYWJsZVBpZWNlKHsgcGllY2UsIHNvdXJjZVNxdWFyZTogc3F1YXJlIH0pXHJcbiAgICAgICAgICAgICAgICA/IFwiLXdlYmtpdC1ncmFiXCJcclxuICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCIgfSkpKTtcclxuICAgIH0sIFtzcXVhcmUsIGN1cnJlbnRQb3NpdGlvbiwgYXJlUGllY2VzRHJhZ2dhYmxlXSk7XHJcbiAgICBmdW5jdGlvbiBnZXRTaW5nbGVTcXVhcmVDb29yZGluYXRlcygpIHtcclxuICAgICAgICByZXR1cm4geyBzb3VyY2VTcTogc3F1YXJlc1tzcXVhcmVdIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBhcmVQaWVjZXNEcmFnZ2FibGUgJiYgY2FuRHJhZyA/IGRyYWcgOiBudWxsLCBvbkNsaWNrOiAoKSA9PiBvblBpZWNlQ2xpY2socGllY2UsIHNxdWFyZSksIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHBpZWNlU3R5bGUgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW3BpZWNlXSA9PT0gXCJmdW5jdGlvblwiID8gKGNoZXNzUGllY2VzW3BpZWNlXSh7XHJcbiAgICAgICAgICAgIHNxdWFyZVdpZHRoOiBib2FyZFdpZHRoIC8gOCxcclxuICAgICAgICAgICAgaXNEcmFnZ2luZyxcclxuICAgICAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHsgZGlzcGxheTogXCJibG9ja1wiIH0gfSwgeyBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNoaWxkcmVuOiBjaGVzc1BpZWNlc1twaWVjZV0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFNxdWFyZSh7IHNxdWFyZSwgc3F1YXJlQ29sb3IsIHNldFNxdWFyZXMsIHNxdWFyZUhhc1ByZW1vdmUsIGNoaWxkcmVuLCB9KSB7XHJcbiAgICBjb25zdCBzcXVhcmVSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCB7IGF1dG9Qcm9tb3RlVG9RdWVlbiwgYm9hcmRXaWR0aCwgYm9hcmRPcmllbnRhdGlvbiwgY2xlYXJBcnJvd3MsIGN1cnJlbnRQb3NpdGlvbiwgY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBjdXN0b21Cb2FyZFN0eWxlLCBjdXN0b21EYXJrU3F1YXJlU3R5bGUsIGN1c3RvbURyb3BTcXVhcmVTdHlsZSwgY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZSwgY3VzdG9tUHJlbW92ZUxpZ2h0U3F1YXJlU3R5bGUsIGN1c3RvbVNxdWFyZTogQ3VzdG9tU3F1YXJlLCBjdXN0b21TcXVhcmVTdHlsZXMsIGRyYXdOZXdBcnJvdywgaGFuZGxlU2V0UG9zaXRpb24sIGhhbmRsZVNwYXJlUGllY2VEcm9wLCBpc1dhaXRpbmdGb3JBbmltYXRpb24sIGxhc3RQaWVjZUNvbG91ciwgbGFzdFNxdWFyZURyYWdnZWRPdmVyLCBvbkFycm93RHJhd0VuZCwgb25EcmFnT3ZlclNxdWFyZSwgb25Nb3VzZU91dFNxdWFyZSwgb25Nb3VzZU92ZXJTcXVhcmUsIG9uUGllY2VEcm9wLCBvblByb21vdGlvbkNoZWNrLCBvblJpZ2h0Q2xpY2tEb3duLCBvblJpZ2h0Q2xpY2tVcCwgb25TcXVhcmVDbGljaywgc2V0TGFzdFNxdWFyZURyYWdnZWRPdmVyLCBzZXRQcm9tb3RlRnJvbVNxdWFyZSwgc2V0UHJvbW90ZVRvU3F1YXJlLCBzZXRTaG93UHJvbW90ZURpYWxvZywgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IFt7IGlzT3ZlciB9LCBkcm9wXSA9IHVzZURyb3AoKCkgPT4gKHtcclxuICAgICAgICBhY2NlcHQ6IFwicGllY2VcIixcclxuICAgICAgICBkcm9wOiBoYW5kbGVEcm9wLFxyXG4gICAgICAgIGNvbGxlY3Q6IChtb25pdG9yKSA9PiAoe1xyXG4gICAgICAgICAgICBpc092ZXI6ICEhbW9uaXRvci5pc092ZXIoKSxcclxuICAgICAgICB9KSxcclxuICAgIH0pLCBbXHJcbiAgICAgICAgc3F1YXJlLFxyXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbixcclxuICAgICAgICBvblBpZWNlRHJvcCxcclxuICAgICAgICBpc1dhaXRpbmdGb3JBbmltYXRpb24sXHJcbiAgICAgICAgbGFzdFBpZWNlQ29sb3VyLFxyXG4gICAgXSk7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVEcm9wKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbS5pc1NwYXJlKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNwYXJlUGllY2VEcm9wKGl0ZW0ucGllY2UsIHNxdWFyZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uUHJvbW90aW9uQ2hlY2soaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSkpIHtcclxuICAgICAgICAgICAgaWYgKGF1dG9Qcm9tb3RlVG9RdWVlbikge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZVswXSA9PT0gXCJ3XCIgPyBcIndRXCIgOiBcImJRXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZUZyb21TcXVhcmUoaXRlbS5zcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbW90ZVRvU3F1YXJlKHNxdWFyZSk7XHJcbiAgICAgICAgICAgICAgICBzZXRTaG93UHJvbW90ZURpYWxvZyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlU2V0UG9zaXRpb24oaXRlbS5zcXVhcmUsIHNxdWFyZSwgaXRlbS5waWVjZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3F1YXJlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBzcXVhcmVSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgc2V0U3F1YXJlcygob2xkU3F1YXJlcykgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU3F1YXJlcyksIHsgW3NxdWFyZV06IHsgeCwgeSB9IH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2JvYXJkV2lkdGgsIGJvYXJkT3JpZW50YXRpb25dKTtcclxuICAgIGNvbnN0IGRlZmF1bHRTcXVhcmVTdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvcmRlclJhZGl1cyhzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpKSwgKHNxdWFyZUNvbG9yID09PSBcImJsYWNrXCJcclxuICAgICAgICA/IGN1c3RvbURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgIDogY3VzdG9tTGlnaHRTcXVhcmVTdHlsZSkpLCAoc3F1YXJlSGFzUHJlbW92ZSAmJlxyXG4gICAgICAgIChzcXVhcmVDb2xvciA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgID8gY3VzdG9tUHJlbW92ZURhcmtTcXVhcmVTdHlsZVxyXG4gICAgICAgICAgICA6IGN1c3RvbVByZW1vdmVMaWdodFNxdWFyZVN0eWxlKSkpLCAoaXNPdmVyICYmIGN1c3RvbURyb3BTcXVhcmVTdHlsZSkpO1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogZHJvcCwgc3R5bGU6IGRlZmF1bHRTcXVhcmVTdHlsZSwgXCJkYXRhLXNxdWFyZS1jb2xvclwiOiBzcXVhcmVDb2xvciwgXCJkYXRhLXNxdWFyZVwiOiBzcXVhcmUsIG9uVG91Y2hNb3ZlOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0b3VjaCBldmVudHMgb24gdGFibGV0IGFuZCBtb2JpbGUgbm90IGNvdmVyZWQgYnkgb25Nb3VzZU92ZXIvb25EcmFnRW50ZXJcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hMb2NhdGlvbiA9IGUudG91Y2hlc1swXTtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodG91Y2hMb2NhdGlvbi5jbGllbnRYLCB0b3VjaExvY2F0aW9uLmNsaWVudFkpO1xyXG4gICAgICAgICAgICBjb25zdCBkcmFnZ2VkT3ZlclNxdWFyZSA9IChfYSA9IHRvdWNoRWxlbWVudCA9PT0gbnVsbCB8fCB0b3VjaEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvdWNoRWxlbWVudC5maW5kKChlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIikpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QXR0cmlidXRlKFwiZGF0YS1zcXVhcmVcIik7XHJcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkT3ZlclNxdWFyZSAmJiBkcmFnZ2VkT3ZlclNxdWFyZSAhPT0gbGFzdFNxdWFyZURyYWdnZWRPdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0U3F1YXJlRHJhZ2dlZE92ZXIoZHJhZ2dlZE92ZXJTcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25EcmFnT3ZlclNxdWFyZShkcmFnZ2VkT3ZlclNxdWFyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvbk1vdXNlT3ZlcjogKGUpID0+IHtcclxuICAgICAgICAgICAgLy8gbm9vcCBpZiBtb3ZpbmcgZnJvbSBjaGlsZCBvZiBzcXVhcmUgaW50byBzcXVhcmUuXHJcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDIgJiYgY3VycmVudFJpZ2h0Q2xpY2tEb3duKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3TmV3QXJyb3coY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiZcclxuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25Nb3VzZU92ZXJTcXVhcmUoc3F1YXJlKTtcclxuICAgICAgICB9LCBvbk1vdXNlT3V0OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBub29wIGlmIG1vdmluZyBmcm9tIHNxdWFyZSBpbnRvIGEgY2hpbGQgb2Ygc3F1YXJlLlxyXG4gICAgICAgICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmXHJcbiAgICAgICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgb25Nb3VzZU91dFNxdWFyZShzcXVhcmUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VEb3duOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpXHJcbiAgICAgICAgICAgICAgICBvblJpZ2h0Q2xpY2tEb3duKHNxdWFyZSk7XHJcbiAgICAgICAgfSwgb25Nb3VzZVVwOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmlnaHRDbGlja0Rvd24pXHJcbiAgICAgICAgICAgICAgICAgICAgb25BcnJvd0RyYXdFbmQoY3VycmVudFJpZ2h0Q2xpY2tEb3duLCBzcXVhcmUpO1xyXG4gICAgICAgICAgICAgICAgb25SaWdodENsaWNrVXAoc3F1YXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9uRHJhZ0VudGVyOiAoKSA9PiBvbkRyYWdPdmVyU3F1YXJlKHNxdWFyZSksIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSBjdXJyZW50UG9zaXRpb25bc3F1YXJlXTtcclxuICAgICAgICAgICAgb25TcXVhcmVDbGljayhzcXVhcmUsIHBpZWNlKTtcclxuICAgICAgICAgICAgY2xlYXJBcnJvd3MoKTtcclxuICAgICAgICB9LCBvbkNvbnRleHRNZW51OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiB0eXBlb2YgQ3VzdG9tU3F1YXJlID09PSBcInN0cmluZ1wiID8gKGpzeChDdXN0b21TcXVhcmVcclxuICAgICAgICAvLyBUeXBlIGlzIHRvbyBjb21wbGV4IHRvIHByb3Blcmx5IGV2YWx1YXRlLCBzbyBpZ25vcmUgdGhpcyBsaW5lLlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAsIE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAgICAgLy8gVHlwZSBpcyB0b28gY29tcGxleCB0byBwcm9wZXJseSBldmFsdWF0ZSwgc28gaWdub3JlIHRoaXMgbGluZS5cclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICByZWY6IHNxdWFyZVJlZiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIDogKGpzeChDdXN0b21TcXVhcmUsIE9iamVjdC5hc3NpZ24oeyByZWY6IHNxdWFyZVJlZiwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaXplKGJvYXJkV2lkdGgpKSwgY2VudGVyKSwgKCFzcXVhcmVIYXNQcmVtb3ZlICYmIChjdXN0b21TcXVhcmVTdHlsZXMgPT09IG51bGwgfHwgY3VzdG9tU3F1YXJlU3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21TcXVhcmVTdHlsZXNbc3F1YXJlXSkpKSB9LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSkpIH0pKSk7XHJcbn1cclxuY29uc3QgY2VudGVyID0ge1xyXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxufTtcclxuY29uc3Qgc2l6ZSA9ICh3aWR0aCkgPT4gKHtcclxuICAgIHdpZHRoOiB3aWR0aCAvIDgsXHJcbiAgICBoZWlnaHQ6IHdpZHRoIC8gOCxcclxufSk7XHJcbmNvbnN0IGJvcmRlclJhZGl1cyA9IChzcXVhcmUsIGJvYXJkT3JpZW50YXRpb24sIGN1c3RvbUJvYXJkU3R5bGUpID0+IHtcclxuICAgIGlmICghKGN1c3RvbUJvYXJkU3R5bGUgPT09IG51bGwgfHwgY3VzdG9tQm9hcmRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMpKVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIGlmIChzcXVhcmUgPT09IFwiYTFcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH1cclxuICAgICAgICAgICAgOiB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHNxdWFyZSA9PT0gXCJhOFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJvYXJkT3JpZW50YXRpb24gPT09IFwid2hpdGVcIlxyXG4gICAgICAgICAgICA/IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGN1c3RvbUJvYXJkU3R5bGUuYm9yZGVyUmFkaXVzIH07XHJcbiAgICB9XHJcbiAgICBpZiAoc3F1YXJlID09PSBcImgxXCIpIHtcclxuICAgICAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJ3aGl0ZVwiXHJcbiAgICAgICAgICAgID8geyBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfVxyXG4gICAgICAgICAgICA6IHsgYm9yZGVyVG9wTGVmdFJhZGl1czogY3VzdG9tQm9hcmRTdHlsZS5ib3JkZXJSYWRpdXMgfTtcclxuICAgIH1cclxuICAgIGlmIChzcXVhcmUgPT09IFwiaDhcIikge1xyXG4gICAgICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSBcIndoaXRlXCJcclxuICAgICAgICAgICAgPyB7IGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9XHJcbiAgICAgICAgICAgIDogeyBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBjdXN0b21Cb2FyZFN0eWxlLmJvcmRlclJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59O1xuXG5mdW5jdGlvbiBTcXVhcmVzKCkge1xyXG4gICAgY29uc3QgW3NxdWFyZXMsIHNldFNxdWFyZXNdID0gdXNlU3RhdGUoe30pO1xyXG4gICAgY29uc3QgeyBhcmVQcmVtb3Zlc0FsbG93ZWQsIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1cnJlbnRQb3NpdGlvbiwgaWQsIHByZW1vdmVzLCBzaG93Qm9hcmROb3RhdGlvbiwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IHByZW1vdmVzSGlzdG9yeSA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIC8vIGlmIHByZW1vdmVzIGFyZW4ndCBhbGxvd2VkLCBkb24ndCB3YXN0ZSB0aW1lIG9uIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgIGlmICghYXJlUHJlbW92ZXNBbGxvd2VkKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgcHJlbW92ZXMuZm9yRWFjaCgocHJlbW92ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIHBpZWNlIH0gPSBwcmVtb3ZlO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHByZW1vdmUgaXMgbWFkZSBieSBhbiBhbHJlYWR5IHByZW1vdmVkIHBpZWNlXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRQcmVtb3ZlZFBpZWNlID0gcmVzdWx0LmZpbmQoKHApID0+IHsgdmFyIF9hOyByZXR1cm4gcC5waWVjZSA9PT0gcGllY2UgJiYgKChfYSA9IHAucHJlbW92ZXNSb3V0ZS5hdCgtMSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50YXJnZXRTcSkgPT09IHNvdXJjZVNxOyB9KTtcclxuICAgICAgICAgICAgLy8gaWYgcHJlbW92ZSBoYXMgYmVlbiBtYWRlIGJ5IGFscmVhZHkgcHJlbW92ZWQgcGllY2UgdGhlbiB3cml0ZSB0aGUgbW92ZSB0byBpdHMgYHByZW1vdmVzUm91dGVgIGZpZWxkIHRvIGJlIGFibGUgZmluZCBpdHMgZmluYWwgZGVzdGluYXRpb24gbGF0ZXJcclxuICAgICAgICAgICAgaWYgKHJlbGF0ZWRQcmVtb3ZlZFBpZWNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGVkUHJlbW92ZWRQaWVjZS5wcmVtb3Zlc1JvdXRlLnB1c2goeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHByZW1vdmUgaGFzIGJlZW4gbWFkZSBieSBzdGFuZGFyZCBwaWVjZSBjcmVhdGUgbmV3IG9iamVjdCBpbiBgcHJlbW92ZXNIaXN0b3J5YCB3aGVyZSB3ZSB3aWxsIGtlZXAgaXRzIG93biBwcmVtb3Zlc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwaWVjZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCBpcyB1c2VmdWwgZm9yIHNjZW5hcmlvcyB3aGVyZSB0d28gb3IgbW9yZSBwaWVjZXMgYXJlIHRhcmdldGluZyB0aGUgc2FtZSBzcXVhcmVcclxuICAgICAgICAgICAgICAgICAgICBwcmVtb3Zlc1JvdXRlOiBbeyBzb3VyY2VTcSwgdGFyZ2V0U3EsIGluZGV4IH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwgW3ByZW1vdmVzXSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgXCJkYXRhLWJvYXJkaWRcIjogaWQgfSwgeyBjaGlsZHJlbjogWy4uLkFycmF5KDgpXS5tYXAoKF8sIHIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJvYXJkV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFsuLi5BcnJheSg4KV0ubWFwKChfLCBjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYm9hcmRPcmllbnRhdGlvbiA9PT0gXCJibGFja1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKENPTFVNTlNbNyAtIGNdICsgKHIgKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoQ09MVU1OU1tjXSArICg4IC0gcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUNvbG9yID0gYyAlIDIgPT09IHIgJSAyID8gXCJ3aGl0ZVwiIDogXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZUhhc1ByZW1vdmUgPSBwcmVtb3Zlcy5maW5kKChwKSA9PiBwLnNvdXJjZVNxID09PSBzcXVhcmUgfHwgcC50YXJnZXRTcSA9PT0gc3F1YXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ID0gcHJlbW92ZXNIaXN0b3J5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgcHJlbW92ZXNSb3V0ZSB9KSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBwcmVtb3Zlc1JvdXRlLmF0KC0xKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldFNxKSA9PT0gc3F1YXJlOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBwcmVtb3ZlZCBwaWVjZSB3aXRoIHRoZSBoaWdoZXIgaW5kZXggd2lsbCBiZSBzaG93biwgYXMgaXQgaXMgdGhlIGxhdGVzdCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXgpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBhLnByZW1vdmVzUm91dGUuYXQoLTEpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGpzeHMoU3F1YXJlLCBPYmplY3QuYXNzaWduKHsgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZUNvbG9yOiBzcXVhcmVDb2xvciwgc2V0U3F1YXJlczogc2V0U3F1YXJlcywgc3F1YXJlSGFzUHJlbW92ZTogISFzcXVhcmVIYXNQcmVtb3ZlIH0sIHsgY2hpbGRyZW46IFshc3F1YXJlSGFzUHJlbW92ZSAmJiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSAmJiAoanN4KFBpZWNlLCB7IHBpZWNlOiBjdXJyZW50UG9zaXRpb25bc3F1YXJlXSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzcXVhcmVIYXNQcmVtb3ZlVGFyZ2V0ICYmIChqc3goUGllY2UsIHsgaXNQcmVtb3ZlZFBpZWNlOiB0cnVlLCBwaWVjZTogc3F1YXJlSGFzUHJlbW92ZVRhcmdldC5waWVjZSwgc3F1YXJlOiBzcXVhcmUsIHNxdWFyZXM6IHNxdWFyZXMgfSkpLCBzaG93Qm9hcmROb3RhdGlvbiAmJiBqc3goTm90YXRpb24sIHsgcm93OiByLCBjb2w6IGMgfSldIH0pLCBgJHtjfSR7cn1gKSk7XHJcbiAgICAgICAgICAgICAgICB9KSB9KSwgci50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfSkgfSkpKTtcclxufVxuXG5jb25zdCBBcnJvd3MgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGFycm93cywgbmV3QXJyb3csIGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGN1c3RvbUFycm93Q29sb3I6IHByaW1hcnlBcnJvd0NvbGxvciwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGFycm93c0xpc3QgPSBbLi4uYXJyb3dzLCBuZXdBcnJvd10uZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHdpZHRoOiBib2FyZFdpZHRoLCBoZWlnaHQ6IGJvYXJkV2lkdGgsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IFwiMFwiLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgekluZGV4OiBcIjEwXCIsXHJcbiAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBhcnJvd3NMaXN0Lm1hcCgoYXJyb3csIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2Fycm93U3RhcnRGaWVsZCwgYXJyb3dFbmRGaWVsZCwgYXJyb3dDb2xvcl0gPSBhcnJvdztcclxuICAgICAgICAgICAgaWYgKGFycm93U3RhcnRGaWVsZCA9PT0gYXJyb3dFbmRGaWVsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gZ2V0UmVsYXRpdmVDb29yZHMoYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgYXJyb3dTdGFydEZpZWxkKTtcclxuICAgICAgICAgICAgY29uc3QgdG8gPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBhcnJvd0VuZEZpZWxkKTtcclxuICAgICAgICAgICAgbGV0IEFSUk9XX0xFTkdUSF9SRURVQ0VSID0gYm9hcmRXaWR0aCAvIDMyO1xyXG4gICAgICAgICAgICBjb25zdCBpc0Fycm93QWN0aXZlID0gaSA9PT0gYXJyb3dzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGRpZmZlcmVudCBhcnJvd3MgdGFyZ2V0aW5nIHRoZSBzYW1lIHNxdWFyZSBtYWtlIHRoZWlyIGxlbmd0aCBhIGJpdCBzaG9ydGVyXHJcbiAgICAgICAgICAgIGlmIChhcnJvd3Muc29tZSgocmVzdEFycm93KSA9PiByZXN0QXJyb3dbMF0gIT09IGFycm93U3RhcnRGaWVsZCAmJiByZXN0QXJyb3dbMV0gPT09IGFycm93RW5kRmllbGQpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNBcnJvd0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgQVJST1dfTEVOR1RIX1JFRFVDRVIgPSBib2FyZFdpZHRoIC8gMTY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZHggPSB0by54IC0gZnJvbS54O1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IHRvLnkgLSBmcm9tLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLmh5cG90KGR5LCBkeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIChkeCAqIChyIC0gQVJST1dfTEVOR1RIX1JFRFVDRVIpKSAvIHIsXHJcbiAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyAoZHkgKiAociAtIEFSUk9XX0xFTkdUSF9SRURVQ0VSKSkgLyByLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW2pzeChcIm1hcmtlclwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IGBhcnJvd2hlYWQtJHtpfWAsIG1hcmtlcldpZHRoOiBcIjJcIiwgbWFya2VySGVpZ2h0OiBcIjIuNVwiLCByZWZYOiBcIjEuMjVcIiwgcmVmWTogXCIxLjI1XCIsIG9yaWVudDogXCJhdXRvXCIgfSwgeyBjaGlsZHJlbjoganN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLjMgMCwgMiAxLjI1LCAwLjMgMi41XCIsIGZpbGw6IGFycm93Q29sb3IgIT09IG51bGwgJiYgYXJyb3dDb2xvciAhPT0gdm9pZCAwID8gYXJyb3dDb2xvciA6IHByaW1hcnlBcnJvd0NvbGxvciB9KSB9KSksIGpzeChcImxpbmVcIiwgeyB4MTogZnJvbS54LCB5MTogZnJvbS55LCB4MjogZW5kLngsIHkyOiBlbmQueSwgb3BhY2l0eTogaXNBcnJvd0FjdGl2ZSA/IFwiMC41XCIgOiBcIjAuNjVcIiwgc3Ryb2tlOiBhcnJvd0NvbG9yICE9PSBudWxsICYmIGFycm93Q29sb3IgIT09IHZvaWQgMCA/IGFycm93Q29sb3IgOiBwcmltYXJ5QXJyb3dDb2xsb3IsIHN0cm9rZVdpZHRoOiBpc0Fycm93QWN0aXZlID8gKDAuOSAqIGJvYXJkV2lkdGgpIC8gNDAgOiBib2FyZFdpZHRoIC8gNDAsIG1hcmtlckVuZDogYHVybCgjYXJyb3doZWFkLSR7aX0pYCB9KV0gfSwgYCR7YXJyb3dTdGFydEZpZWxkfS0ke2Fycm93RW5kRmllbGR9JHtpc0Fycm93QWN0aXZlID8gXCItYWN0aXZlXCIgOiBcIlwifWApKTtcclxuICAgICAgICB9KSB9KSkpO1xyXG59O1xuXG5mdW5jdGlvbiBQcm9tb3Rpb25PcHRpb24oeyBvcHRpb24gfSkge1xyXG4gICAgY29uc3QgW2lzSG92ZXIsIHNldElzSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgY3VzdG9tRGFya1NxdWFyZVN0eWxlLCBjdXN0b21MaWdodFNxdWFyZVN0eWxlLCBoYW5kbGVTZXRQb3NpdGlvbiwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCwgcHJvbW90ZUZyb21TcXVhcmUsIHByb21vdGVUb1NxdWFyZSwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9ICgpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKG9wdGlvblsxXSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbURhcmtTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tTGlnaHRTcXVhcmVTdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGNhc2UgXCJOXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbW90aW9uRGlhbG9nVmFyaWFudCA9PT0gXCJkZWZhdWx0XCJcclxuICAgICAgICAgICAgICAgICAgICA/IGN1c3RvbUxpZ2h0U3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICBjYXNlIFwiQlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21vdGlvbkRpYWxvZ1ZhcmlhbnQgPT09IFwiZGVmYXVsdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjdXN0b21EYXJrU3F1YXJlU3R5bGUuYmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjdXN0b21MaWdodFNxdWFyZVN0eWxlLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9uUHJvbW90aW9uUGllY2VTZWxlY3Qob3B0aW9uLCBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlRnJvbVNxdWFyZSAhPT0gdm9pZCAwID8gcHJvbW90ZUZyb21TcXVhcmUgOiB1bmRlZmluZWQsIHByb21vdGVUb1NxdWFyZSAhPT0gbnVsbCAmJiBwcm9tb3RlVG9TcXVhcmUgIT09IHZvaWQgMCA/IHByb21vdGVUb1NxdWFyZSA6IHVuZGVmaW5lZCkpXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXRQb3NpdGlvbihwcm9tb3RlRnJvbVNxdWFyZSwgcHJvbW90ZVRvU3F1YXJlLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sIG9uTW91c2VPdmVyOiAoKSA9PiBzZXRJc0hvdmVyKHRydWUpLCBvbk1vdXNlT3V0OiAoKSA9PiBzZXRJc0hvdmVyKGZhbHNlKSwgXCJkYXRhLXBpZWNlXCI6IG9wdGlvbiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0hvdmVyID8gYmFja2dyb3VuZENvbG9yKCkgOiBgJHtiYWNrZ3JvdW5kQ29sb3IoKX1hYWAsXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC4xcyBlYXNlLW91dFwiLFxyXG4gICAgICAgIH0gfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW29wdGlvbl0gPT09IFwiZnVuY3Rpb25cIiA/IChqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBcImFsbCAwLjFzIGVhc2Utb3V0XCIsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGlzSG92ZXIgPyBcInNjYWxlKDEpXCIgOiBcInNjYWxlKDAuODUpXCIsXHJcbiAgICAgICAgICAgIH0gfSwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbb3B0aW9uXSh7XHJcbiAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aDogYm9hcmRXaWR0aCAvIDgsXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgfSkgfSkpKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiBib2FyZFdpZHRoIC8gOCwgaGVpZ2h0OiBib2FyZFdpZHRoIC8gOCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYWxsIDAuMXMgZWFzZS1vdXRcIixcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogaXNIb3ZlciA/IFwic2NhbGUoMSlcIiA6IFwic2NhbGUoMC44NSlcIixcclxuICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGNoZXNzUGllY2VzW29wdGlvbl0gfSkgfSkpKSB9KSkpO1xyXG59XG5cbmZ1bmN0aW9uIFByb21vdGlvbkRpYWxvZygpIHtcclxuICAgIGNvbnN0IHsgYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgcHJvbW90aW9uRGlhbG9nVmFyaWFudCwgcHJvbW90ZVRvU3F1YXJlLCB9ID0gdXNlQ2hlc3Nib2FyZCgpO1xyXG4gICAgY29uc3QgcHJvbW90ZVBpZWNlQ29sb3IgPSAocHJvbW90ZVRvU3F1YXJlID09PSBudWxsIHx8IHByb21vdGVUb1NxdWFyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZVRvU3F1YXJlWzFdKSA9PT0gXCIxXCIgPyBcImJcIiA6IFwid1wiO1xyXG4gICAgY29uc3QgcHJvbW90aW9uT3B0aW9ucyA9IFtcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1RYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1SYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1OYCxcclxuICAgICAgICBgJHtwcm9tb3RlUGllY2VDb2xvciAhPT0gbnVsbCAmJiBwcm9tb3RlUGllY2VDb2xvciAhPT0gdm9pZCAwID8gcHJvbW90ZVBpZWNlQ29sb3IgOiBcIndcIn1CYCxcclxuICAgIF07XHJcbiAgICBjb25zdCBkaWFsb2dTdHlsZXMgPSB7XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcclxuICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogXCIxZnIgMWZyXCIsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gOH1weCwgJHstYm9hcmRXaWR0aCAvIDh9cHgpYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgkey1ib2FyZFdpZHRoIC8gMTZ9cHgsICR7LWJvYXJkV2lkdGggLyAxNn1weClgLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kYWw6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoMHB4LCAkeygzICogYm9hcmRXaWR0aCkgLyA4fXB4KWAsXHJcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtib2FyZFdpZHRoIC8gNH1weGAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBkaWFsb2dDb29yZHMgPSBnZXRSZWxhdGl2ZUNvb3Jkcyhib2FyZE9yaWVudGF0aW9uLCBib2FyZFdpZHRoLCBwcm9tb3RlVG9TcXVhcmUgfHwgXCJhOFwiKTtcclxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogYCR7ZGlhbG9nQ29vcmRzID09PSBudWxsIHx8IGRpYWxvZ0Nvb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlhbG9nQ29vcmRzLnl9cHhgLCBsZWZ0OiBgJHtkaWFsb2dDb29yZHMgPT09IG51bGwgfHwgZGlhbG9nQ29vcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaWFsb2dDb29yZHMueH1weGAsIHpJbmRleDogMTAwMCB9LCBkaWFsb2dTdHlsZXNbcHJvbW90aW9uRGlhbG9nVmFyaWFudF0pLCB0aXRsZTogXCJDaG9vc2UgcHJvbW90aW9uIHBpZWNlXCIgfSwgeyBjaGlsZHJlbjogcHJvbW90aW9uT3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKGpzeChQcm9tb3Rpb25PcHRpb24sIHsgb3B0aW9uOiBvcHRpb24gfSwgb3B0aW9uKSkpIH0pKSk7XHJcbn1cblxuY29uc3QgZXJyb3JJbWFnZSA9IHtcclxuICAgIHdoaXRlS2luZzogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIHRleHRSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgICAgICAgIGltYWdlUmVuZGVyaW5nOiBcImNyaXNwLWVkZ2VzXCIsXHJcbiAgICAgICAgfSwgdmlld0JveDogXCIwIDAgNDIxMCAxMjk3MFwiLCB4OiBcIjBweFwiLCB5OiBcIjBweFwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGNsaXBSdWxlOiBcImV2ZW5vZGRcIiwgd2lkdGg6IFwiMjUwXCIsIGhlaWdodDogXCIyNTBcIiB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUnVsZTogXCJub256ZXJvXCIsXHJcbiAgICAgICAgICAgICAgICB9LCBkOiBcIk0yMTA1IDBjMTY5LDAgMjg2LDE2MCAyNDksMzE1bDIwMCAwYy0xNzIsMjY2IC0yMzEsNDc5IC0yNTYsNzkyIDMxNSwtMjQgNTMwLC04NiA3OTIsLTI1NWwwIDg5N2MtMjY1LC0xNzEgLTQ3OSwtMjMxIC03OTIsLTI1NiAxOCwyMzQgNzUsNDk1IDE4NSw2ODJsMzM5IDBjMjMzLDAgMzY5LDI2OSAyMjUsNDU2bDU0NSAwIC01OTUgMTkxNmMxMzAsOTQgMTU4LDI3NSA1OSw0MDIgNDY1LDAgNDE2LDU2OCA1MSw1NjhsLTMzNCAwIDQ2NSAyODY3IDMzMiAwYzI1MCwwIDM4MSwzMDYgMTk5LDQ4NSAxNjIsNjMgMjczLDIyMCAyNzMsMzk5bDAgNjMzIDE2OCAwIDAgNDc1Yy0xNDAzLDAgLTI4MDcsMCAtNDIxMCwwbDAgLTQ3NSAxNjcgMCAwIC02MzNjMCwtMTc5IDExMiwtMzM2IDI3NCwtMzk5IC0xODEsLTE3OCAtNTIsLTQ4NSAxOTksLTQ4NWwzMzIgMCA0NjUgLTI4NjcgLTMzNSAwYy0zNTMsMCAtNDE4LC01NjggNTEsLTU2OCAtOTgsLTEyNyAtNzAsLTMwOCA1OSwtNDAybC01OTQgLTE5MTZjMTgxLDAgMzYzLDAgNTQ1LDAgLTE0NCwtMTg3IC05LC00NTYgMjI1LC00NTZsMzM5IDBjMTEwLC0xODcgMTY3LC00NDggMTg1LC02ODIgLTMxNSwyNSAtNTMwLDg3IC03OTMsMjU2bDAgLTg5N2MyNjYsMTcxIDQ4MCwyMzEgNzkzLDI1NSAtMjUsLTMxNSAtODcsLTUyOSAtMjU2LC03OTJsMTk5IDBjLTM2LC0xNTUgODEsLTMxNSAyNTAsLTMxNXptLTE5OTQgMTAwMTJsMCAyNTMgMzk4OCAwIDAgLTI1M2MtMTMzMCwwIC0yNjU5LDAgLTM5ODgsMHptNDg0IC0xMDYwYy0xNzQsMCAtMzE2LDE0MiAtMzE2LDMxNmwwIDYzMyAzNjUyIDAgMCAtNjMzYzAsLTE3NCAtMTQyLC0zMTYgLTMxNiwtMzE2IC0xMDA3LDAgLTIwMTMsMCAtMzAyMCwwem00NSAtNDU3Yy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwyOTMwIDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC05NzcsMCAtMTk1MywwIC0yOTMwLDB6bTIwMjAgLTI5NzhsLTExMTEgMCAtNDY1IDI4NjcgMjA0MSAwIC00NjUgLTI4Njd6bS0xNTU4IC00NTZjLTIyOSwwIC0yMjQsMzQ1IDAsMzQ1IDY2OSwwIDEzMzcsMCAyMDA1LDAgMjMwLDAgMjI1LC0zNDUgMCwtMzQ1IC02NjgsMCAtMTMzNiwwIC0yMDA1LDB6bTE3MzAgLTQ1N2wtMTQ1NCAwYy0yMjksMCAtMjI0LDM0NSAwLDM0NWwxNDU0IDBjMjI5LDAgMjI0LC0zNDUgMCwtMzQ1em0tMjA2NCAtMTg2Mmw1NDQgMTc1MWM1MjksMCAxMDU3LDAgMTU4NiwwbDU0NCAtMTc1MWMtODkyLDAgLTE3ODMsMCAtMjY3NCwwem0xMDg1IC01NjdsNTA0IDBjLTEyNiwtMjQ3IC0xNjMsLTUyNiAtMTc3LC04MDAgMjczLDE1IDU1Myw1MiA4MDAsMTc3bDAgLTUwNGMtMjQ3LDEyNiAtNTI3LDE2MyAtODAwLDE3NyAxNCwtMjczIDUxLC01NTIgMTc3LC03OTkgLTE2OCwwIC0zMzYsMCAtNTA0LDAgMTI1LDI0NyAxNjIsNTI2IDE3Nyw3OTkgLTI3NCwtMTQgLTU1MywtNTEgLTgwMCwtMTc3bDAgNTA0YzI0NywtMTI1IDUyNywtMTYyIDgwMCwtMTc3IC0xNSwyNzQgLTUyLDU1MyAtMTc3LDgwMHptOTY5IDExMWwtMTQzNCAwYy0yMzAsMCAtMjI1LDM0NSAwLDM0NWwxNDM0IDBjMjMwLDAgMjI1LC0zNDUgMCwtMzQ1em0tNzE3IC0yMTc1Yy0xMDUsMCAtMTc1LDEwOSAtMTMzLDIwNGwyNjYgMGM0MiwtOTYgLTMwLC0yMDUgLTEzMywtMjA0elwiIH0pIH0pIH0pKSksXHJcbn07XG5cbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBjaGlsZHJlbiB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBqc3goV2hpdGVLaW5nLCB7IHNob3dFcnJvcjogdHJ1ZSB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBXaGl0ZUtpbmcoeyBzaG93RXJyb3IgPSBmYWxzZSB9KSB7XHJcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcclxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1MCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKDkwZGVnKVwiLFxyXG4gICAgICAgICAgICAgICAgfSB9LCB7IGNoaWxkcmVuOiBlcnJvckltYWdlLndoaXRlS2luZyB9KSksIHNob3dFcnJvciAmJiBqc3goXCJoMVwiLCB7IGNoaWxkcmVuOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nXCIgfSldIH0pKSk7XHJcbn1cblxuZnVuY3Rpb24gQm9hcmQoKSB7XHJcbiAgICBjb25zdCBib2FyZFJlZiA9IHVzZVJlZihudWxsKTtcclxuICAgIGNvbnN0IHsgYm9hcmRXaWR0aCwgY2xlYXJDdXJyZW50UmlnaHRDbGlja0Rvd24sIG9uUHJvbW90aW9uUGllY2VTZWxlY3QsIHNldFNob3dQcm9tb3RlRGlhbG9nLCBzaG93UHJvbW90ZURpYWxvZywgY3VzdG9tQm9hcmRTdHlsZSwgfSA9IHVzZUNoZXNzYm9hcmQoKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2tPdXRzaWRlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChib2FyZFJlZi5jdXJyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAhYm9hcmRSZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckN1cnJlbnRSaWdodENsaWNrRG93bigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZUNsaWNrT3V0c2lkZSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgaGFuZGxlQ2xpY2tPdXRzaWRlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIGJvYXJkV2lkdGggPyAoanN4KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBzdHlsZTogeyBwZXJzcGVjdGl2ZTogXCIxMDAwcHhcIiB9IH0sIHsgY2hpbGRyZW46IGpzeHMoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogYm9hcmRSZWYsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIGJvYXJkU3R5bGVzKGJvYXJkV2lkdGgpKSwgY3VzdG9tQm9hcmRTdHlsZSkgfSwgeyBjaGlsZHJlbjogW2pzeChTcXVhcmVzLCB7fSksIGpzeChBcnJvd3MsIHt9KSwgc2hvd1Byb21vdGVEaWFsb2cgJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1Byb21vdGVEaWFsb2coZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvbW90aW9uUGllY2VTZWxlY3QgPT09IG51bGwgfHwgb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Qcm9tb3Rpb25QaWVjZVNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBcIjEwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDIyLDIxLDE4LC43KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib2FyZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm9hcmRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChQcm9tb3Rpb25EaWFsb2csIHt9KV0gfSkpXSB9KSkgfSkpKSA6IChqc3goV2hpdGVLaW5nLCB7fSkpO1xyXG59XHJcbmNvbnN0IGJvYXJkU3R5bGVzID0gKHdpZHRoKSA9PiAoe1xyXG4gICAgY3Vyc29yOiBcImRlZmF1bHRcIixcclxuICAgIGhlaWdodDogd2lkdGgsXHJcbiAgICB3aWR0aCxcclxufSk7XG5cbnZhciBMaXN0ZW5lclR5cGU7XG4oZnVuY3Rpb24oTGlzdGVuZXJUeXBlKSB7XG4gICAgTGlzdGVuZXJUeXBlW1wibW91c2VcIl0gPSBcIm1vdXNlXCI7XG4gICAgTGlzdGVuZXJUeXBlW1widG91Y2hcIl0gPSBcInRvdWNoXCI7XG4gICAgTGlzdGVuZXJUeXBlW1wia2V5Ym9hcmRcIl0gPSBcImtleWJvYXJkXCI7XG59KShMaXN0ZW5lclR5cGUgfHwgKExpc3RlbmVyVHlwZSA9IHt9KSk7XG5cbmNsYXNzIE9wdGlvbnNSZWFkZXIge1xuICAgIGdldCBkZWxheSgpIHtcbiAgICAgICAgdmFyIF9kZWxheTtcbiAgICAgICAgcmV0dXJuIChfZGVsYXkgPSB0aGlzLmFyZ3MuZGVsYXkpICE9PSBudWxsICYmIF9kZWxheSAhPT0gdm9pZCAwID8gX2RlbGF5IDogMDtcbiAgICB9XG4gICAgZ2V0IHNjcm9sbEFuZ2xlUmFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNjcm9sbEFuZ2xlUmFuZ2VzO1xuICAgIH1cbiAgICBnZXQgZ2V0RHJvcFRhcmdldEVsZW1lbnRzQXRQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50O1xuICAgIH1cbiAgICBnZXQgaWdub3JlQ29udGV4dE1lbnUoKSB7XG4gICAgICAgIHZhciBfaWdub3JlQ29udGV4dE1lbnU7XG4gICAgICAgIHJldHVybiAoX2lnbm9yZUNvbnRleHRNZW51ID0gdGhpcy5hcmdzLmlnbm9yZUNvbnRleHRNZW51KSAhPT0gbnVsbCAmJiBfaWdub3JlQ29udGV4dE1lbnUgIT09IHZvaWQgMCA/IF9pZ25vcmVDb250ZXh0TWVudSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0KCkge1xuICAgICAgICB2YXIgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldDtcbiAgICAgICAgcmV0dXJuIChfZW5hYmxlSG92ZXJPdXRzaWRlVGFyZ2V0ID0gdGhpcy5hcmdzLmVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCkgIT09IG51bGwgJiYgX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCAhPT0gdm9pZCAwID8gX2VuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlS2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlS2V5Ym9hcmRFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZUtleWJvYXJkRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZUtleWJvYXJkRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlS2V5Ym9hcmRFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVLZXlib2FyZEV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlTW91c2VFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlTW91c2VFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZU1vdXNlRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZU1vdXNlRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlTW91c2VFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVNb3VzZUV2ZW50cyA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZW5hYmxlVG91Y2hFdmVudHMoKSB7XG4gICAgICAgIHZhciBfZW5hYmxlVG91Y2hFdmVudHM7XG4gICAgICAgIHJldHVybiAoX2VuYWJsZVRvdWNoRXZlbnRzID0gdGhpcy5hcmdzLmVuYWJsZVRvdWNoRXZlbnRzKSAhPT0gbnVsbCAmJiBfZW5hYmxlVG91Y2hFdmVudHMgIT09IHZvaWQgMCA/IF9lbmFibGVUb3VjaEV2ZW50cyA6IHRydWU7XG4gICAgfVxuICAgIGdldCB0b3VjaFNsb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3MudG91Y2hTbG9wIHx8IDA7XG4gICAgfVxuICAgIGdldCBkZWxheVRvdWNoU3RhcnQoKSB7XG4gICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICByZXR1cm4gKHJlZjMgPSAocmVmMiA9IChyZWYgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRlbGF5VG91Y2hTdGFydCkgIT09IG51bGwgJiYgcmVmMiAhPT0gdm9pZCAwID8gcmVmMiA6IChyZWYxID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmRlbGF5KSAhPT0gbnVsbCAmJiByZWYzICE9PSB2b2lkIDAgPyByZWYzIDogMDtcbiAgICB9XG4gICAgZ2V0IGRlbGF5TW91c2VTdGFydCgpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmNDtcbiAgICAgICAgdmFyIHJlZjUsIHJlZjY7XG4gICAgICAgIHJldHVybiAocmVmNiA9IChyZWY1ID0gKHJlZiA9IHRoaXMuYXJncykgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuZGVsYXlNb3VzZVN0YXJ0KSAhPT0gbnVsbCAmJiByZWY1ICE9PSB2b2lkIDAgPyByZWY1IDogKHJlZjQgPSB0aGlzLmFyZ3MpID09PSBudWxsIHx8IHJlZjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjQuZGVsYXkpICE9PSBudWxsICYmIHJlZjYgIT09IHZvaWQgMCA/IHJlZjYgOiAwO1xuICAgIH1cbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0ICYmIHRoaXMuY29udGV4dC53aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQud2luZG93O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBkb2N1bWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKChyZWYgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByb290RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5hcmdzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5yb290RWxlbWVudCkgfHwgdGhpcy5kb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXJncywgY29udGV4dCl7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coTWF0aC5hYnMoeDIgLSB4MSksIDIpICsgTWF0aC5wb3coTWF0aC5hYnMoeTIgLSB5MSksIDIpKTtcbn1cbmZ1bmN0aW9uIGluQW5nbGVSYW5nZXMoeDEsIHkxLCB4MiwgeTIsIGFuZ2xlUmFuZ2VzKSB7XG4gICAgaWYgKCFhbmdsZVJhbmdlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCAvIE1hdGguUEkgKyAxODA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFuZ2xlUmFuZ2VzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgY29uc3QgYXIgPSBhbmdsZVJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGFyICYmIChhci5zdGFydCA9PSBudWxsIHx8IGFuZ2xlID49IGFyLnN0YXJ0KSAmJiAoYXIuZW5kID09IG51bGwgfHwgYW5nbGUgPD0gYXIuZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBVc2VkIGZvciBNb3VzZUV2ZW50LmJ1dHRvbnMgKG5vdGUgdGhlIHMgb24gdGhlIGVuZCkuXG5jb25zdCBNb3VzZUJ1dHRvbnMgPSB7XG4gICAgTGVmdDogMSxcbiAgICBSaWdodDogMixcbiAgICBDZW50ZXI6IDRcbn07XG4vLyBVc2VkIGZvciBlLmJ1dHRvbiAobm90ZSB0aGUgbGFjayBvZiBhbiBzIG9uIHRoZSBlbmQpLlxuY29uc3QgTW91c2VCdXR0b24gPSB7XG4gICAgTGVmdDogMCxcbiAgICBDZW50ZXI6IDEsXG4gICAgUmlnaHQ6IDJcbn07XG4vKipcbiAqIE9ubHkgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMgd2hlcmUgdGhlIGxlZnQgYnV0dG9uIGlzIHByZXNzZWQgc2hvdWxkIGluaXRpYXRlIGEgZHJhZy5cbiAqIEBwYXJhbSB7TW91c2VFdmVudCB8IFRvdWNoRXZlbnR9IGUgVGhlIGV2ZW50XG4gKi8gZnVuY3Rpb24gZXZlbnRTaG91bGRTdGFydERyYWcoZSkge1xuICAgIC8vIEZvciB0b3VjaCBldmVudHMsIGJ1dHRvbiB3aWxsIGJlIHVuZGVmaW5lZC4gSWYgZS5idXR0b24gaXMgZGVmaW5lZCxcbiAgICAvLyB0aGVuIGl0IHNob3VsZCBiZSBNb3VzZUJ1dHRvbi5MZWZ0LlxuICAgIHJldHVybiBlLmJ1dHRvbiA9PT0gdW5kZWZpbmVkIHx8IGUuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5MZWZ0O1xufVxuLyoqXG4gKiBPbmx5IHRvdWNoIGV2ZW50cyBhbmQgbW91c2UgZXZlbnRzIHdoZXJlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBpcyBubyBsb25nZXIgaGVsZCBzaG91bGQgZW5kIGEgZHJhZy5cbiAqIEl0J3MgcG9zc2libGUgdGhlIHVzZXIgbW91c2UgZG93bnMgd2l0aCB0aGUgbGVmdCBtb3VzZSBidXR0b24sIHRoZW4gbW91c2UgZG93biBhbmQgdXBzIHdpdGggdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbi5cbiAqIFdlIGRvbid0IHdhbnQgcmVsZWFzaW5nIHRoZSByaWdodCBtb3VzZSBidXR0b24gdG8gZW5kIHRoZSBkcmFnLlxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZSBUaGUgZXZlbnRcbiAqLyBmdW5jdGlvbiBldmVudFNob3VsZEVuZERyYWcoZSkge1xuICAgIC8vIFRvdWNoIGV2ZW50cyB3aWxsIGhhdmUgYnV0dG9ucyBiZSB1bmRlZmluZWQsIHdoaWxlIG1vdXNlIGV2ZW50cyB3aWxsIGhhdmUgZS5idXR0b25zJ3MgbGVmdCBidXR0b25cbiAgICAvLyBiaXQgZmllbGQgdW5zZXQgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGhhcyBiZWVuIHJlbGVhc2VkXG4gICAgcmV0dXJuIGUuYnV0dG9ucyA9PT0gdW5kZWZpbmVkIHx8IChlLmJ1dHRvbnMgJiBNb3VzZUJ1dHRvbnMuTGVmdCkgPT09IDA7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZSkge1xuICAgIHJldHVybiAhIWUudGFyZ2V0VG91Y2hlcztcbn1cblxuY29uc3QgRUxFTUVOVF9OT0RFID0gMTtcbmZ1bmN0aW9uIGdldE5vZGVDbGllbnRPZmZzZXQobm9kZSkge1xuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFID8gbm9kZSA6IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgdG9wICwgbGVmdCAgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFdmVudENsaWVudFRvdWNoT2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUudGFyZ2V0VG91Y2hlc1swXSk7XG4gICAgfSBlbHNlIGlmIChsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0udGFyZ2V0ID09PSBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjay50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFdmVudENsaWVudE9mZnNldChlLnRvdWNoZXNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUsIGxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrKSB7XG4gICAgaWYgKGlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICByZXR1cm4gZ2V0RXZlbnRDbGllbnRUb3VjaE9mZnNldChlLCBsYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3Qgc3VwcG9ydHNQYXNzaXZlID0gKCgpPT57XG4gICAgLy8gc2ltdWxhciB0byBqUXVlcnkncyB0ZXN0XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCAoKT0+e1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufSkoKTtcblxuY29uc3QgZXZlbnROYW1lcyA9IHtcbiAgICBbTGlzdGVuZXJUeXBlLm1vdXNlXToge1xuICAgICAgICBzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgICAgICBlbmQ6ICdtb3VzZXVwJyxcbiAgICAgICAgY29udGV4dG1lbnU6ICdjb250ZXh0bWVudSdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUudG91Y2hdOiB7XG4gICAgICAgIHN0YXJ0OiAndG91Y2hzdGFydCcsXG4gICAgICAgIG1vdmU6ICd0b3VjaG1vdmUnLFxuICAgICAgICBlbmQ6ICd0b3VjaGVuZCdcbiAgICB9LFxuICAgIFtMaXN0ZW5lclR5cGUua2V5Ym9hcmRdOiB7XG4gICAgICAgIGtleWRvd246ICdrZXlkb3duJ1xuICAgIH1cbn07XG5jbGFzcyBUb3VjaEJhY2tlbmRJbXBsIHtcbiAgICAvKipcblx0ICogR2VuZXJhdGUgcHJvZmlsaW5nIHN0YXRpc3RpY3MgZm9yIHRoZSBIVE1MNUJhY2tlbmQuXG5cdCAqLyBwcm9maWxlKCkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlTm9kZXM6IHRoaXMuc291cmNlTm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZXMuc2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZVByZXZpZXdOb2RlT3B0aW9uczogdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGVzOiB0aGlzLnRhcmdldE5vZGVzLnNpemUsXG4gICAgICAgICAgICBkcmFnT3ZlclRhcmdldElkczogKChyZWYgPSB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5sZW5ndGgpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcHVibGljIGZvciB0ZXN0XG4gICAgZ2V0IGRvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRvY3VtZW50O1xuICAgIH1cbiAgICBzZXR1cCgpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KCFUb3VjaEJhY2tlbmRJbXBsLmlzU2V0VXAsICdDYW5ub3QgaGF2ZSB0d28gVG91Y2ggYmFja2VuZHMgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuZ2V0VG9wTW92ZVN0YXJ0SGFuZGxlcigpKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHJvb3QsICdzdGFydCcsIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW92ZScsIHRoaXMuaGFuZGxlVG9wTW92ZUNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2VuZCcsIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZU1vdXNlRXZlbnRzICYmICF0aGlzLm9wdGlvbnMuaWdub3JlQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnY29udGV4dG1lbnUnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMub3B0aW9ucy5yb290RWxlbWVudDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVG91Y2hCYWNrZW5kSW1wbC5pc1NldFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihyb290LCAnc3RhcnQnLCB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydENhcHR1cmUsIHRydWUpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ3N0YXJ0JywgdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdmUnLCB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdtb3ZlJywgdGhpcy5oYW5kbGVUb3BNb3ZlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdlbmQnLCB0aGlzLmhhbmRsZVRvcE1vdmVFbmRDYXB0dXJlLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVNb3VzZUV2ZW50cyAmJiAhdGhpcy5vcHRpb25zLmlnbm9yZUNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIocm9vdCwgJ2NvbnRleHRtZW51JywgdGhpcy5oYW5kbGVUb3BNb3ZlRW5kQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVLZXlib2FyZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsICdrZXlkb3duJywgdGhpcy5oYW5kbGVDYW5jZWxPbkVzY2FwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIoc3ViamVjdCwgZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBjYXB0dXJlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGV2ZW50TmFtZXNbbGlzdGVuZXJUeXBlXVtldmVudF07XG4gICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgc3ViamVjdC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHN1YmplY3QsIGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogY2FwdHVyZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBldnQgPSBldmVudE5hbWVzW2xpc3RlbmVyVHlwZV1bZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgIHN1YmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdERyYWdTb3VyY2Uoc291cmNlSWQsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlTW92ZVN0YXJ0ID0gdGhpcy5oYW5kbGVNb3ZlU3RhcnQuYmluZCh0aGlzLCBzb3VyY2VJZCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMuc2V0KHNvdXJjZUlkLCBub2RlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsICdzdGFydCcsIGhhbmRsZU1vdmVTdGFydCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbm5lY3REcmFnUHJldmlldyhzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5kZWxldGUoc291cmNlSWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0RHJvcFRhcmdldCh0YXJnZXRJZCwgbm9kZSkge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5vcHRpb25zLnJvb3RFbGVtZW50O1xuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgLyogbm9vcCAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZU1vdmUgPSAoZSk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5kb2N1bWVudCB8fCAhcm9vdCB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb29yZHM7XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIEdyYWIgdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgY3VycmVudCBtb3VzZS90b3VjaCBwb3NpdGlvblxuXHRcdFx0ICovIHN3aXRjaChlLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgZXZlbnROYW1lcy5tb3VzZS5tb3ZlOlxuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBldmVudE5hbWVzLnRvdWNoLm1vdmU6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6ICgocmVmID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jbGllbnRYKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogKChyZWYxID0gZS50b3VjaGVzWzBdKSA9PT0gbnVsbCB8fCByZWYxID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYxLmNsaWVudFkpIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcblx0XHRcdCAqIFVzZSB0aGUgY29vcmRpbmF0ZXMgdG8gZ3JhYiB0aGUgZWxlbWVudCB0aGUgZHJhZyBlbmRlZCBvbi5cblx0XHRcdCAqIElmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIGFzIHRoZSB0YXJnZXQgbm9kZSAob3IgYW55IG9mIGl0J3MgY2hpbGRyZW4pIHRoZW4gd2UgaGF2ZSBoaXQgYSBkcm9wIHRhcmdldCBhbmQgY2FuIGhhbmRsZSB0aGUgbW92ZS5cblx0XHRcdCAqLyBjb25zdCBkcm9wcGVkT24gPSBjb29yZHMgIT0gbnVsbCA/IHRoaXMuZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjb29yZHMueCwgY29vcmRzLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRNYXRjaCA9IGRyb3BwZWRPbiAmJiBub2RlLmNvbnRhaW5zKGRyb3BwZWRPbik7XG4gICAgICAgICAgICBpZiAoZHJvcHBlZE9uID09PSBub2RlIHx8IGNoaWxkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVNb3ZlKGUsIHRhcmdldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG5cdFx0ICogQXR0YWNoaW5nIHRoZSBldmVudCBsaXN0ZW5lciB0byB0aGUgYm9keSBzbyB0aGF0IHRvdWNobW92ZSB3aWxsIHdvcmsgd2hpbGUgZHJhZ2dpbmcgb3ZlciBtdWx0aXBsZSB0YXJnZXQgZWxlbWVudHMuXG5cdFx0ICovIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmRvY3VtZW50LmJvZHksICdtb3ZlJywgaGFuZGxlTW92ZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuc2V0KHRhcmdldElkLCBub2RlKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0Tm9kZXMuZGVsZXRlKHRhcmdldElkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb2N1bWVudC5ib2R5LCAnbW92ZScsIGhhbmRsZU1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRUb3BNb3ZlU3RhcnRIYW5kbGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWxheVRvdWNoU3RhcnQgJiYgIXRoaXMub3B0aW9ucy5kZWxheU1vdXNlU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnREZWxheTtcbiAgICB9XG4gICAgaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIobm9kZSkge1xuICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKT0+e1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgIW5vZGUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdXJyZWN0U291cmNlTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnZWRTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyLm9ic2VydmUobm9kZS5wYXJlbnRFbGVtZW50LCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VycmVjdFNvdXJjZU5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50ICYmIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZFNvdXJjZU5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXJlYWN0aWQnKTtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRyYWdnZWRTb3VyY2VOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmluc3RhbGxTb3VyY2VOb2RlUmVtb3ZhbE9ic2VydmVyKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZVJlbW92YWxPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kcmFnZ2VkU291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgY29udGV4dCwgb3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZ2V0U291cmNlQ2xpZW50T2Zmc2V0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuc291cmNlTm9kZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGdldE5vZGVDbGllbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZVN0YXJ0Q2FwdHVyZSA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZVN0YXJ0ID0gKHNvdXJjZUlkKT0+e1xuICAgICAgICAgICAgLy8gSnVzdCBiZWNhdXNlIHdlIHJlY2VpdmVkIGFuIGV2ZW50IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiB3ZSBuZWVkIHRvIGNvbGxlY3QgZHJhZyBzb3VyY2VzLlxuICAgICAgICAgICAgLy8gV2Ugb25seSBjb2xsZWN0IHN0YXJ0IGNvbGxlY3RpbmcgZHJhZyBzb3VyY2VzIG9uIHRvdWNoIGFuZCBsZWZ0IG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubW92ZVN0YXJ0U291cmNlSWRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzLnVuc2hpZnQoc291cmNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydCA9IChlKT0+e1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZFN0YXJ0RHJhZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IHByZW1hdHVyZWx5IHByZXZlbnREZWZhdWx0KCkgaGVyZSBzaW5jZSBpdCBtaWdodDpcbiAgICAgICAgICAgIC8vIDEuIE1lc3MgdXAgc2Nyb2xsaW5nXG4gICAgICAgICAgICAvLyAyLiBNZXNzIHVwIGxvbmcgdGFwICh3aGljaCBicmluZ3MgdXAgY29udGV4dCBtZW51KVxuICAgICAgICAgICAgLy8gMy4gSWYgdGhlcmUncyBhbiBhbmNob3IgbGluayBhcyBhIGNoaWxkLCB0YXAgd29uJ3QgYmUgdHJpZ2dlcmVkIG9uIGxpbmtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudE9mZnNldCA9IGdldEV2ZW50Q2xpZW50T2Zmc2V0KGUpO1xuICAgICAgICAgICAgaWYgKGNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayA9IGUudGFyZ2V0VG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQgPSBjbGllbnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JEZWxheSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVTdGFydERlbGF5ID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoIWV2ZW50U2hvdWxkU3RhcnREcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBlLnR5cGUgPT09IGV2ZW50TmFtZXMudG91Y2guc3RhcnQgPyB0aGlzLm9wdGlvbnMuZGVsYXlUb3VjaFN0YXJ0IDogdGhpcy5vcHRpb25zLmRlbGF5TW91c2VTdGFydDtcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVUb3BNb3ZlU3RhcnQuYmluZCh0aGlzLCBlKSwgZGVsYXkpO1xuICAgICAgICAgICAgdGhpcy53YWl0aW5nRm9yRGVsYXkgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmVDYXB0dXJlID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlID0gKF9ldnQsIHRhcmdldElkKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcE1vdmUgPSAoZTEpPT57XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnQgfHwgdGhpcy53YWl0aW5nRm9yRGVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IG1vdmVTdGFydFNvdXJjZUlkcyAsIGRyYWdPdmVyVGFyZ2V0SWRzICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZUhvdmVyT3V0c2lkZVRhcmdldCA9IHRoaXMub3B0aW9ucy5lbmFibGVIb3Zlck91dHNpZGVUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRPZmZzZXQgPSBnZXRFdmVudENsaWVudE9mZnNldChlMSwgdGhpcy5sYXN0VGFyZ2V0VG91Y2hGYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoIWNsaWVudE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0b3VjaCBtb3ZlIHN0YXJ0ZWQgYXMgYSBzY3JvbGwsIG9yIGlzIGlzIGJldHdlZW4gdGhlIHNjcm9sbCBhbmdsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbGluZyB8fCAhdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSAmJiBpbkFuZ2xlUmFuZ2VzKHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0LnggfHwgMCwgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQueSB8fCAwLCBjbGllbnRPZmZzZXQueCwgY2xpZW50T2Zmc2V0LnksIHRoaXMub3B0aW9ucy5zY3JvbGxBbmdsZVJhbmdlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIGFuZCB3ZSd2ZSBtb3ZlZCBhIGxpdHRsZSwgdGhhdCBjb3VudHMgYXMgYSBkcmFnIHN0YXJ0XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgdGhpcy5fbW91c2VDbGllbnRPZmZzZXQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBtb3ZlU3RhcnRTb3VyY2VJZHMgJiYgZGlzdGFuY2UodGhpcy5fbW91c2VDbGllbnRPZmZzZXQueCB8fCAwLCB0aGlzLl9tb3VzZUNsaWVudE9mZnNldC55IHx8IDAsIGNsaWVudE9mZnNldC54LCBjbGllbnRPZmZzZXQueSkgPiAodGhpcy5vcHRpb25zLnRvdWNoU2xvcCA/IHRoaXMub3B0aW9ucy50b3VjaFNsb3AgOiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5iZWdpbkRyYWcobW92ZVN0YXJ0U291cmNlSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogdGhpcy5fbW91c2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldFNvdXJjZUNsaWVudE9mZnNldDogdGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hTb3VyY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gdGhpcy5zb3VyY2VOb2Rlcy5nZXQodGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcihzb3VyY2VOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5wdWJsaXNoRHJhZ1NvdXJjZSgpO1xuICAgICAgICAgICAgaWYgKGUxLmNhbmNlbGFibGUpIGUxLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5vZGUgZWxlbWVudHMgb2YgdGhlIGhvdmVyZWQgRHJvcFRhcmdldHNcbiAgICAgICAgICAgIGNvbnN0IGRyYWdPdmVyVGFyZ2V0Tm9kZXMgPSAoZHJhZ092ZXJUYXJnZXRJZHMgfHwgW10pLm1hcCgoa2V5KT0+dGhpcy50YXJnZXROb2Rlcy5nZXQoa2V5KVxuICAgICAgICAgICAgKS5maWx0ZXIoKGUpPT4hIWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGEgb3JkZXJlZCBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRvdWNoZWQgYnlcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IHRoaXMub3B0aW9ucy5nZXREcm9wVGFyZ2V0RWxlbWVudHNBdFBvaW50ID8gdGhpcy5vcHRpb25zLmdldERyb3BUYXJnZXRFbGVtZW50c0F0UG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55LCBkcmFnT3ZlclRhcmdldE5vZGVzKSA6IHRoaXMuZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50T2Zmc2V0LngsIGNsaWVudE9mZnNldC55KTtcbiAgICAgICAgICAgIC8vIEV4dGVuZCBsaXN0IHdpdGggcGFyZW50cyB0aGF0IGFyZSBub3QgcmVjZWl2aW5nIGVsZW1lbnRzRnJvbVBvaW50IGV2ZW50cyAoc2l6ZSAwIGVsZW1lbnRzIGFuZCBzdmcgZ3JvdXBzKVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQgPSBbXTtcbiAgICAgICAgICAgIGZvcihjb25zdCBub2RlSWQgaW4gZWxlbWVudHNBdFBvaW50KXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50c0F0UG9pbnQuaGFzT3duUHJvcGVydHkobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudHNBdFBvaW50W25vZGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnROb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgZWxlbWVudHNBdFBvaW50RXh0ZW5kZWQuaW5kZXhPZihjdXJyZW50Tm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c0F0UG9pbnRFeHRlbmRlZC5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yZGVyZWREcmFnT3ZlclRhcmdldElkcyA9IGVsZW1lbnRzQXRQb2ludEV4dGVuZGVkLy8gRmlsdGVyIG9mZiBub2RlcyB0aGF0IGFyZW50IGEgaG92ZXJlZCBEcm9wVGFyZ2V0cyBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcigobm9kZSk9PmRyYWdPdmVyVGFyZ2V0Tm9kZXMuaW5kZXhPZihub2RlKSA+IC0xXG4gICAgICAgICAgICApLy8gTWFwIGJhY2sgdGhlIG5vZGVzIGVsZW1lbnRzIHRvIHRhcmdldElkc1xuICAgICAgICAgICAgLm1hcCgobm9kZSk9PnRoaXMuX2dldERyb3BUYXJnZXRJZChub2RlKVxuICAgICAgICAgICAgKS8vIEZpbHRlciBvZmYgcG9zc2libGUgbnVsbCByb3dzXG4gICAgICAgICAgICAuZmlsdGVyKChub2RlKT0+ISFub2RlXG4gICAgICAgICAgICApLmZpbHRlcigoaWQsIGluZGV4LCBpZHMpPT5pZHMuaW5kZXhPZihpZCkgPT09IGluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gSW52b2tlIGhvdmVyIGZvciBkcm9wIHRhcmdldHMgd2hlbiBzb3VyY2Ugbm9kZSBpcyBzdGlsbCBvdmVyIGFuZCBwb2ludGVyIGlzIG91dHNpZGVcbiAgICAgICAgICAgIGlmIChlbmFibGVIb3Zlck91dHNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgdGFyZ2V0SWQgaW4gdGhpcy50YXJnZXROb2Rlcyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLnRhcmdldE5vZGVzLmdldCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5jb250YWlucyhzb3VyY2VOb2RlKSAmJiBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMudW5zaGlmdCh0YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgYmVjYXVzZSBkbmQtY29yZSByZXZlcnNlIGl0IGJlZm9yZSBjYWxsaW5nIHRoZSBEcm9wVGFyZ2V0IGRyb3AgbWV0aG9kc1xuICAgICAgICAgICAgb3JkZXJlZERyYWdPdmVyVGFyZ2V0SWRzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5ob3ZlcihvcmRlcmVkRHJhZ092ZXJUYXJnZXRJZHMsIHtcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuXHQgKlxuXHQgKiB2aXNpYmxlIGZvciB0ZXN0aW5nXG5cdCAqLyB0aGlzLl9nZXREcm9wVGFyZ2V0SWQgPSAobm9kZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLnRhcmdldE5vZGVzLmtleXMoKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0ga2V5cy5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZShuZXh0LmRvbmUgPT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJZCA9IG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0Tm9kZXMuZ2V0KHRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGtleXMubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wTW92ZUVuZENhcHR1cmUgPSAoZSk9PntcbiAgICAgICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxhc3RUYXJnZXRUb3VjaEZhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCFldmVudFNob3VsZEVuZERyYWcoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkgfHwgdGhpcy5tb25pdG9yLmRpZERyb3AoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0U291cmNlSWRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgICAgICB0aGlzLnVuaW5zdGFsbFNvdXJjZU5vZGVSZW1vdmFsT2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5kcm9wKCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMuZW5kRHJhZygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbE9uRXNjYXBlID0gKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnICYmIHRoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUNsaWVudE9mZnNldCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsU291cmNlTm9kZVJlbW92YWxPYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zUmVhZGVyKG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBtYW5hZ2VyLmdldEFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50YXJnZXROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzID0gW107XG4gICAgICAgIHRoaXMuX21vdXNlQ2xpZW50T2Zmc2V0ID0ge307XG4gICAgICAgIHRoaXMuX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTW91c2VFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJUeXBlcy5wdXNoKExpc3RlbmVyVHlwZS5tb3VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lclR5cGVzLnB1c2goTGlzdGVuZXJUeXBlLnRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUtleWJvYXJkRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyVHlwZXMucHVzaChMaXN0ZW5lclR5cGUua2V5Ym9hcmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBUb3VjaEJhY2tlbmQgPSBmdW5jdGlvbiBjcmVhdGVCYWNrZW5kKG1hbmFnZXIsIGNvbnRleHQgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaEJhY2tlbmRJbXBsKG1hbmFnZXIsIGNvbnRleHQsIG9wdGlvbnMpO1xufTtcblxuY29uc3QgQ2hlc3Nib2FyZERuRENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHsgaXNDdXN0b21EbmRQcm92aWRlclNldDogZmFsc2UgfSk7XHJcbmNvbnN0IEVtcHR5UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxufTtcclxuY29uc3QgQ2hlc3Nib2FyZERuRFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGJhY2tlbmQsIGNvbnRleHQsIG9wdGlvbnMsIGRlYnVnTW9kZSwgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChqc3goQ2hlc3Nib2FyZERuRENvbnRleHQuUHJvdmlkZXIsIE9iamVjdC5hc3NpZ24oeyB2YWx1ZTogeyBpc0N1c3RvbURuZFByb3ZpZGVyU2V0OiB0cnVlIH0gfSwgeyBjaGlsZHJlbjoganN4KERuZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYmFja2VuZDogYmFja2VuZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgPyBUb3VjaEJhY2tlbmQgOiBIVE1MNUJhY2tlbmQpLCBjb250ZXh0OiBjb250ZXh0LCBvcHRpb25zOiBvcHRpb25zLCBkZWJ1Z01vZGU6IGRlYnVnTW9kZSAhPT0gbnVsbCAmJiBkZWJ1Z01vZGUgIT09IHZvaWQgMCA/IGRlYnVnTW9kZSA6IGZhbHNlIH0sIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKSB9KSkpO1xyXG59O1xyXG5jb25zdCBDaGVzc2JvYXJkRG5EUm9vdCA9ICh7IGN1c3RvbURuZEJhY2tlbmQsIGN1c3RvbURuZEJhY2tlbmRPcHRpb25zLCBjaGlsZHJlbiwgfSkgPT4ge1xyXG4gICAgY29uc3QgW2NsaWVudFdpbmRvdywgc2V0Q2xpZW50V2luZG93XSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBbYmFja2VuZFNldCwgc2V0QmFja2VuZFNldF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaXNNb2JpbGUsIHNldElzTW9iaWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgaXNDdXN0b21EbmRQcm92aWRlclNldCB9ID0gdXNlQ29udGV4dChDaGVzc2JvYXJkRG5EQ29udGV4dCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldElzTW9iaWxlKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KTtcclxuICAgICAgICBzZXRCYWNrZW5kU2V0KHRydWUpO1xyXG4gICAgICAgIHNldENsaWVudFdpbmRvdyh3aW5kb3cpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgLy8gaW4gY2FzZSB3ZSBhbHJlYWR5IHdyYXBwZWQgYDxDaGVzc2JvYXJkLz5gICB3aXRoIGA8RG5EUHJvdmlkZXIvPmAgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICBjb25zdCBEbkRXcmFwcGVyID0gaXNDdXN0b21EbmRQcm92aWRlclNldCA/IEVtcHR5UHJvdmlkZXIgOiBEbmRQcm92aWRlcjtcclxuICAgIGlmICghYmFja2VuZFNldCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsaWVudFdpbmRvdyA/IChqc3goRG5EV3JhcHBlciwgT2JqZWN0LmFzc2lnbih7IGJhY2tlbmQ6IGN1c3RvbURuZEJhY2tlbmQgfHwgKGlzTW9iaWxlID8gVG91Y2hCYWNrZW5kIDogSFRNTDVCYWNrZW5kKSwgY29udGV4dDogY2xpZW50V2luZG93LCBvcHRpb25zOiBjdXN0b21EbmRCYWNrZW5kID8gY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMgOiB1bmRlZmluZWQgfSwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkpKSA6IChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcclxufTtcblxuZnVuY3Rpb24gQ3VzdG9tRHJhZ0xheWVyKHsgYm9hcmRDb250YWluZXIgfSkge1xyXG4gICAgY29uc3QgeyBib2FyZFdpZHRoLCBjaGVzc1BpZWNlcywgaWQsIHNuYXBUb0N1cnNvciwgYWxsb3dEcmFnT3V0c2lkZUJvYXJkIH0gPSB1c2VDaGVzc2JvYXJkKCk7XHJcbiAgICBjb25zdCBjb2xsZWN0ZWRQcm9wcyA9IHVzZURyYWdMYXllcigobW9uaXRvcikgPT4gKHtcclxuICAgICAgICBpdGVtOiBtb25pdG9yLmdldEl0ZW0oKSxcclxuICAgICAgICBjbGllbnRPZmZzZXQ6IG1vbml0b3IuZ2V0Q2xpZW50T2Zmc2V0KCksXHJcbiAgICAgICAgc291cmNlQ2xpZW50T2Zmc2V0OiBtb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpLFxyXG4gICAgICAgIGlzRHJhZ2dpbmc6IG1vbml0b3IuaXNEcmFnZ2luZygpLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgeyBpc0RyYWdnaW5nLCBpdGVtLCBjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCwgfSA9IGNvbGxlY3RlZFByb3BzO1xyXG4gICAgY29uc3QgZ2V0SXRlbVN0eWxlID0gdXNlQ2FsbGJhY2soKGNsaWVudE9mZnNldCwgc291cmNlQ2xpZW50T2Zmc2V0KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjbGllbnRPZmZzZXQgfHwgIXNvdXJjZUNsaWVudE9mZnNldClcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcGxheTogXCJub25lXCIgfTtcclxuICAgICAgICBsZXQgeyB4LCB5IH0gPSBzbmFwVG9DdXJzb3IgPyBjbGllbnRPZmZzZXQgOiBzb3VyY2VDbGllbnRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgaGFsZlNxdWFyZVdpZHRoID0gYm9hcmRXaWR0aCAvIDggLyAyO1xyXG4gICAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcclxuICAgICAgICAgICAgeCAtPSBoYWxmU3F1YXJlV2lkdGg7XHJcbiAgICAgICAgICAgIHkgLT0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFsbG93RHJhZ091dHNpZGVCb2FyZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gYm9hcmRDb250YWluZXI7XHJcbiAgICAgICAgICAgIC8vIGhhbGYgc3F1YXJlIHNvIHRoZSBwaWVjZSByZWFjaGVzIHRoZSBib2FyZFxyXG4gICAgICAgICAgICBjb25zdCBtYXhMZWZ0ID0gbGVmdCAtIGhhbGZTcXVhcmVXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgbWF4VG9wID0gdG9wIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IGxlZnQgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhCb3R0b20gPSB0b3AgKyBib2FyZFdpZHRoIC0gaGFsZlNxdWFyZVdpZHRoO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5tYXgobWF4TGVmdCwgTWF0aC5taW4oeCwgbWF4UmlnaHQpKTtcclxuICAgICAgICAgICAgeSA9IE1hdGgubWF4KG1heFRvcCwgTWF0aC5taW4oeSwgbWF4Qm90dG9tKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtib2FyZFdpZHRoLCBhbGxvd0RyYWdPdXRzaWRlQm9hcmQsIHNuYXBUb0N1cnNvciwgYm9hcmRDb250YWluZXJdKTtcclxuICAgIHJldHVybiBpc0RyYWdnaW5nICYmIGl0ZW0uaWQgPT09IGlkID8gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcclxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXHJcbiAgICAgICAgICAgIHpJbmRleDogMTAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICB9IH0sIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgc3R5bGU6IGdldEl0ZW1TdHlsZShjbGllbnRPZmZzZXQsIHNvdXJjZUNsaWVudE9mZnNldCkgfSwgeyBjaGlsZHJlbjogdHlwZW9mIGNoZXNzUGllY2VzW2l0ZW0ucGllY2VdID09PSBcImZ1bmN0aW9uXCIgPyAoY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0oe1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlV2lkdGg6IGJvYXJkV2lkdGggLyA4LFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcclxuICAgICAgICAgICAgfSkpIDogKGpzeChcInN2Z1wiLCBPYmplY3QuYXNzaWduKHsgdmlld0JveDogXCIxIDEgNDMgNDNcIiwgd2lkdGg6IGJvYXJkV2lkdGggLyA4LCBoZWlnaHQ6IGJvYXJkV2lkdGggLyA4IH0sIHsgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjaGlsZHJlbjogY2hlc3NQaWVjZXNbaXRlbS5waWVjZV0gfSkgfSkpKSB9KSkgfSkpKSA6IG51bGw7XHJcbn1cblxuY29uc3QgU3BhcmVQaWVjZSA9ICh7IHBpZWNlLCB3aWR0aCwgY3VzdG9tUGllY2VKU1gsIGRuZElkLCB9KSA9PiB7XHJcbiAgICBjb25zdCByZW5kZXJQaWVjZSA9IGN1c3RvbVBpZWNlSlNYICE9PSBudWxsICYmIGN1c3RvbVBpZWNlSlNYICE9PSB2b2lkIDAgPyBjdXN0b21QaWVjZUpTWCA6IGRlZmF1bHRQaWVjZXNbcGllY2VdO1xyXG4gICAgY29uc3QgW3sgY2FuRHJhZywgaXNEcmFnZ2luZyB9LCBkcmFnLCBkcmFnUHJldmlld10gPSB1c2VEcmFnKCgpID0+ICh7XHJcbiAgICAgICAgdHlwZTogXCJwaWVjZVwiLFxyXG4gICAgICAgIGl0ZW06ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGllY2UsIGlzU3BhcmU6IHRydWUsIGlkOiBkbmRJZCB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdDogKG1vbml0b3IpID0+ICh7XHJcbiAgICAgICAgICAgIGNhbkRyYWc6IHRydWUsXHJcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6ICEhbW9uaXRvci5pc0RyYWdnaW5nKCksXHJcbiAgICAgICAgfSksXHJcbiAgICB9KSwgW3BpZWNlLCBkbmRJZF0pO1xyXG4gICAgLy8gaGlkZSB0aGUgZGVmYXVsdCBwcmV2aWV3XHJcbiAgICBkcmFnUHJldmlldyhnZXRFbXB0eUltYWdlKCksIHsgY2FwdHVyZURyYWdnaW5nU3RhdGU6IHRydWUgfSk7XHJcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgcmVmOiBjYW5EcmFnID8gZHJhZyA6IG51bGwsIFwiZGF0YS1waWVjZVwiOiBwaWVjZSwgc3R5bGU6IHsgY3Vyc29yOiBcIm1vdmVcIiB9IH0sIHsgY2hpbGRyZW46IHR5cGVvZiByZW5kZXJQaWVjZSA9PT0gXCJmdW5jdGlvblwiID8gKHJlbmRlclBpZWNlKHtcclxuICAgICAgICAgICAgc3F1YXJlV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBpc0RyYWdnaW5nLFxyXG4gICAgICAgIH0pKSA6IChqc3goXCJzdmdcIiwgT2JqZWN0LmFzc2lnbih7IHZpZXdCb3g6IFwiMSAxIDQzIDQzXCIsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiB3aWR0aCB9LCB7IGNoaWxkcmVuOiBqc3goXCJnXCIsIHsgY2hpbGRyZW46IHJlbmRlclBpZWNlIH0pIH0pKSkgfSkpKTtcclxufTtcblxuY29uc3QgQ2hlc3Nib2FyZCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcclxuICAgIGNvbnN0IHsgY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnMsIG9uQm9hcmRXaWR0aENoYW5nZSB9ID0gcHJvcHMsIG90aGVyUHJvcHMgPSBfX3Jlc3QocHJvcHMsIFtcImN1c3RvbURuZEJhY2tlbmRcIiwgXCJjdXN0b21EbmRCYWNrZW5kT3B0aW9uc1wiLCBcIm9uQm9hcmRXaWR0aENoYW5nZVwiXSk7XHJcbiAgICBjb25zdCBbYm9hcmRXaWR0aCwgc2V0Qm9hcmRXaWR0aF0gPSB1c2VTdGF0ZShwcm9wcy5ib2FyZFdpZHRoKTtcclxuICAgIGNvbnN0IGJvYXJkUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gICAgY29uc3QgYm9hcmRDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBbYm9hcmRDb250YWluZXJQb3MsIHNldEJvYXJkQ29udGFpbmVyUG9zXSA9IHVzZVN0YXRlKHtcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWV0cmljcyA9IHVzZU1lbW8oKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBib2FyZFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGJvYXJkV2lkdGggJiYgKG9uQm9hcmRXaWR0aENoYW5nZSA9PT0gbnVsbCB8fCBvbkJvYXJkV2lkdGhDaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQm9hcmRXaWR0aENoYW5nZShib2FyZFdpZHRoKSk7XHJcbiAgICB9LCBbYm9hcmRXaWR0aF0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRCb2FyZENvbnRhaW5lclBvcyh7XHJcbiAgICAgICAgICAgIGxlZnQ6IChtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCkgPyBtZXRyaWNzID09PSBudWxsIHx8IG1ldHJpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldHJpY3MubGVmdCA6IDAsXHJcbiAgICAgICAgICAgIHRvcDogKG1ldHJpY3MgPT09IG51bGwgfHwgbWV0cmljcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0cmljcy50b3ApID8gbWV0cmljcyA9PT0gbnVsbCB8fCBtZXRyaWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRyaWNzLnRvcCA6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbbWV0cmljc10pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHByb3BzLmJvYXJkV2lkdGggPT09IHVuZGVmaW5lZCAmJiAoKF9hID0gYm9hcmRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZnNldFdpZHRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBzZXRCb2FyZFdpZHRoKChfYSA9IGJvYXJkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGJvYXJkUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XHJcbiAgICByZXR1cm4gKGpzeChFcnJvckJvdW5kYXJ5LCB7IGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyByZWY6IGJvYXJkQ29udGFpbmVyUmVmLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICB9IH0sIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyByZWY6IGJvYXJkUmVmLCBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIgfSB9KSwganN4KENoZXNzYm9hcmREbkRSb290LCBPYmplY3QuYXNzaWduKHsgY3VzdG9tRG5kQmFja2VuZDogY3VzdG9tRG5kQmFja2VuZCwgY3VzdG9tRG5kQmFja2VuZE9wdGlvbnM6IGN1c3RvbURuZEJhY2tlbmRPcHRpb25zIH0sIHsgY2hpbGRyZW46IGJvYXJkV2lkdGggJiYgKGpzeHMoQ2hlc3Nib2FyZFByb3ZpZGVyLCBPYmplY3QuYXNzaWduKHsgYm9hcmRXaWR0aDogYm9hcmRXaWR0aCB9LCBvdGhlclByb3BzLCB7IHJlZjogcmVmIH0sIHsgY2hpbGRyZW46IFtqc3goQ3VzdG9tRHJhZ0xheWVyLCB7IGJvYXJkQ29udGFpbmVyOiBib2FyZENvbnRhaW5lclBvcyB9KSwganN4KEJvYXJkLCB7fSldIH0pKSkgfSkpXSB9KSkgfSkpO1xyXG59KTtcblxuZXhwb3J0IHsgQ2hlc3Nib2FyZCwgQ2hlc3Nib2FyZERuRFByb3ZpZGVyLCBTcGFyZVBpZWNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-chessboard/dist/index.esm.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fayushsinghchauhan%2FDownloads%2Fdont_delete%2Fcd3%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);