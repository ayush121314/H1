"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/hooks/useEscrow.ts":
/*!********************************!*\
  !*** ./src/hooks/useEscrow.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEscrow: function() { return /* binding */ useEscrow; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/EscrowContractAdapter */ \"./src/contracts/EscrowContractAdapter.ts\");\n\n\nfunction useEscrow() {\n    // Escrow adapter for blockchain interactions\n    const escrowAdapter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowContractAdapter(\"https://fullnode.testnet.aptoslabs.com/v1\", \"0x1\" // Default module address, would be replaced with actual deployed address\n        ), []);\n    // Escrow state\n    const [useSimulationMode, setUseSimulationMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // Default to false for production use\n    const [escrowLocked, setEscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player1EscrowLocked, setPlayer1EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player2EscrowLocked, setPlayer2EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [escrowAddress, setEscrowAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [escrowStatus, setEscrowStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    const [escrowBalance, setEscrowBalance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Initialize escrow\n    const initializeEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet)=>{\n        if (!player1Wallet || !player2Wallet) {\n            console.error(\"Cannot initialize escrow: both players must be connected\");\n            setError(\"Both players must be connected to initialize the escrow\");\n            return;\n        }\n        try {\n            setIsLoading(true);\n            console.log(\"Initializing escrow contract\");\n            // In simulation mode, just set a fake address\n            if (useSimulationMode) {\n                try {\n                    const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                    console.log(\"Creating simulated escrow with address:\", simulatedAddress);\n                    // Set the address in the adapter\n                    escrowAdapter.setEscrowAddress(simulatedAddress);\n                    // Set the address in our component state\n                    setEscrowAddress(simulatedAddress);\n                    console.log(\"Simulated escrow initialized with address:\", simulatedAddress);\n                    // Add a small delay to ensure state updates\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                    setIsLoading(false);\n                    return;\n                } catch (simError) {\n                    console.error(\"Error in simulation mode:\", simError);\n                // Continue to try real mode, but log the error\n                }\n            }\n            // Try connecting to Player 1's wallet\n            console.log(\"Attempting to connect to Player 1's wallet for escrow initialization\");\n            // Show prompt for wallet connection\n            window.alert(\"Please make sure a SEPARATE ESCROW wallet is selected in your Petra extension to initialize the escrow. This should NOT be the same as Player 1 or Player 2's wallet.\");\n            try {\n                const response = await window.aptos.connect();\n                // Check if this wallet is the same as player 1 or player 2\n                if (response && response.address === player1Wallet.address) {\n                    window.alert(\"Error: This wallet is the same as Player 1's wallet. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 1's wallet.\");\n                }\n                if (response && response.address === player2Wallet.address) {\n                    window.alert(\"Error: This wallet is the same as Player 2's wallet. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 2's wallet.\");\n                }\n                // Proceed with escrow initialization\n                if (response && response.address) {\n                    console.log(\"Connected to wallet, creating escrow\");\n                    const initializeEscrowResult = await escrowAdapter.initializeEscrow(window.aptos, player1Wallet.address, player2Wallet.address, 0.1, 24 * 60 * 60 // 24 hour timeout\n                    );\n                    if (initializeEscrowResult) {\n                        setEscrowAddress(initializeEscrowResult);\n                        console.log(\"Escrow contract created with address:\", initializeEscrowResult);\n                        setIsLoading(false);\n                        return;\n                    }\n                } else {\n                    console.warn(\"Connected to wrong wallet address:\", response === null || response === void 0 ? void 0 : response.address);\n                    throw new Error(\"Failed to connect wallet. Please make sure a valid wallet is selected.\");\n                }\n            } catch (error) {\n                console.error(\"Error with direct Petra connection:\", error);\n                throw error;\n            }\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            setError(error.message || \"Failed to initialize escrow\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Create a simulated escrow (for testing)\n    const createSimulatedEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!useSimulationMode) {\n            setError(\"Please enable simulation mode first\");\n            return;\n        }\n        console.log(\"Creating a simulated escrow for testing\");\n        const simulatedAddress = \"simulated_escrow_\" + Date.now();\n        escrowAdapter.setEscrowAddress(simulatedAddress);\n        setEscrowAddress(simulatedAddress);\n        console.log(\"Created simulated escrow with address:\", simulatedAddress);\n        // Also set escrow status to PENDING\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Connect escrow wallet\n    const connectEscrowWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting escrow wallet...\");\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension.\");\n                setIsLoading(false);\n                return;\n            }\n            // Prompt to select the escrow wallet\n            window.alert(\"Please make sure your ESCROW wallet is selected in your Petra extension.\\nIMPORTANT: This should be DIFFERENT from Player 1 and Player 2 wallets.\");\n            const response = await window.aptos.connect();\n            console.log(\"Escrow wallet connection response:\", response);\n            if (response && response.address) {\n                console.log(\"Connected to escrow wallet:\", response.address);\n                // Check if the wallet is the same as player 1 or player 2\n                if (player1Wallet && player1Wallet.address === response.address) {\n                    window.alert(\"Error: This wallet is already being used by Player 1. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 1's wallet.\");\n                }\n                if (player2Wallet && player2Wallet.address === response.address) {\n                    window.alert(\"Error: This wallet is already being used by Player 2. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 2's wallet.\");\n                }\n                // Set the escrow address in the adapter\n                escrowAdapter.setEscrowAddress(response.address);\n                // Set the address in component state\n                setEscrowAddress(response.address);\n                console.log(\"Escrow wallet set successfully:\", response.address);\n            } else {\n                throw new Error(\"Failed to get escrow wallet address\");\n            }\n        } catch (error) {\n            console.error(\"Error connecting escrow wallet:\", error);\n            setError(error.message || \"Failed to connect escrow wallet\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        escrowAdapter\n    ]);\n    // Lock the escrow by transferring the minimum bet amount from a specific player\n    const lockEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (playerNumber, player1Wallet, player2Wallet, player1Bet, player2Bet, ensureCorrectWalletConnected, getAccountBalance, transferToEscrow)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Starting escrow locking process for Player \".concat(playerNumber));\n            console.log(\"Current escrow lock status: Player 1: \".concat(player1EscrowLocked, \", Player 2: \").concat(player2EscrowLocked));\n            // Verify both players have placed bets\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must announce bets before locking escrow\");\n            }\n            // Determine the minimum bet amount (this is what will be deducted)\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Minimum bet amount between players: \".concat(minimumBet, \" APT\"));\n            // Get player wallet\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (!playerWallet) {\n                throw new Error(\"Player \".concat(playerNumber, \" wallet not connected\"));\n            }\n            // In simulation mode, create an escrow if not yet initialized\n            if (useSimulationMode && !escrowAddress) {\n                console.log(\"No escrow initialized yet, but in simulation mode. Creating escrow now...\");\n                const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                escrowAdapter.setEscrowAddress(simulatedAddress);\n                setEscrowAddress(simulatedAddress);\n                console.log(\"Auto-created simulated escrow with address:\", simulatedAddress);\n                // Brief pause to let state update\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            // Make sure an escrow address is set\n            if (!escrowAddress) {\n                throw new Error(\"No escrow wallet connected. Please connect the escrow wallet first.\");\n            }\n            console.log(\"Depositing \".concat(minimumBet, \" APT to escrow contract from Player \").concat(playerNumber));\n            // Use simulation mode if enabled\n            if (useSimulationMode) {\n                console.log(\"Using simulation mode - no actual transfer will occur\");\n                // Simulate deposit\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                } else {\n                    setPlayer2EscrowLocked(true);\n                }\n                console.log(\"Simulated escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance in simulation mode\n                setEscrowBalance((prevBalance)=>prevBalance + minimumBet);\n            } else {\n                // Real deposit by transferring funds to the escrow address\n                // Make sure the player's wallet is connected - strict verification\n                let maxAttempts = 3;\n                let isWalletConnected = false;\n                for(let attempt = 1; attempt <= maxAttempts; attempt++){\n                    isWalletConnected = await ensureCorrectWalletConnected(playerNumber);\n                    if (isWalletConnected) {\n                        break;\n                    }\n                    if (attempt < maxAttempts) {\n                        // Ask if they want to try again\n                        const shouldRetry = window.confirm(\"Failed to connect the correct wallet for Player \".concat(playerNumber, \". Do you want to try again? (Attempt \").concat(attempt, \"/\").concat(maxAttempts, \")\"));\n                        if (!shouldRetry) {\n                            throw new Error(\"Escrow locking cancelled - correct wallet for Player \".concat(playerNumber, \" was not connected.\"));\n                        }\n                    } else {\n                        throw new Error(\"Failed to connect the correct wallet for Player \".concat(playerNumber, \" after \").concat(maxAttempts, \" attempts.\"));\n                    }\n                }\n                if (!isWalletConnected) {\n                    throw new Error(\"Could not verify Player \".concat(playerNumber, \"'s wallet. Please make sure the correct wallet is connected.\"));\n                }\n                // Direct transfer to escrow address - using minimumBet instead of player's full bet\n                const transferSuccess = await transferToEscrow(playerNumber, minimumBet, escrowAddress);\n                if (!transferSuccess) {\n                    throw new Error(\"Failed to transfer funds to escrow for Player \".concat(playerNumber));\n                }\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                    // Refresh balance\n                    if (player1Wallet) {\n                        const newBalance = await getAccountBalance(player1Wallet.address);\n                    }\n                } else {\n                    setPlayer2EscrowLocked(true);\n                    // Refresh balance\n                    if (player2Wallet) {\n                        const newBalance = await getAccountBalance(player2Wallet.address);\n                    }\n                }\n                console.log(\"Escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance - in real mode, we'd query the contract\n                if (escrowAddress) {\n                    const escrowBalanceResult = await getAccountBalance(escrowAddress);\n                    setEscrowBalance(escrowBalanceResult);\n                }\n            }\n            // Check if both players have locked their escrow after this player's lock\n            const bothPlayersLocked = playerNumber === 1 ?  true && player2EscrowLocked // Player 1 just locked + check if Player 2 was already locked\n             : player1EscrowLocked && true; // Check if Player 1 was already locked + Player 2 just locked\n            if (bothPlayersLocked) {\n                console.log(\"Both players have deposited funds to escrow. Ready to start game...\");\n                // Final pool amount is minimum bet Ã— 2\n                const finalPoolAmount = minimumBet * 2;\n                console.log(\"Setting final bet amount to \".concat(finalPoolAmount, \" APT (\").concat(minimumBet, \" \\xd7 2)\"));\n                setEscrowLocked(true);\n            } else {\n                console.log(\"Waiting for the other player to lock their escrow\");\n            }\n            return {\n                wasLocked: true,\n                playerNumber,\n                minimumBet\n            };\n        } catch (error) {\n            console.error(\"Error locking escrow for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to lock escrow for Player \".concat(playerNumber));\n            return {\n                wasLocked: false,\n                error: error.message || \"Failed to lock escrow for Player \".concat(playerNumber)\n            };\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAddress,\n        player1EscrowLocked,\n        player2EscrowLocked,\n        escrowAdapter\n    ]);\n    // Pay winner from escrow\n    const payWinner = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (winner, player1Wallet, player2Wallet, player1Bet, player2Bet, finalBetAmount, getAccountBalance)=>{\n        try {\n            if (!winner) return;\n            console.log(\"Paying winner: \".concat(winner));\n            // Only proceed if not in simulation mode and escrow is locked\n            if (!useSimulationMode && escrowLocked && escrowAddress) {\n                // Verify escrow wallet - with retry mechanism\n                let maxAttempts = 3;\n                let escrowWalletConnected = null;\n                let isCorrectWallet = false;\n                for(let attempt = 1; attempt <= maxAttempts; attempt++){\n                    // Show clear instructions about which wallet to connect\n                    window.alert(\"Please select the ESCROW wallet (\".concat(escrowAddress.substring(0, 6), \"...\").concat(escrowAddress.substring(escrowAddress.length - 4), \") in your Petra extension to transfer funds.\\n          \\nIMPORTANT: Only the escrow wallet can be used for this operation.\"));\n                    try {\n                        escrowWalletConnected = await window.aptos.connect();\n                        if (escrowWalletConnected && escrowWalletConnected.address === escrowAddress) {\n                            isCorrectWallet = true;\n                            console.log(\"Successfully connected to escrow wallet:\", escrowWalletConnected.address);\n                            break;\n                        } else {\n                            // Wrong wallet connected\n                            window.alert(\"Error: Wrong wallet connected. \\n              \\nExpected the escrow wallet (\".concat(escrowAddress.substring(0, 6), \"...\").concat(escrowAddress.substring(escrowAddress.length - 4), \") \\n\\nbut got a different wallet (\").concat(escrowWalletConnected === null || escrowWalletConnected === void 0 ? void 0 : escrowWalletConnected.address.substring(0, 6), \"...\").concat(escrowWalletConnected === null || escrowWalletConnected === void 0 ? void 0 : escrowWalletConnected.address.substring(escrowWalletConnected.address.length - 4), \").\"));\n                            if (attempt < maxAttempts) {\n                                const shouldRetry = window.confirm(\"Failed to connect the correct escrow wallet. Do you want to try again? (Attempt \".concat(attempt, \"/\").concat(maxAttempts, \")\"));\n                                if (!shouldRetry) {\n                                    throw new Error(\"Operation cancelled - escrow wallet was not connected.\");\n                                }\n                            }\n                        }\n                    } catch (error) {\n                        console.error(\"Error connecting to wallet:\", error);\n                        if (attempt < maxAttempts) {\n                            const shouldRetry = window.confirm(\"Error connecting to wallet. Do you want to try again? (Attempt \".concat(attempt, \"/\").concat(maxAttempts, \")\"));\n                            if (!shouldRetry) {\n                                throw new Error(\"Operation cancelled due to wallet connection error.\");\n                            }\n                        } else {\n                            throw new Error(\"Failed to connect wallet after \".concat(maxAttempts, \" attempts.\"));\n                        }\n                    }\n                }\n                if (!isCorrectWallet) {\n                    throw new Error(\"Failed to connect to the correct escrow wallet. Please ensure the correct wallet is selected.\");\n                }\n                // Handle draw case\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - returning funds to both players\");\n                    // For a draw, return original bet amounts to each player\n                    // Return funds to Player 1\n                    if (player1Wallet) {\n                        console.log(\"Returning \".concat(player1Bet, \" APT to Player 1 from escrow\"));\n                        const payload1 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player1Wallet.address,\n                                Math.floor(player1Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse1 = await window.aptos.signAndSubmitTransaction(payload1);\n                        console.log(\"Player 1 refund transaction:\", txResponse1);\n                    }\n                    // Return funds to Player 2\n                    if (player2Wallet) {\n                        console.log(\"Returning \".concat(player2Bet, \" APT to Player 2 from escrow\"));\n                        const payload2 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player2Wallet.address,\n                                Math.floor(player2Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse2 = await window.aptos.signAndSubmitTransaction(payload2);\n                        console.log(\"Player 2 refund transaction:\", txResponse2);\n                    }\n                } else {\n                    const winnerWallet = winner === \"player1\" ? player1Wallet : player2Wallet;\n                    if (!winnerWallet) {\n                        throw new Error(\"Winner wallet not found\");\n                    }\n                    console.log(\"Transferring \".concat(finalBetAmount, \" APT to winner (\").concat(winnerWallet.address, \")\"));\n                    // Transfer all funds from escrow to winner\n                    const payload = {\n                        type: \"entry_function_payload\",\n                        function: \"0x1::coin::transfer\",\n                        type_arguments: [\n                            \"0x1::aptos_coin::AptosCoin\"\n                        ],\n                        arguments: [\n                            winnerWallet.address,\n                            Math.floor(finalBetAmount * 100000000).toString()\n                        ]\n                    };\n                    const txResponse = await window.aptos.signAndSubmitTransaction(payload);\n                    console.log(\"Winner payment transaction:\", txResponse);\n                }\n                // Update player balances after transfers\n                if (player1Wallet) {\n                    await getAccountBalance(player1Wallet.address);\n                }\n                if (player2Wallet) {\n                    await getAccountBalance(player2Wallet.address);\n                }\n            } else if (useSimulationMode) {\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - both players receive their bets back (simulation)\");\n                } else {\n                    console.log(\"Updating Player \".concat(winner === \"player1\" ? \"1\" : \"2\", \" wallet balance: +\").concat(finalBetAmount, \" APT (simulation)\"));\n                }\n            }\n            console.log(\"Winner payment completed successfully\");\n        } catch (error) {\n            console.error(\"Error paying winner:\", error);\n            setError(error.message || \"Failed to pay winner\");\n        }\n    }, [\n        useSimulationMode,\n        escrowLocked,\n        escrowAddress\n    ]);\n    // Reset escrow state\n    const resetEscrowState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setPlayer1EscrowLocked(false);\n        setPlayer2EscrowLocked(false);\n        setEscrowLocked(false);\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n        setEscrowBalance(0);\n    }, []);\n    return {\n        useSimulationMode,\n        setUseSimulationMode,\n        escrowLocked,\n        setEscrowLocked,\n        player1EscrowLocked,\n        setPlayer1EscrowLocked,\n        player2EscrowLocked,\n        setPlayer2EscrowLocked,\n        escrowAddress,\n        setEscrowAddress,\n        escrowStatus,\n        setEscrowStatus,\n        escrowBalance,\n        setEscrowBalance,\n        isLoading,\n        error,\n        setError,\n        initializeEscrow,\n        createSimulatedEscrow,\n        connectEscrowWallet,\n        lockEscrow,\n        payWinner,\n        resetEscrowState,\n        escrowAdapter\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0IzQixjQUFjZSxPQUFPO2dCQUMvQztZQUNGLE9BRUssSUFBSXBDLG1CQUFtQjtnQkFDMUIsSUFBSW1FLFdBQVcsUUFBUTtvQkFDckI3QyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2QsT0FBTztvQkFDTEQsUUFBUUMsR0FBRyxDQUFDLG1CQUF3RTZDLE9BQXJERCxXQUFXLFlBQVksTUFBTSxLQUFJLHNCQUFtQyxPQUFmQyxnQkFBZTtnQkFDckc7WUFDRjtZQUVBOUMsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPTixPQUFZO1lBQ25CSyxRQUFRTCxLQUFLLENBQUMsd0JBQXdCQTtZQUN0Q0MsU0FBU0QsTUFBTXVCLE9BQU8sSUFBSTtRQUM1QjtJQUNGLEdBQUc7UUFBQ3hDO1FBQW1CRTtRQUFjTTtLQUFjO0lBRW5ELHFCQUFxQjtJQUNyQixNQUFNK0UsbUJBQW1CN0Ysa0RBQVdBLENBQUM7UUFDbkNXLHVCQUF1QjtRQUN2QkUsdUJBQXVCO1FBQ3ZCSixnQkFBZ0I7UUFDaEJRLGdCQUFnQmQsMEVBQVlBLENBQUNlLE9BQU87UUFDcENFLGlCQUFpQjtJQUNuQixHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0xkO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FFO1FBQ0FDO1FBQ0FDO1FBQ0FzQjtRQUNBQztRQUNBQztRQUNBdUI7UUFDQXFCO1FBQ0F4RjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUVzY3Jvdy50cz9kMjhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVzY3Jvd0NvbnRyYWN0QWRhcHRlciwgRXNjcm93U3RhdHVzIH0gZnJvbSAnLi4vY29udHJhY3RzL0VzY3Jvd0NvbnRyYWN0QWRhcHRlcic7XG5pbXBvcnQgeyBQbGF5ZXJXYWxsZXRJbmZvIH0gZnJvbSAnLi4vdHlwZXMvZ2FtZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFc2Nyb3coKSB7XG4gIC8vIEVzY3JvdyBhZGFwdGVyIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9uc1xuICBjb25zdCBlc2Nyb3dBZGFwdGVyID0gdXNlTWVtbygoKSA9PiBuZXcgRXNjcm93Q29udHJhY3RBZGFwdGVyKFxuICAgICdodHRwczovL2Z1bGxub2RlLnRlc3RuZXQuYXB0b3NsYWJzLmNvbS92MScsXG4gICAgJzB4MScgLy8gRGVmYXVsdCBtb2R1bGUgYWRkcmVzcywgd291bGQgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgZGVwbG95ZWQgYWRkcmVzc1xuICApLCBbXSk7XG5cbiAgLy8gRXNjcm93IHN0YXRlXG4gIGNvbnN0IFt1c2VTaW11bGF0aW9uTW9kZSwgc2V0VXNlU2ltdWxhdGlvbk1vZGVdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpOyAvLyBEZWZhdWx0IHRvIGZhbHNlIGZvciBwcm9kdWN0aW9uIHVzZVxuICBjb25zdCBbZXNjcm93TG9ja2VkLCBzZXRFc2Nyb3dMb2NrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbcGxheWVyMUVzY3Jvd0xvY2tlZCwgc2V0UGxheWVyMUVzY3Jvd0xvY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtwbGF5ZXIyRXNjcm93TG9ja2VkLCBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2VzY3Jvd0FkZHJlc3MsIHNldEVzY3Jvd0FkZHJlc3NdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlc2Nyb3dTdGF0dXMsIHNldEVzY3Jvd1N0YXR1c10gPSB1c2VTdGF0ZTxFc2Nyb3dTdGF0dXM+KEVzY3Jvd1N0YXR1cy5QRU5ESU5HKTtcbiAgY29uc3QgW2VzY3Jvd0JhbGFuY2UsIHNldEVzY3Jvd0JhbGFuY2VdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBJbml0aWFsaXplIGVzY3Jvd1xuICBjb25zdCBpbml0aWFsaXplRXNjcm93ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHBsYXllcjFXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLCBcbiAgICBwbGF5ZXIyV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbFxuICApID0+IHtcbiAgICBpZiAoIXBsYXllcjFXYWxsZXQgfHwgIXBsYXllcjJXYWxsZXQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSBlc2Nyb3c6IGJvdGggcGxheWVycyBtdXN0IGJlIGNvbm5lY3RlZFwiKTtcbiAgICAgIHNldEVycm9yKFwiQm90aCBwbGF5ZXJzIG11c3QgYmUgY29ubmVjdGVkIHRvIGluaXRpYWxpemUgdGhlIGVzY3Jvd1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc29sZS5sb2coXCJJbml0aWFsaXppbmcgZXNjcm93IGNvbnRyYWN0XCIpO1xuXG4gICAgICAvLyBJbiBzaW11bGF0aW9uIG1vZGUsIGp1c3Qgc2V0IGEgZmFrZSBhZGRyZXNzXG4gICAgICBpZiAodXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzaW11bGF0ZWRBZGRyZXNzID0gJ3NpbXVsYXRlZF9lc2Nyb3dfJyArIERhdGUubm93KCk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBzaW11bGF0ZWQgZXNjcm93IHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IHRoZSBhZGRyZXNzIGluIHRoZSBhZGFwdGVyXG4gICAgICAgICAgZXNjcm93QWRhcHRlci5zZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0aGUgYWRkcmVzcyBpbiBvdXIgY29tcG9uZW50IHN0YXRlXG4gICAgICAgICAgc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNpbXVsYXRlZCBlc2Nyb3cgaW5pdGlhbGl6ZWQgd2l0aCBhZGRyZXNzOlwiLCBzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgc3RhdGUgdXBkYXRlc1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoc2ltRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc2ltdWxhdGlvbiBtb2RlOlwiLCBzaW1FcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgdG8gdHJ5IHJlYWwgbW9kZSwgYnV0IGxvZyB0aGUgZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUcnkgY29ubmVjdGluZyB0byBQbGF5ZXIgMSdzIHdhbGxldFxuICAgICAgY29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gUGxheWVyIDEncyB3YWxsZXQgZm9yIGVzY3JvdyBpbml0aWFsaXphdGlvblwiKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBwcm9tcHQgZm9yIHdhbGxldCBjb25uZWN0aW9uXG4gICAgICB3aW5kb3cuYWxlcnQoXCJQbGVhc2UgbWFrZSBzdXJlIGEgU0VQQVJBVEUgRVNDUk9XIHdhbGxldCBpcyBzZWxlY3RlZCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byBpbml0aWFsaXplIHRoZSBlc2Nyb3cuIFRoaXMgc2hvdWxkIE5PVCBiZSB0aGUgc2FtZSBhcyBQbGF5ZXIgMSBvciBQbGF5ZXIgMidzIHdhbGxldC5cIik7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgd2FsbGV0IGlzIHRoZSBzYW1lIGFzIHBsYXllciAxIG9yIHBsYXllciAyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5hZGRyZXNzID09PSBwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpIHtcbiAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJFcnJvcjogVGhpcyB3YWxsZXQgaXMgdGhlIHNhbWUgYXMgUGxheWVyIDEncyB3YWxsZXQuIFBsZWFzZSBzZWxlY3QgYSBkaWZmZXJlbnQgd2FsbGV0IGZvciBlc2Nyb3cuXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyB3YWxsZXQgY2Fubm90IGJlIHRoZSBzYW1lIGFzIFBsYXllciAxJ3Mgd2FsbGV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MgPT09IHBsYXllcjJXYWxsZXQuYWRkcmVzcykge1xuICAgICAgICAgIHdpbmRvdy5hbGVydChcIkVycm9yOiBUaGlzIHdhbGxldCBpcyB0aGUgc2FtZSBhcyBQbGF5ZXIgMidzIHdhbGxldC4gUGxlYXNlIHNlbGVjdCBhIGRpZmZlcmVudCB3YWxsZXQgZm9yIGVzY3Jvdy5cIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IHdhbGxldCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgUGxheWVyIDIncyB3YWxsZXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZWVkIHdpdGggZXNjcm93IGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5hZGRyZXNzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gd2FsbGV0LCBjcmVhdGluZyBlc2Nyb3dcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaW5pdGlhbGl6ZUVzY3Jvd1Jlc3VsdCA9IGF3YWl0IGVzY3Jvd0FkYXB0ZXIuaW5pdGlhbGl6ZUVzY3JvdyhcbiAgICAgICAgICAgIHdpbmRvdy5hcHRvcyxcbiAgICAgICAgICAgIHBsYXllcjFXYWxsZXQuYWRkcmVzcyxcbiAgICAgICAgICAgIHBsYXllcjJXYWxsZXQuYWRkcmVzcyxcbiAgICAgICAgICAgIDAuMSwgLy8gTWluaW11bSBiZXQgb2YgMC4xIEFQVFxuICAgICAgICAgICAgMjQgKiA2MCAqIDYwIC8vIDI0IGhvdXIgdGltZW91dFxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGluaXRpYWxpemVFc2Nyb3dSZXN1bHQpIHtcbiAgICAgICAgICAgIHNldEVzY3Jvd0FkZHJlc3MoaW5pdGlhbGl6ZUVzY3Jvd1Jlc3VsdCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVzY3JvdyBjb250cmFjdCBjcmVhdGVkIHdpdGggYWRkcmVzczpcIiwgaW5pdGlhbGl6ZUVzY3Jvd1Jlc3VsdCk7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb25uZWN0ZWQgdG8gd3Jvbmcgd2FsbGV0IGFkZHJlc3M6XCIsIHJlc3BvbnNlPy5hZGRyZXNzKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb25uZWN0IHdhbGxldC4gUGxlYXNlIG1ha2Ugc3VyZSBhIHZhbGlkIHdhbGxldCBpcyBzZWxlY3RlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2l0aCBkaXJlY3QgUGV0cmEgY29ubmVjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBpbml0aWFsaXplIGVzY3Jvd1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFt1c2VTaW11bGF0aW9uTW9kZSwgZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIENyZWF0ZSBhIHNpbXVsYXRlZCBlc2Nyb3cgKGZvciB0ZXN0aW5nKVxuICBjb25zdCBjcmVhdGVTaW11bGF0ZWRFc2Nyb3cgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCF1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgc2V0RXJyb3IoXCJQbGVhc2UgZW5hYmxlIHNpbXVsYXRpb24gbW9kZSBmaXJzdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBhIHNpbXVsYXRlZCBlc2Nyb3cgZm9yIHRlc3RpbmdcIik7XG4gICAgY29uc3Qgc2ltdWxhdGVkQWRkcmVzcyA9ICdzaW11bGF0ZWRfZXNjcm93XycgKyBEYXRlLm5vdygpO1xuICAgIGVzY3Jvd0FkYXB0ZXIuc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlZCBzaW11bGF0ZWQgZXNjcm93IHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgXG4gICAgLy8gQWxzbyBzZXQgZXNjcm93IHN0YXR1cyB0byBQRU5ESU5HXG4gICAgc2V0RXNjcm93U3RhdHVzKEVzY3Jvd1N0YXR1cy5QRU5ESU5HKTtcbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dBZGFwdGVyXSk7XG5cbiAgLy8gQ29ubmVjdCBlc2Nyb3cgd2FsbGV0XG4gIGNvbnN0IGNvbm5lY3RFc2Nyb3dXYWxsZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgcGxheWVyMVdhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsXG4gICAgcGxheWVyMldhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGxcbiAgKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RpbmcgZXNjcm93IHdhbGxldC4uLlwiKTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuYXB0b3MpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJQZXRyYSB3YWxsZXQgaXMgbm90IGluc3RhbGxlZC4gUGxlYXNlIGluc3RhbGwgdGhlIFBldHJhIHdhbGxldCBleHRlbnNpb24uXCIpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb21wdCB0byBzZWxlY3QgdGhlIGVzY3JvdyB3YWxsZXRcbiAgICAgIHdpbmRvdy5hbGVydChcIlBsZWFzZSBtYWtlIHN1cmUgeW91ciBFU0NST1cgd2FsbGV0IGlzIHNlbGVjdGVkIGluIHlvdXIgUGV0cmEgZXh0ZW5zaW9uLlxcbklNUE9SVEFOVDogVGhpcyBzaG91bGQgYmUgRElGRkVSRU5UIGZyb20gUGxheWVyIDEgYW5kIFBsYXllciAyIHdhbGxldHMuXCIpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZyhcIkVzY3JvdyB3YWxsZXQgY29ubmVjdGlvbiByZXNwb25zZTpcIiwgcmVzcG9uc2UpO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RlZCB0byBlc2Nyb3cgd2FsbGV0OlwiLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB3YWxsZXQgaXMgdGhlIHNhbWUgYXMgcGxheWVyIDEgb3IgcGxheWVyIDJcbiAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQgJiYgcGxheWVyMVdhbGxldC5hZGRyZXNzID09PSByZXNwb25zZS5hZGRyZXNzKSB7XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiRXJyb3I6IFRoaXMgd2FsbGV0IGlzIGFscmVhZHkgYmVpbmcgdXNlZCBieSBQbGF5ZXIgMS4gUGxlYXNlIHNlbGVjdCBhIGRpZmZlcmVudCB3YWxsZXQgZm9yIGVzY3Jvdy5cIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IHdhbGxldCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgUGxheWVyIDEncyB3YWxsZXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocGxheWVyMldhbGxldCAmJiBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MgPT09IHJlc3BvbnNlLmFkZHJlc3MpIHtcbiAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJFcnJvcjogVGhpcyB3YWxsZXQgaXMgYWxyZWFkeSBiZWluZyB1c2VkIGJ5IFBsYXllciAyLiBQbGVhc2Ugc2VsZWN0IGEgZGlmZmVyZW50IHdhbGxldCBmb3IgZXNjcm93LlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgd2FsbGV0IGNhbm5vdCBiZSB0aGUgc2FtZSBhcyBQbGF5ZXIgMidzIHdhbGxldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgZXNjcm93IGFkZHJlc3MgaW4gdGhlIGFkYXB0ZXJcbiAgICAgICAgZXNjcm93QWRhcHRlci5zZXRFc2Nyb3dBZGRyZXNzKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBhZGRyZXNzIGluIGNvbXBvbmVudCBzdGF0ZVxuICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coXCJFc2Nyb3cgd2FsbGV0IHNldCBzdWNjZXNzZnVsbHk6XCIsIHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBlc2Nyb3cgd2FsbGV0IGFkZHJlc3NcIik7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyBlc2Nyb3cgd2FsbGV0OlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGNvbm5lY3QgZXNjcm93IHdhbGxldFwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtlc2Nyb3dBZGFwdGVyXSk7XG5cbiAgLy8gTG9jayB0aGUgZXNjcm93IGJ5IHRyYW5zZmVycmluZyB0aGUgbWluaW11bSBiZXQgYW1vdW50IGZyb20gYSBzcGVjaWZpYyBwbGF5ZXJcbiAgY29uc3QgbG9ja0VzY3JvdyA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBwbGF5ZXJOdW1iZXI6IDEgfCAyLCBcbiAgICBwbGF5ZXIxV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIyV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIxQmV0OiBudW1iZXIsXG4gICAgcGxheWVyMkJldDogbnVtYmVyLFxuICAgIGVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQ6IChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiBQcm9taXNlPGJvb2xlYW4+LFxuICAgIGdldEFjY291bnRCYWxhbmNlOiAoYWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPG51bWJlcj4sXG4gICAgdHJhbnNmZXJUb0VzY3JvdzogKHBsYXllck51bWJlcjogMSB8IDIsIGFtb3VudDogbnVtYmVyLCB0YXJnZXRBZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj5cbiAgKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgZXNjcm93IGxvY2tpbmcgcHJvY2VzcyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgZXNjcm93IGxvY2sgc3RhdHVzOiBQbGF5ZXIgMTogJHtwbGF5ZXIxRXNjcm93TG9ja2VkfSwgUGxheWVyIDI6ICR7cGxheWVyMkVzY3Jvd0xvY2tlZH1gKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGJvdGggcGxheWVycyBoYXZlIHBsYWNlZCBiZXRzXG4gICAgICBpZiAocGxheWVyMUJldCA8PSAwIHx8IHBsYXllcjJCZXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIHBsYXllcnMgbXVzdCBhbm5vdW5jZSBiZXRzIGJlZm9yZSBsb2NraW5nIGVzY3Jvd1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGJldCBhbW91bnQgKHRoaXMgaXMgd2hhdCB3aWxsIGJlIGRlZHVjdGVkKVxuICAgICAgY29uc3QgbWluaW11bUJldCA9IE1hdGgubWluKHBsYXllcjFCZXQsIHBsYXllcjJCZXQpO1xuICAgICAgY29uc29sZS5sb2coYE1pbmltdW0gYmV0IGFtb3VudCBiZXR3ZWVuIHBsYXllcnM6ICR7bWluaW11bUJldH0gQVBUYCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwbGF5ZXIgd2FsbGV0XG4gICAgICBjb25zdCBwbGF5ZXJXYWxsZXQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIxV2FsbGV0IDogcGxheWVyMldhbGxldDtcbiAgICAgIGlmICghcGxheWVyV2FsbGV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxheWVyICR7cGxheWVyTnVtYmVyfSB3YWxsZXQgbm90IGNvbm5lY3RlZGApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbiBzaW11bGF0aW9uIG1vZGUsIGNyZWF0ZSBhbiBlc2Nyb3cgaWYgbm90IHlldCBpbml0aWFsaXplZFxuICAgICAgaWYgKHVzZVNpbXVsYXRpb25Nb2RlICYmICFlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZXNjcm93IGluaXRpYWxpemVkIHlldCwgYnV0IGluIHNpbXVsYXRpb24gbW9kZS4gQ3JlYXRpbmcgZXNjcm93IG5vdy4uLlwiKTtcbiAgICAgICAgY29uc3Qgc2ltdWxhdGVkQWRkcmVzcyA9ICdzaW11bGF0ZWRfZXNjcm93XycgKyBEYXRlLm5vdygpO1xuICAgICAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIHNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXV0by1jcmVhdGVkIHNpbXVsYXRlZCBlc2Nyb3cgd2l0aCBhZGRyZXNzOlwiLCBzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJyaWVmIHBhdXNlIHRvIGxldCBzdGF0ZSB1cGRhdGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgYW4gZXNjcm93IGFkZHJlc3MgaXMgc2V0XG4gICAgICBpZiAoIWVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXNjcm93IHdhbGxldCBjb25uZWN0ZWQuIFBsZWFzZSBjb25uZWN0IHRoZSBlc2Nyb3cgd2FsbGV0IGZpcnN0LlwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYERlcG9zaXRpbmcgJHttaW5pbXVtQmV0fSBBUFQgdG8gZXNjcm93IGNvbnRyYWN0IGZyb20gUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgXG4gICAgICAvLyBVc2Ugc2ltdWxhdGlvbiBtb2RlIGlmIGVuYWJsZWRcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHNpbXVsYXRpb24gbW9kZSAtIG5vIGFjdHVhbCB0cmFuc2ZlciB3aWxsIG9jY3VyXCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltdWxhdGUgZGVwb3NpdFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIFVJIHN0YXRlXG4gICAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFBsYXllcjJFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTaW11bGF0ZWQgZXNjcm93IGxvY2sgc3VjY2Vzc2Z1bCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGVzY3JvdyBiYWxhbmNlIGluIHNpbXVsYXRpb24gbW9kZVxuICAgICAgICBzZXRFc2Nyb3dCYWxhbmNlKHByZXZCYWxhbmNlID0+IHByZXZCYWxhbmNlICsgbWluaW11bUJldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWFsIGRlcG9zaXQgYnkgdHJhbnNmZXJyaW5nIGZ1bmRzIHRvIHRoZSBlc2Nyb3cgYWRkcmVzc1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBsYXllcidzIHdhbGxldCBpcyBjb25uZWN0ZWQgLSBzdHJpY3QgdmVyaWZpY2F0aW9uXG4gICAgICAgIGxldCBtYXhBdHRlbXB0cyA9IDM7XG4gICAgICAgIGxldCBpc1dhbGxldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgIGlzV2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZChwbGF5ZXJOdW1iZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpc1dhbGxldENvbm5lY3RlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChhdHRlbXB0IDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIC8vIEFzayBpZiB0aGV5IHdhbnQgdG8gdHJ5IGFnYWluXG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXRyeSA9IHdpbmRvdy5jb25maXJtKGBGYWlsZWQgdG8gY29ubmVjdCB0aGUgY29ycmVjdCB3YWxsZXQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn0uIERvIHlvdSB3YW50IHRvIHRyeSBhZ2Fpbj8gKEF0dGVtcHQgJHthdHRlbXB0fS8ke21heEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFc2Nyb3cgbG9ja2luZyBjYW5jZWxsZWQgLSBjb3JyZWN0IHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfSB3YXMgbm90IGNvbm5lY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCB0aGUgY29ycmVjdCB3YWxsZXQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn0gYWZ0ZXIgJHttYXhBdHRlbXB0c30gYXR0ZW1wdHMuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWlzV2FsbGV0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdmVyaWZ5IFBsYXllciAke3BsYXllck51bWJlcn0ncyB3YWxsZXQuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGNvcnJlY3Qgd2FsbGV0IGlzIGNvbm5lY3RlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRGlyZWN0IHRyYW5zZmVyIHRvIGVzY3JvdyBhZGRyZXNzIC0gdXNpbmcgbWluaW11bUJldCBpbnN0ZWFkIG9mIHBsYXllcidzIGZ1bGwgYmV0XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyU3VjY2VzcyA9IGF3YWl0IHRyYW5zZmVyVG9Fc2Nyb3cocGxheWVyTnVtYmVyLCBtaW5pbXVtQmV0LCBlc2Nyb3dBZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdHJhbnNmZXJTdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdHJhbnNmZXIgZnVuZHMgdG8gZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBVSSBzdGF0ZVxuICAgICAgICBpZiAocGxheWVyTnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgc2V0UGxheWVyMUVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWZyZXNoIGJhbGFuY2VcbiAgICAgICAgICBpZiAocGxheWVyMVdhbGxldCkge1xuICAgICAgICAgICAgY29uc3QgbmV3QmFsYW5jZSA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHBsYXllcjFXYWxsZXQuYWRkcmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFBsYXllcjJFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVmcmVzaCBiYWxhbmNlXG4gICAgICAgICAgaWYgKHBsYXllcjJXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIyV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEVzY3JvdyBsb2NrIHN1Y2Nlc3NmdWwgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBlc2Nyb3cgYmFsYW5jZSAtIGluIHJlYWwgbW9kZSwgd2UnZCBxdWVyeSB0aGUgY29udHJhY3RcbiAgICAgICAgaWYgKGVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgICBjb25zdCBlc2Nyb3dCYWxhbmNlUmVzdWx0ID0gYXdhaXQgZ2V0QWNjb3VudEJhbGFuY2UoZXNjcm93QWRkcmVzcyk7XG4gICAgICAgICAgc2V0RXNjcm93QmFsYW5jZShlc2Nyb3dCYWxhbmNlUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBib3RoIHBsYXllcnMgaGF2ZSBsb2NrZWQgdGhlaXIgZXNjcm93IGFmdGVyIHRoaXMgcGxheWVyJ3MgbG9ja1xuICAgICAgY29uc3QgYm90aFBsYXllcnNMb2NrZWQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgXG4gICAgICAgID8gdHJ1ZSAmJiBwbGF5ZXIyRXNjcm93TG9ja2VkICAvLyBQbGF5ZXIgMSBqdXN0IGxvY2tlZCArIGNoZWNrIGlmIFBsYXllciAyIHdhcyBhbHJlYWR5IGxvY2tlZFxuICAgICAgICA6IHBsYXllcjFFc2Nyb3dMb2NrZWQgJiYgdHJ1ZTsgLy8gQ2hlY2sgaWYgUGxheWVyIDEgd2FzIGFscmVhZHkgbG9ja2VkICsgUGxheWVyIDIganVzdCBsb2NrZWRcbiAgICAgICAgXG4gICAgICBpZiAoYm90aFBsYXllcnNMb2NrZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJCb3RoIHBsYXllcnMgaGF2ZSBkZXBvc2l0ZWQgZnVuZHMgdG8gZXNjcm93LiBSZWFkeSB0byBzdGFydCBnYW1lLi4uXCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmluYWwgcG9vbCBhbW91bnQgaXMgbWluaW11bSBiZXQgw5cgMlxuICAgICAgICBjb25zdCBmaW5hbFBvb2xBbW91bnQgPSBtaW5pbXVtQmV0ICogMjtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGZpbmFsIGJldCBhbW91bnQgdG8gJHtmaW5hbFBvb2xBbW91bnR9IEFQVCAoJHttaW5pbXVtQmV0fSDDlyAyKWApO1xuICAgICAgICBzZXRFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyBmb3IgdGhlIG90aGVyIHBsYXllciB0byBsb2NrIHRoZWlyIGVzY3Jvd2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YXNMb2NrZWQ6IHRydWUsXG4gICAgICAgIHBsYXllck51bWJlcixcbiAgICAgICAgbWluaW11bUJldFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2NraW5nIGVzY3JvdyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfTpgLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gbG9jayBlc2Nyb3cgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdhc0xvY2tlZDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gbG9jayBlc2Nyb3cgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dBZGRyZXNzLCBwbGF5ZXIxRXNjcm93TG9ja2VkLCBwbGF5ZXIyRXNjcm93TG9ja2VkLCBlc2Nyb3dBZGFwdGVyXSk7XG5cbiAgLy8gUGF5IHdpbm5lciBmcm9tIGVzY3Jvd1xuICBjb25zdCBwYXlXaW5uZXIgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgd2lubmVyOiAncGxheWVyMScgfCAncGxheWVyMicgfCAnZHJhdycgfCBudWxsLFxuICAgIHBsYXllcjFXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLFxuICAgIHBsYXllcjJXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLFxuICAgIHBsYXllcjFCZXQ6IG51bWJlcixcbiAgICBwbGF5ZXIyQmV0OiBudW1iZXIsXG4gICAgZmluYWxCZXRBbW91bnQ6IG51bWJlcixcbiAgICBnZXRBY2NvdW50QmFsYW5jZTogKGFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTxudW1iZXI+XG4gICkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXdpbm5lcikgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgUGF5aW5nIHdpbm5lcjogJHt3aW5uZXJ9YCk7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiBub3QgaW4gc2ltdWxhdGlvbiBtb2RlIGFuZCBlc2Nyb3cgaXMgbG9ja2VkXG4gICAgICBpZiAoIXVzZVNpbXVsYXRpb25Nb2RlICYmIGVzY3Jvd0xvY2tlZCAmJiBlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgIC8vIFZlcmlmeSBlc2Nyb3cgd2FsbGV0IC0gd2l0aCByZXRyeSBtZWNoYW5pc21cbiAgICAgICAgbGV0IG1heEF0dGVtcHRzID0gMztcbiAgICAgICAgbGV0IGVzY3Jvd1dhbGxldENvbm5lY3RlZCA9IG51bGw7XG4gICAgICAgIGxldCBpc0NvcnJlY3RXYWxsZXQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAvLyBTaG93IGNsZWFyIGluc3RydWN0aW9ucyBhYm91dCB3aGljaCB3YWxsZXQgdG8gY29ubmVjdFxuICAgICAgICAgIHdpbmRvdy5hbGVydChgUGxlYXNlIHNlbGVjdCB0aGUgRVNDUk9XIHdhbGxldCAoJHtlc2Nyb3dBZGRyZXNzLnN1YnN0cmluZygwLCA2KX0uLi4ke2VzY3Jvd0FkZHJlc3Muc3Vic3RyaW5nKGVzY3Jvd0FkZHJlc3MubGVuZ3RoIC0gNCl9KSBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byB0cmFuc2ZlciBmdW5kcy5cbiAgICAgICAgICBcbklNUE9SVEFOVDogT25seSB0aGUgZXNjcm93IHdhbGxldCBjYW4gYmUgdXNlZCBmb3IgdGhpcyBvcGVyYXRpb24uYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVzY3Jvd1dhbGxldENvbm5lY3RlZCA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlc2Nyb3dXYWxsZXRDb25uZWN0ZWQgJiYgZXNjcm93V2FsbGV0Q29ubmVjdGVkLmFkZHJlc3MgPT09IGVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgaXNDb3JyZWN0V2FsbGV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvIGVzY3JvdyB3YWxsZXQ6XCIsIGVzY3Jvd1dhbGxldENvbm5lY3RlZC5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXcm9uZyB3YWxsZXQgY29ubmVjdGVkXG4gICAgICAgICAgICAgIHdpbmRvdy5hbGVydChgRXJyb3I6IFdyb25nIHdhbGxldCBjb25uZWN0ZWQuIFxuICAgICAgICAgICAgICBcbkV4cGVjdGVkIHRoZSBlc2Nyb3cgd2FsbGV0ICgke2VzY3Jvd0FkZHJlc3Muc3Vic3RyaW5nKDAsIDYpfS4uLiR7ZXNjcm93QWRkcmVzcy5zdWJzdHJpbmcoZXNjcm93QWRkcmVzcy5sZW5ndGggLSA0KX0pIFxuXG5idXQgZ290IGEgZGlmZmVyZW50IHdhbGxldCAoJHtlc2Nyb3dXYWxsZXRDb25uZWN0ZWQ/LmFkZHJlc3Muc3Vic3RyaW5nKDAsIDYpfS4uLiR7ZXNjcm93V2FsbGV0Q29ubmVjdGVkPy5hZGRyZXNzLnN1YnN0cmluZyhlc2Nyb3dXYWxsZXRDb25uZWN0ZWQuYWRkcmVzcy5sZW5ndGggLSA0KX0pLmApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCBtYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gd2luZG93LmNvbmZpcm0oYEZhaWxlZCB0byBjb25uZWN0IHRoZSBjb3JyZWN0IGVzY3JvdyB3YWxsZXQuIERvIHlvdSB3YW50IHRvIHRyeSBhZ2Fpbj8gKEF0dGVtcHQgJHthdHRlbXB0fS8ke21heEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZXJhdGlvbiBjYW5jZWxsZWQgLSBlc2Nyb3cgd2FsbGV0IHdhcyBub3QgY29ubmVjdGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyB0byB3YWxsZXQ6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSB3aW5kb3cuY29uZmlybShgRXJyb3IgY29ubmVjdGluZyB0byB3YWxsZXQuIERvIHlvdSB3YW50IHRvIHRyeSBhZ2Fpbj8gKEF0dGVtcHQgJHthdHRlbXB0fS8ke21heEF0dGVtcHRzfSlgKTtcbiAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlcmF0aW9uIGNhbmNlbGxlZCBkdWUgdG8gd2FsbGV0IGNvbm5lY3Rpb24gZXJyb3IuYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3Qgd2FsbGV0IGFmdGVyICR7bWF4QXR0ZW1wdHN9IGF0dGVtcHRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFpc0NvcnJlY3RXYWxsZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byB0aGUgY29ycmVjdCBlc2Nyb3cgd2FsbGV0LiBQbGVhc2UgZW5zdXJlIHRoZSBjb3JyZWN0IHdhbGxldCBpcyBzZWxlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBkcmF3IGNhc2VcbiAgICAgICAgaWYgKHdpbm5lciA9PT0gJ2RyYXcnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJEcmF3IGdhbWUgLSByZXR1cm5pbmcgZnVuZHMgdG8gYm90aCBwbGF5ZXJzXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBhIGRyYXcsIHJldHVybiBvcmlnaW5hbCBiZXQgYW1vdW50cyB0byBlYWNoIHBsYXllclxuICAgICAgICAgIC8vIFJldHVybiBmdW5kcyB0byBQbGF5ZXIgMVxuICAgICAgICAgIGlmIChwbGF5ZXIxV2FsbGV0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0dXJuaW5nICR7cGxheWVyMUJldH0gQVBUIHRvIFBsYXllciAxIGZyb20gZXNjcm93YCk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkMSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiBcIjB4MTo6Y29pbjo6dHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtcIjB4MTo6YXB0b3NfY29pbjo6QXB0b3NDb2luXCJdLFxuICAgICAgICAgICAgICBhcmd1bWVudHM6IFtwbGF5ZXIxV2FsbGV0LmFkZHJlc3MsIE1hdGguZmxvb3IocGxheWVyMUJldCAqIDEwMDAwMDAwMCkudG9TdHJpbmcoKV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHR4UmVzcG9uc2UxID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkMSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBsYXllciAxIHJlZnVuZCB0cmFuc2FjdGlvbjpcIiwgdHhSZXNwb25zZTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gZnVuZHMgdG8gUGxheWVyIDJcbiAgICAgICAgICBpZiAocGxheWVyMldhbGxldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFJldHVybmluZyAke3BsYXllcjJCZXR9IEFQVCB0byBQbGF5ZXIgMiBmcm9tIGVzY3Jvd2ApO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZDIgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogXCIweDE6OmNvaW46OnRyYW5zZmVyXCIsXG4gICAgICAgICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXCIweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pblwiXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBbcGxheWVyMldhbGxldC5hZGRyZXNzLCBNYXRoLmZsb29yKHBsYXllcjJCZXQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlMiA9IGF3YWl0IHdpbmRvdy5hcHRvcy5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24ocGF5bG9hZDIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQbGF5ZXIgMiByZWZ1bmQgdHJhbnNhY3Rpb246XCIsIHR4UmVzcG9uc2UyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIC8vIEhhbmRsZSB3aW5uZXIgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3aW5uZXJXYWxsZXQgPSB3aW5uZXIgPT09ICdwbGF5ZXIxJyA/IHBsYXllcjFXYWxsZXQgOiBwbGF5ZXIyV2FsbGV0O1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghd2lubmVyV2FsbGV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaW5uZXIgd2FsbGV0IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFRyYW5zZmVycmluZyAke2ZpbmFsQmV0QW1vdW50fSBBUFQgdG8gd2lubmVyICgke3dpbm5lcldhbGxldC5hZGRyZXNzfSlgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmFuc2ZlciBhbGwgZnVuZHMgZnJvbSBlc2Nyb3cgdG8gd2lubmVyXG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtcIjB4MTo6YXB0b3NfY29pbjo6QXB0b3NDb2luXCJdLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbd2lubmVyV2FsbGV0LmFkZHJlc3MsIE1hdGguZmxvb3IoZmluYWxCZXRBbW91bnQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldpbm5lciBwYXltZW50IHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBsYXllciBiYWxhbmNlcyBhZnRlciB0cmFuc2ZlcnNcbiAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocGxheWVyMldhbGxldCkge1xuICAgICAgICAgIGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHBsYXllcjJXYWxsZXQuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICAvLyBTaW11bGF0aW9uIG1vZGUgaGFuZGxpbmdcbiAgICAgIGVsc2UgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gYm90aCBwbGF5ZXJzIHJlY2VpdmUgdGhlaXIgYmV0cyBiYWNrIChzaW11bGF0aW9uKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgUGxheWVyICR7d2lubmVyID09PSAncGxheWVyMScgPyAnMScgOiAnMid9IHdhbGxldCBiYWxhbmNlOiArJHtmaW5hbEJldEFtb3VudH0gQVBUIChzaW11bGF0aW9uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiV2lubmVyIHBheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGF5aW5nIHdpbm5lcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBwYXkgd2lubmVyXCIpO1xuICAgIH1cbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dMb2NrZWQsIGVzY3Jvd0FkZHJlc3NdKTtcblxuICAvLyBSZXNldCBlc2Nyb3cgc3RhdGVcbiAgY29uc3QgcmVzZXRFc2Nyb3dTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gICAgc2V0RXNjcm93QmFsYW5jZSgwKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgdXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgc2V0VXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgZXNjcm93TG9ja2VkLFxuICAgIHNldEVzY3Jvd0xvY2tlZCxcbiAgICBwbGF5ZXIxRXNjcm93TG9ja2VkLCBcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkLFxuICAgIHBsYXllcjJFc2Nyb3dMb2NrZWQsXG4gICAgc2V0UGxheWVyMkVzY3Jvd0xvY2tlZCxcbiAgICBlc2Nyb3dBZGRyZXNzLFxuICAgIHNldEVzY3Jvd0FkZHJlc3MsXG4gICAgZXNjcm93U3RhdHVzLFxuICAgIHNldEVzY3Jvd1N0YXR1cyxcbiAgICBlc2Nyb3dCYWxhbmNlLFxuICAgIHNldEVzY3Jvd0JhbGFuY2UsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHNldEVycm9yLFxuICAgIGluaXRpYWxpemVFc2Nyb3csXG4gICAgY3JlYXRlU2ltdWxhdGVkRXNjcm93LFxuICAgIGNvbm5lY3RFc2Nyb3dXYWxsZXQsXG4gICAgbG9ja0VzY3JvdyxcbiAgICBwYXlXaW5uZXIsXG4gICAgcmVzZXRFc2Nyb3dTdGF0ZSxcbiAgICBlc2Nyb3dBZGFwdGVyXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsIkVzY3Jvd0NvbnRyYWN0QWRhcHRlciIsIkVzY3Jvd1N0YXR1cyIsInVzZUVzY3JvdyIsImVzY3Jvd0FkYXB0ZXIiLCJ1c2VTaW11bGF0aW9uTW9kZSIsInNldFVzZVNpbXVsYXRpb25Nb2RlIiwiZXNjcm93TG9ja2VkIiwic2V0RXNjcm93TG9ja2VkIiwicGxheWVyMUVzY3Jvd0xvY2tlZCIsInNldFBsYXllcjFFc2Nyb3dMb2NrZWQiLCJwbGF5ZXIyRXNjcm93TG9ja2VkIiwic2V0UGxheWVyMkVzY3Jvd0xvY2tlZCIsImVzY3Jvd0FkZHJlc3MiLCJzZXRFc2Nyb3dBZGRyZXNzIiwiZXNjcm93U3RhdHVzIiwic2V0RXNjcm93U3RhdHVzIiwiUEVORElORyIsImVzY3Jvd0JhbGFuY2UiLCJzZXRFc2Nyb3dCYWxhbmNlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxpemVFc2Nyb3ciLCJwbGF5ZXIxV2FsbGV0IiwicGxheWVyMldhbGxldCIsImNvbnNvbGUiLCJsb2ciLCJzaW11bGF0ZWRBZGRyZXNzIiwiRGF0ZSIsIm5vdyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNpbUVycm9yIiwid2luZG93IiwiYWxlcnQiLCJyZXNwb25zZSIsImFwdG9zIiwiY29ubmVjdCIsImFkZHJlc3MiLCJFcnJvciIsImluaXRpYWxpemVFc2Nyb3dSZXN1bHQiLCJ3YXJuIiwibWVzc2FnZSIsImNyZWF0ZVNpbXVsYXRlZEVzY3JvdyIsImNvbm5lY3RFc2Nyb3dXYWxsZXQiLCJsb2NrRXNjcm93IiwicGxheWVyTnVtYmVyIiwicGxheWVyMUJldCIsInBsYXllcjJCZXQiLCJlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkIiwiZ2V0QWNjb3VudEJhbGFuY2UiLCJ0cmFuc2ZlclRvRXNjcm93IiwibWluaW11bUJldCIsIk1hdGgiLCJtaW4iLCJwbGF5ZXJXYWxsZXQiLCJwcmV2QmFsYW5jZSIsIm1heEF0dGVtcHRzIiwiaXNXYWxsZXRDb25uZWN0ZWQiLCJhdHRlbXB0Iiwic2hvdWxkUmV0cnkiLCJjb25maXJtIiwidHJhbnNmZXJTdWNjZXNzIiwibmV3QmFsYW5jZSIsImVzY3Jvd0JhbGFuY2VSZXN1bHQiLCJib3RoUGxheWVyc0xvY2tlZCIsImZpbmFsUG9vbEFtb3VudCIsIndhc0xvY2tlZCIsInBheVdpbm5lciIsIndpbm5lciIsImZpbmFsQmV0QW1vdW50IiwiZXNjcm93V2FsbGV0Q29ubmVjdGVkIiwiaXNDb3JyZWN0V2FsbGV0Iiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicGF5bG9hZDEiLCJ0eXBlIiwiZnVuY3Rpb24iLCJ0eXBlX2FyZ3VtZW50cyIsImFyZ3VtZW50cyIsImZsb29yIiwidG9TdHJpbmciLCJ0eFJlc3BvbnNlMSIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsInBheWxvYWQyIiwidHhSZXNwb25zZTIiLCJ3aW5uZXJXYWxsZXQiLCJwYXlsb2FkIiwidHhSZXNwb25zZSIsInJlc2V0RXNjcm93U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useEscrow.ts\n"));

/***/ })

});