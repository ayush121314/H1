"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/hooks/useEscrow.ts":
/*!********************************!*\
  !*** ./src/hooks/useEscrow.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEscrow: function() { return /* binding */ useEscrow; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/EscrowContractAdapter */ \"./src/contracts/EscrowContractAdapter.ts\");\n\n\nfunction useEscrow() {\n    // Escrow adapter for blockchain interactions\n    const escrowAdapter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowContractAdapter(\"https://fullnode.testnet.aptoslabs.com/v1\", \"0x1\" // Default module address, would be replaced with actual deployed address\n        ), []);\n    // Escrow state\n    const [useSimulationMode, setUseSimulationMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // Default to false for production use\n    const [escrowLocked, setEscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player1EscrowLocked, setPlayer1EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player2EscrowLocked, setPlayer2EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [escrowAddress, setEscrowAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [escrowStatus, setEscrowStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    const [escrowBalance, setEscrowBalance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Initialize escrow\n    const initializeEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet)=>{\n        if (!player1Wallet || !player2Wallet) {\n            console.error(\"Cannot initialize escrow: both players must be connected\");\n            setError(\"Both players must be connected to initialize the escrow\");\n            return;\n        }\n        try {\n            setIsLoading(true);\n            console.log(\"Initializing escrow contract\");\n            // In simulation mode, just set a fake address\n            if (useSimulationMode) {\n                try {\n                    const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                    console.log(\"Creating simulated escrow with address:\", simulatedAddress);\n                    // Set the address in the adapter\n                    escrowAdapter.setEscrowAddress(simulatedAddress);\n                    // Set the address in our component state\n                    setEscrowAddress(simulatedAddress);\n                    console.log(\"Simulated escrow initialized with address:\", simulatedAddress);\n                    // Add a small delay to ensure state updates\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                    setIsLoading(false);\n                    return;\n                } catch (simError) {\n                    console.error(\"Error in simulation mode:\", simError);\n                // Continue to try real mode, but log the error\n                }\n            }\n            // Try connecting to Player 1's wallet\n            console.log(\"Attempting to connect to Player 1's wallet for escrow initialization\");\n            // Show prompt for wallet connection\n            window.alert(\"Please make sure a SEPARATE ESCROW wallet is selected in your Petra extension to initialize the escrow. This should NOT be the same as Player 1 or Player 2's wallet.\");\n            try {\n                const response = await window.aptos.connect();\n                // Check if this wallet is the same as player 1 or player 2\n                if (response && response.address === player1Wallet.address) {\n                    window.alert(\"Error: This wallet is the same as Player 1's wallet. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 1's wallet.\");\n                }\n                if (response && response.address === player2Wallet.address) {\n                    window.alert(\"Error: This wallet is the same as Player 2's wallet. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 2's wallet.\");\n                }\n                // Proceed with escrow initialization\n                if (response && response.address) {\n                    console.log(\"Connected to wallet, creating escrow\");\n                    const initializeEscrowResult = await escrowAdapter.initializeEscrow(window.aptos, player1Wallet.address, player2Wallet.address, 0.1, 24 * 60 * 60 // 24 hour timeout\n                    );\n                    if (initializeEscrowResult) {\n                        setEscrowAddress(initializeEscrowResult);\n                        console.log(\"Escrow contract created with address:\", initializeEscrowResult);\n                        setIsLoading(false);\n                        return;\n                    }\n                } else {\n                    console.warn(\"Connected to wrong wallet address:\", response === null || response === void 0 ? void 0 : response.address);\n                    throw new Error(\"Failed to connect wallet. Please make sure a valid wallet is selected.\");\n                }\n            } catch (error) {\n                console.error(\"Error with direct Petra connection:\", error);\n                throw error;\n            }\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            setError(error.message || \"Failed to initialize escrow\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Create a simulated escrow (for testing)\n    const createSimulatedEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!useSimulationMode) {\n            setError(\"Please enable simulation mode first\");\n            return;\n        }\n        console.log(\"Creating a simulated escrow for testing\");\n        const simulatedAddress = \"simulated_escrow_\" + Date.now();\n        escrowAdapter.setEscrowAddress(simulatedAddress);\n        setEscrowAddress(simulatedAddress);\n        console.log(\"Created simulated escrow with address:\", simulatedAddress);\n        // Also set escrow status to PENDING\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Connect escrow wallet\n    const connectEscrowWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting escrow wallet...\");\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension.\");\n                setIsLoading(false);\n                return;\n            }\n            // Prompt to select the escrow wallet\n            window.alert(\"Please make sure your ESCROW wallet is selected in your Petra extension.\\nIMPORTANT: This should be DIFFERENT from Player 1 and Player 2 wallets.\");\n            const response = await window.aptos.connect();\n            console.log(\"Escrow wallet connection response:\", response);\n            if (response && response.address) {\n                console.log(\"Connected to escrow wallet:\", response.address);\n                // Check if the wallet is the same as player 1 or player 2\n                if (player1Wallet && player1Wallet.address === response.address) {\n                    window.alert(\"Error: This wallet is already being used by Player 1. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 1's wallet.\");\n                }\n                if (player2Wallet && player2Wallet.address === response.address) {\n                    window.alert(\"Error: This wallet is already being used by Player 2. Please select a different wallet for escrow.\");\n                    throw new Error(\"Escrow wallet cannot be the same as Player 2's wallet.\");\n                }\n                // Set the escrow address in the adapter\n                escrowAdapter.setEscrowAddress(response.address);\n                // Set the address in component state\n                setEscrowAddress(response.address);\n                console.log(\"Escrow wallet set successfully:\", response.address);\n            } else {\n                throw new Error(\"Failed to get escrow wallet address\");\n            }\n        } catch (error) {\n            console.error(\"Error connecting escrow wallet:\", error);\n            setError(error.message || \"Failed to connect escrow wallet\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        escrowAdapter\n    ]);\n    // Lock the escrow by transferring the minimum bet amount from a specific player\n    const lockEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (playerNumber, player1Wallet, player2Wallet, player1Bet, player2Bet, ensureCorrectWalletConnected, getAccountBalance, transferToEscrow)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Starting escrow locking process for Player \".concat(playerNumber));\n            console.log(\"Current escrow lock status: Player 1: \".concat(player1EscrowLocked, \", Player 2: \").concat(player2EscrowLocked));\n            // Verify both players have placed bets\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must announce bets before locking escrow\");\n            }\n            // Determine the minimum bet amount (this is what will be deducted)\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Minimum bet amount between players: \".concat(minimumBet, \" APT\"));\n            // Get player wallet\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (!playerWallet) {\n                throw new Error(\"Player \".concat(playerNumber, \" wallet not connected\"));\n            }\n            // In simulation mode, create an escrow if not yet initialized\n            if (useSimulationMode && !escrowAddress) {\n                console.log(\"No escrow initialized yet, but in simulation mode. Creating escrow now...\");\n                const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                escrowAdapter.setEscrowAddress(simulatedAddress);\n                setEscrowAddress(simulatedAddress);\n                console.log(\"Auto-created simulated escrow with address:\", simulatedAddress);\n                // Brief pause to let state update\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            // Make sure an escrow address is set\n            if (!escrowAddress) {\n                throw new Error(\"No escrow wallet connected. Please connect the escrow wallet first.\");\n            }\n            console.log(\"Depositing \".concat(minimumBet, \" APT to escrow contract from Player \").concat(playerNumber));\n            // Use simulation mode if enabled\n            if (useSimulationMode) {\n                console.log(\"Using simulation mode - no actual transfer will occur\");\n                // Simulate deposit\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                } else {\n                    setPlayer2EscrowLocked(true);\n                }\n                console.log(\"Simulated escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance in simulation mode\n                setEscrowBalance((prevBalance)=>prevBalance + minimumBet);\n            } else {\n                // Real deposit by transferring funds to the escrow address\n                // Make sure the player's wallet is connected\n                const isWalletConnected = await ensureCorrectWalletConnected(playerNumber);\n                if (!isWalletConnected) {\n                    throw new Error(\"Please connect the wallet for Player \".concat(playerNumber, \" to continue\"));\n                }\n                // Direct transfer to escrow address - using minimumBet instead of player's full bet\n                const transferSuccess = await transferToEscrow(playerNumber, minimumBet, escrowAddress);\n                if (!transferSuccess) {\n                    throw new Error(\"Failed to transfer funds to escrow for Player \".concat(playerNumber));\n                }\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                    // Refresh balance\n                    if (player1Wallet) {\n                        const newBalance = await getAccountBalance(player1Wallet.address);\n                    }\n                } else {\n                    setPlayer2EscrowLocked(true);\n                    // Refresh balance\n                    if (player2Wallet) {\n                        const newBalance = await getAccountBalance(player2Wallet.address);\n                    }\n                }\n                console.log(\"Escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance - in real mode, we'd query the contract\n                if (escrowAddress) {\n                    const escrowBalanceResult = await getAccountBalance(escrowAddress);\n                    setEscrowBalance(escrowBalanceResult);\n                }\n            }\n            // Check if both players have locked their escrow after this player's lock\n            const bothPlayersLocked = playerNumber === 1 ?  true && player2EscrowLocked // Player 1 just locked + check if Player 2 was already locked\n             : player1EscrowLocked && true; // Check if Player 1 was already locked + Player 2 just locked\n            if (bothPlayersLocked) {\n                console.log(\"Both players have deposited funds to escrow. Ready to start game...\");\n                // Final pool amount is minimum bet × 2\n                const finalPoolAmount = minimumBet * 2;\n                console.log(\"Setting final bet amount to \".concat(finalPoolAmount, \" APT (\").concat(minimumBet, \" \\xd7 2)\"));\n                setEscrowLocked(true);\n            } else {\n                console.log(\"Waiting for the other player to lock their escrow\");\n            }\n            return {\n                wasLocked: true,\n                playerNumber,\n                minimumBet\n            };\n        } catch (error) {\n            console.error(\"Error locking escrow for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to lock escrow for Player \".concat(playerNumber));\n            return {\n                wasLocked: false,\n                error: error.message || \"Failed to lock escrow for Player \".concat(playerNumber)\n            };\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAddress,\n        player1EscrowLocked,\n        player2EscrowLocked,\n        escrowAdapter\n    ]);\n    // Pay winner from escrow\n    const payWinner = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (winner, player1Wallet, player2Wallet, player1Bet, player2Bet, finalBetAmount, getAccountBalance)=>{\n        try {\n            if (!winner) return;\n            console.log(\"Paying winner: \".concat(winner));\n            // Only proceed if not in simulation mode and escrow is locked\n            if (!useSimulationMode && escrowLocked && escrowAddress) {\n                // Handle draw case\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - returning funds to both players\");\n                    // For a draw, return original bet amounts to each player\n                    // Connect to escrow wallet first\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to return funds.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Return funds to Player 1\n                    if (player1Wallet) {\n                        console.log(\"Returning \".concat(player1Bet, \" APT to Player 1 from escrow\"));\n                        const payload1 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player1Wallet.address,\n                                Math.floor(player1Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse1 = await window.aptos.signAndSubmitTransaction(payload1);\n                        console.log(\"Player 1 refund transaction:\", txResponse1);\n                    }\n                    // Return funds to Player 2\n                    if (player2Wallet) {\n                        console.log(\"Returning \".concat(player2Bet, \" APT to Player 2 from escrow\"));\n                        const payload2 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player2Wallet.address,\n                                Math.floor(player2Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse2 = await window.aptos.signAndSubmitTransaction(payload2);\n                        console.log(\"Player 2 refund transaction:\", txResponse2);\n                    }\n                } else {\n                    const winnerWallet = winner === \"player1\" ? player1Wallet : player2Wallet;\n                    if (!winnerWallet) {\n                        throw new Error(\"Winner wallet not found\");\n                    }\n                    console.log(\"Transferring \".concat(finalBetAmount, \" APT to winner (\").concat(winnerWallet.address, \")\"));\n                    // Connect to escrow wallet\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to pay the winner.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Transfer all funds from escrow to winner\n                    const payload = {\n                        type: \"entry_function_payload\",\n                        function: \"0x1::coin::transfer\",\n                        type_arguments: [\n                            \"0x1::aptos_coin::AptosCoin\"\n                        ],\n                        arguments: [\n                            winnerWallet.address,\n                            Math.floor(finalBetAmount * 100000000).toString()\n                        ]\n                    };\n                    const txResponse = await window.aptos.signAndSubmitTransaction(payload);\n                    console.log(\"Winner payment transaction:\", txResponse);\n                }\n                // Update player balances after transfers\n                if (player1Wallet) {\n                    await getAccountBalance(player1Wallet.address);\n                }\n                if (player2Wallet) {\n                    await getAccountBalance(player2Wallet.address);\n                }\n            } else if (useSimulationMode) {\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - both players receive their bets back (simulation)\");\n                } else {\n                    console.log(\"Updating Player \".concat(winner === \"player1\" ? \"1\" : \"2\", \" wallet balance: +\").concat(finalBetAmount, \" APT (simulation)\"));\n                }\n            }\n            console.log(\"Winner payment completed successfully\");\n        } catch (error) {\n            console.error(\"Error paying winner:\", error);\n            setError(error.message || \"Failed to pay winner\");\n        }\n    }, [\n        useSimulationMode,\n        escrowLocked,\n        escrowAddress\n    ]);\n    // Reset escrow state\n    const resetEscrowState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setPlayer1EscrowLocked(false);\n        setPlayer2EscrowLocked(false);\n        setEscrowLocked(false);\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n        setEscrowBalance(0);\n    }, []);\n    return {\n        useSimulationMode,\n        setUseSimulationMode,\n        escrowLocked,\n        setEscrowLocked,\n        player1EscrowLocked,\n        setPlayer1EscrowLocked,\n        player2EscrowLocked,\n        setPlayer2EscrowLocked,\n        escrowAddress,\n        setEscrowAddress,\n        escrowStatus,\n        setEscrowStatus,\n        escrowBalance,\n        setEscrowBalance,\n        isLoading,\n        error,\n        setError,\n        initializeEscrow,\n        createSimulatedEscrow,\n        connectEscrowWallet,\n        lockEscrow,\n        payWinner,\n        resetEscrowState,\n        escrowAdapter\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFXQSxDQUFDO1FBQ25DVyx1QkFBdUI7UUFDdkJFLHVCQUF1QjtRQUN2QkosZ0JBQWdCO1FBQ2hCUSxnQkFBZ0JkLDBFQUFZQSxDQUFDZSxPQUFPO1FBQ3BDRSxpQkFBaUI7SUFDbkIsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMZDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBQztRQUNBc0I7UUFDQUM7UUFDQUM7UUFDQW1CO1FBQ0FrQjtRQUNBakY7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VFc2Nyb3cudHM/ZDI4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFc2Nyb3dDb250cmFjdEFkYXB0ZXIsIEVzY3Jvd1N0YXR1cyB9IGZyb20gJy4uL2NvbnRyYWN0cy9Fc2Nyb3dDb250cmFjdEFkYXB0ZXInO1xuaW1wb3J0IHsgUGxheWVyV2FsbGV0SW5mbyB9IGZyb20gJy4uL3R5cGVzL2dhbWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXNjcm93KCkge1xuICAvLyBFc2Nyb3cgYWRhcHRlciBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnNcbiAgY29uc3QgZXNjcm93QWRhcHRlciA9IHVzZU1lbW8oKCkgPT4gbmV3IEVzY3Jvd0NvbnRyYWN0QWRhcHRlcihcbiAgICAnaHR0cHM6Ly9mdWxsbm9kZS50ZXN0bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgICcweDEnIC8vIERlZmF1bHQgbW9kdWxlIGFkZHJlc3MsIHdvdWxkIGJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIGRlcGxveWVkIGFkZHJlc3NcbiAgKSwgW10pO1xuXG4gIC8vIEVzY3JvdyBzdGF0ZVxuICBjb25zdCBbdXNlU2ltdWxhdGlvbk1vZGUsIHNldFVzZVNpbXVsYXRpb25Nb2RlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTsgLy8gRGVmYXVsdCB0byBmYWxzZSBmb3IgcHJvZHVjdGlvbiB1c2VcbiAgY29uc3QgW2VzY3Jvd0xvY2tlZCwgc2V0RXNjcm93TG9ja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3BsYXllcjFFc2Nyb3dMb2NrZWQsIHNldFBsYXllcjFFc2Nyb3dMb2NrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbcGxheWVyMkVzY3Jvd0xvY2tlZCwgc2V0UGxheWVyMkVzY3Jvd0xvY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlc2Nyb3dBZGRyZXNzLCBzZXRFc2Nyb3dBZGRyZXNzXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXNjcm93U3RhdHVzLCBzZXRFc2Nyb3dTdGF0dXNdID0gdXNlU3RhdGU8RXNjcm93U3RhdHVzPihFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gIGNvbnN0IFtlc2Nyb3dCYWxhbmNlLCBzZXRFc2Nyb3dCYWxhbmNlXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBlc2Nyb3dcbiAgY29uc3QgaW5pdGlhbGl6ZUVzY3JvdyA9IHVzZUNhbGxiYWNrKGFzeW5jIChcbiAgICBwbGF5ZXIxV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCwgXG4gICAgcGxheWVyMldhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGxcbiAgKSA9PiB7XG4gICAgaWYgKCFwbGF5ZXIxV2FsbGV0IHx8ICFwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgZXNjcm93OiBib3RoIHBsYXllcnMgbXVzdCBiZSBjb25uZWN0ZWRcIik7XG4gICAgICBzZXRFcnJvcihcIkJvdGggcGxheWVycyBtdXN0IGJlIGNvbm5lY3RlZCB0byBpbml0aWFsaXplIHRoZSBlc2Nyb3dcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIGVzY3JvdyBjb250cmFjdFwiKTtcblxuICAgICAgLy8gSW4gc2ltdWxhdGlvbiBtb2RlLCBqdXN0IHNldCBhIGZha2UgYWRkcmVzc1xuICAgICAgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2ltdWxhdGVkQWRkcmVzcyA9ICdzaW11bGF0ZWRfZXNjcm93XycgKyBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgc2ltdWxhdGVkIGVzY3JvdyB3aXRoIGFkZHJlc3M6XCIsIHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0aGUgYWRkcmVzcyBpbiB0aGUgYWRhcHRlclxuICAgICAgICAgIGVzY3Jvd0FkYXB0ZXIuc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdGhlIGFkZHJlc3MgaW4gb3VyIGNvbXBvbmVudCBzdGF0ZVxuICAgICAgICAgIHNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTaW11bGF0ZWQgZXNjcm93IGluaXRpYWxpemVkIHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIHN0YXRlIHVwZGF0ZXNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKHNpbUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNpbXVsYXRpb24gbW9kZTpcIiwgc2ltRXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRvIHRyeSByZWFsIG1vZGUsIGJ1dCBsb2cgdGhlIGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IGNvbm5lY3RpbmcgdG8gUGxheWVyIDEncyB3YWxsZXRcbiAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIFBsYXllciAxJ3Mgd2FsbGV0IGZvciBlc2Nyb3cgaW5pdGlhbGl6YXRpb25cIik7XG4gICAgICBcbiAgICAgIC8vIFNob3cgcHJvbXB0IGZvciB3YWxsZXQgY29ubmVjdGlvblxuICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIG1ha2Ugc3VyZSBhIFNFUEFSQVRFIEVTQ1JPVyB3YWxsZXQgaXMgc2VsZWN0ZWQgaW4geW91ciBQZXRyYSBleHRlbnNpb24gdG8gaW5pdGlhbGl6ZSB0aGUgZXNjcm93LiBUaGlzIHNob3VsZCBOT1QgYmUgdGhlIHNhbWUgYXMgUGxheWVyIDEgb3IgUGxheWVyIDIncyB3YWxsZXQuXCIpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHdhbGxldCBpcyB0aGUgc2FtZSBhcyBwbGF5ZXIgMSBvciBwbGF5ZXIgMlxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYWRkcmVzcyA9PT0gcGxheWVyMVdhbGxldC5hZGRyZXNzKSB7XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiRXJyb3I6IFRoaXMgd2FsbGV0IGlzIHRoZSBzYW1lIGFzIFBsYXllciAxJ3Mgd2FsbGV0LiBQbGVhc2Ugc2VsZWN0IGEgZGlmZmVyZW50IHdhbGxldCBmb3IgZXNjcm93LlwiKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgd2FsbGV0IGNhbm5vdCBiZSB0aGUgc2FtZSBhcyBQbGF5ZXIgMSdzIHdhbGxldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5hZGRyZXNzID09PSBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MpIHtcbiAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJFcnJvcjogVGhpcyB3YWxsZXQgaXMgdGhlIHNhbWUgYXMgUGxheWVyIDIncyB3YWxsZXQuIFBsZWFzZSBzZWxlY3QgYSBkaWZmZXJlbnQgd2FsbGV0IGZvciBlc2Nyb3cuXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyB3YWxsZXQgY2Fubm90IGJlIHRoZSBzYW1lIGFzIFBsYXllciAyJ3Mgd2FsbGV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VlZCB3aXRoIGVzY3JvdyBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIHdhbGxldCwgY3JlYXRpbmcgZXNjcm93XCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGluaXRpYWxpemVFc2Nyb3dSZXN1bHQgPSBhd2FpdCBlc2Nyb3dBZGFwdGVyLmluaXRpYWxpemVFc2Nyb3coXG4gICAgICAgICAgICB3aW5kb3cuYXB0b3MsXG4gICAgICAgICAgICBwbGF5ZXIxV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICAwLjEsIC8vIE1pbmltdW0gYmV0IG9mIDAuMSBBUFRcbiAgICAgICAgICAgIDI0ICogNjAgKiA2MCAvLyAyNCBob3VyIHRpbWVvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpbml0aWFsaXplRXNjcm93UmVzdWx0KSB7XG4gICAgICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKGluaXRpYWxpemVFc2Nyb3dSZXN1bHQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFc2Nyb3cgY29udHJhY3QgY3JlYXRlZCB3aXRoIGFkZHJlc3M6XCIsIGluaXRpYWxpemVFc2Nyb3dSZXN1bHQpO1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ29ubmVjdGVkIHRvIHdyb25nIHdhbGxldCBhZGRyZXNzOlwiLCByZXNwb25zZT8uYWRkcmVzcyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQuIFBsZWFzZSBtYWtlIHN1cmUgYSB2YWxpZCB3YWxsZXQgaXMgc2VsZWN0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdpdGggZGlyZWN0IFBldHJhIGNvbm5lY3Rpb246XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluaXRpYWxpemluZyBlc2Nyb3c6XCIsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBlc2Nyb3dcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbdXNlU2ltdWxhdGlvbk1vZGUsIGVzY3Jvd0FkYXB0ZXJdKTtcblxuICAvLyBDcmVhdGUgYSBzaW11bGF0ZWQgZXNjcm93IChmb3IgdGVzdGluZylcbiAgY29uc3QgY3JlYXRlU2ltdWxhdGVkRXNjcm93ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghdXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgIHNldEVycm9yKFwiUGxlYXNlIGVuYWJsZSBzaW11bGF0aW9uIG1vZGUgZmlyc3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgYSBzaW11bGF0ZWQgZXNjcm93IGZvciB0ZXN0aW5nXCIpO1xuICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZWQgc2ltdWxhdGVkIGVzY3JvdyB3aXRoIGFkZHJlc3M6XCIsIHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgIFxuICAgIC8vIEFsc28gc2V0IGVzY3JvdyBzdGF0dXMgdG8gUEVORElOR1xuICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gIH0sIFt1c2VTaW11bGF0aW9uTW9kZSwgZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIENvbm5lY3QgZXNjcm93IHdhbGxldFxuICBjb25zdCBjb25uZWN0RXNjcm93V2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHBsYXllcjFXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLFxuICAgIHBsYXllcjJXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsXG4gICkgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW5nIGVzY3JvdyB3YWxsZXQuLi5cIik7XG4gICAgICBcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LmFwdG9zKSB7XG4gICAgICAgIHNldEVycm9yKFwiUGV0cmEgd2FsbGV0IGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIHRoZSBQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9tcHQgdG8gc2VsZWN0IHRoZSBlc2Nyb3cgd2FsbGV0XG4gICAgICB3aW5kb3cuYWxlcnQoXCJQbGVhc2UgbWFrZSBzdXJlIHlvdXIgRVNDUk9XIHdhbGxldCBpcyBzZWxlY3RlZCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbi5cXG5JTVBPUlRBTlQ6IFRoaXMgc2hvdWxkIGJlIERJRkZFUkVOVCBmcm9tIFBsYXllciAxIGFuZCBQbGF5ZXIgMiB3YWxsZXRzLlwiKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJFc2Nyb3cgd2FsbGV0IGNvbm5lY3Rpb24gcmVzcG9uc2U6XCIsIHJlc3BvbnNlKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gZXNjcm93IHdhbGxldDpcIiwgcmVzcG9uc2UuYWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgd2FsbGV0IGlzIHRoZSBzYW1lIGFzIHBsYXllciAxIG9yIHBsYXllciAyXG4gICAgICAgIGlmIChwbGF5ZXIxV2FsbGV0ICYmIHBsYXllcjFXYWxsZXQuYWRkcmVzcyA9PT0gcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICAgIHdpbmRvdy5hbGVydChcIkVycm9yOiBUaGlzIHdhbGxldCBpcyBhbHJlYWR5IGJlaW5nIHVzZWQgYnkgUGxheWVyIDEuIFBsZWFzZSBzZWxlY3QgYSBkaWZmZXJlbnQgd2FsbGV0IGZvciBlc2Nyb3cuXCIpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyB3YWxsZXQgY2Fubm90IGJlIHRoZSBzYW1lIGFzIFBsYXllciAxJ3Mgd2FsbGV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBsYXllcjJXYWxsZXQgJiYgcGxheWVyMldhbGxldC5hZGRyZXNzID09PSByZXNwb25zZS5hZGRyZXNzKSB7XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiRXJyb3I6IFRoaXMgd2FsbGV0IGlzIGFscmVhZHkgYmVpbmcgdXNlZCBieSBQbGF5ZXIgMi4gUGxlYXNlIHNlbGVjdCBhIGRpZmZlcmVudCB3YWxsZXQgZm9yIGVzY3Jvdy5cIik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IHdhbGxldCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgUGxheWVyIDIncyB3YWxsZXQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGhlIGVzY3JvdyBhZGRyZXNzIGluIHRoZSBhZGFwdGVyXG4gICAgICAgIGVzY3Jvd0FkYXB0ZXIuc2V0RXNjcm93QWRkcmVzcyhyZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgYWRkcmVzcyBpbiBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgc2V0RXNjcm93QWRkcmVzcyhyZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXNjcm93IHdhbGxldCBzZXQgc3VjY2Vzc2Z1bGx5OlwiLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgZXNjcm93IHdhbGxldCBhZGRyZXNzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbm5lY3RpbmcgZXNjcm93IHdhbGxldDpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBjb25uZWN0IGVzY3JvdyB3YWxsZXRcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIExvY2sgdGhlIGVzY3JvdyBieSB0cmFuc2ZlcnJpbmcgdGhlIG1pbmltdW0gYmV0IGFtb3VudCBmcm9tIGEgc3BlY2lmaWMgcGxheWVyXG4gIGNvbnN0IGxvY2tFc2Nyb3cgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgcGxheWVyTnVtYmVyOiAxIHwgMiwgXG4gICAgcGxheWVyMVdhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsXG4gICAgcGxheWVyMldhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsXG4gICAgcGxheWVyMUJldDogbnVtYmVyLFxuICAgIHBsYXllcjJCZXQ6IG51bWJlcixcbiAgICBlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkOiAocGxheWVyTnVtYmVyOiAxIHwgMikgPT4gUHJvbWlzZTxib29sZWFuPixcbiAgICBnZXRBY2NvdW50QmFsYW5jZTogKGFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTxudW1iZXI+LFxuICAgIHRyYW5zZmVyVG9Fc2Nyb3c6IChwbGF5ZXJOdW1iZXI6IDEgfCAyLCBhbW91bnQ6IG51bWJlciwgdGFyZ2V0QWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gICkgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGVzY3JvdyBsb2NraW5nIHByb2Nlc3MgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IGVzY3JvdyBsb2NrIHN0YXR1czogUGxheWVyIDE6ICR7cGxheWVyMUVzY3Jvd0xvY2tlZH0sIFBsYXllciAyOiAke3BsYXllcjJFc2Nyb3dMb2NrZWR9YCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBib3RoIHBsYXllcnMgaGF2ZSBwbGFjZWQgYmV0c1xuICAgICAgaWYgKHBsYXllcjFCZXQgPD0gMCB8fCBwbGF5ZXIyQmV0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBwbGF5ZXJzIG11c3QgYW5ub3VuY2UgYmV0cyBiZWZvcmUgbG9ja2luZyBlc2Nyb3dcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSB0aGUgbWluaW11bSBiZXQgYW1vdW50ICh0aGlzIGlzIHdoYXQgd2lsbCBiZSBkZWR1Y3RlZClcbiAgICAgIGNvbnN0IG1pbmltdW1CZXQgPSBNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KTtcbiAgICAgIGNvbnNvbGUubG9nKGBNaW5pbXVtIGJldCBhbW91bnQgYmV0d2VlbiBwbGF5ZXJzOiAke21pbmltdW1CZXR9IEFQVGApO1xuICAgICAgXG4gICAgICAvLyBHZXQgcGxheWVyIHdhbGxldFxuICAgICAgY29uc3QgcGxheWVyV2FsbGV0ID0gcGxheWVyTnVtYmVyID09PSAxID8gcGxheWVyMVdhbGxldCA6IHBsYXllcjJXYWxsZXQ7XG4gICAgICBpZiAoIXBsYXllcldhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXllciAke3BsYXllck51bWJlcn0gd2FsbGV0IG5vdCBjb25uZWN0ZWRgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW4gc2ltdWxhdGlvbiBtb2RlLCBjcmVhdGUgYW4gZXNjcm93IGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSAmJiAhZXNjcm93QWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGVzY3JvdyBpbml0aWFsaXplZCB5ZXQsIGJ1dCBpbiBzaW11bGF0aW9uIG1vZGUuIENyZWF0aW5nIGVzY3JvdyBub3cuLi5cIik7XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgZXNjcm93QWRhcHRlci5zZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkF1dG8tY3JlYXRlZCBzaW11bGF0ZWQgZXNjcm93IHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBCcmllZiBwYXVzZSB0byBsZXQgc3RhdGUgdXBkYXRlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIGFuIGVzY3JvdyBhZGRyZXNzIGlzIHNldFxuICAgICAgaWYgKCFlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVzY3JvdyB3YWxsZXQgY29ubmVjdGVkLiBQbGVhc2UgY29ubmVjdCB0aGUgZXNjcm93IHdhbGxldCBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBEZXBvc2l0aW5nICR7bWluaW11bUJldH0gQVBUIHRvIGVzY3JvdyBjb250cmFjdCBmcm9tIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHNpbXVsYXRpb24gbW9kZSBpZiBlbmFibGVkXG4gICAgICBpZiAodXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBzaW11bGF0aW9uIG1vZGUgLSBubyBhY3R1YWwgdHJhbnNmZXIgd2lsbCBvY2N1clwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXVsYXRlIGRlcG9zaXRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBVSSBzdGF0ZVxuICAgICAgICBpZiAocGxheWVyTnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgc2V0UGxheWVyMUVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU2ltdWxhdGVkIGVzY3JvdyBsb2NrIHN1Y2Nlc3NmdWwgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBlc2Nyb3cgYmFsYW5jZSBpbiBzaW11bGF0aW9uIG1vZGVcbiAgICAgICAgc2V0RXNjcm93QmFsYW5jZShwcmV2QmFsYW5jZSA9PiBwcmV2QmFsYW5jZSArIG1pbmltdW1CZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVhbCBkZXBvc2l0IGJ5IHRyYW5zZmVycmluZyBmdW5kcyB0byB0aGUgZXNjcm93IGFkZHJlc3NcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwbGF5ZXIncyB3YWxsZXQgaXMgY29ubmVjdGVkXG4gICAgICAgIGNvbnN0IGlzV2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZChwbGF5ZXJOdW1iZXIpO1xuICAgICAgICBpZiAoIWlzV2FsbGV0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgY29ubmVjdCB0aGUgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IHRvIGNvbnRpbnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERpcmVjdCB0cmFuc2ZlciB0byBlc2Nyb3cgYWRkcmVzcyAtIHVzaW5nIG1pbmltdW1CZXQgaW5zdGVhZCBvZiBwbGF5ZXIncyBmdWxsIGJldFxuICAgICAgICBjb25zdCB0cmFuc2ZlclN1Y2Nlc3MgPSBhd2FpdCB0cmFuc2ZlclRvRXNjcm93KHBsYXllck51bWJlciwgbWluaW11bUJldCwgZXNjcm93QWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRyYW5zZmVyU3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHRyYW5zZmVyIGZ1bmRzIHRvIGVzY3JvdyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVUkgc3RhdGVcbiAgICAgICAgaWYgKHBsYXllck51bWJlciA9PT0gMSkge1xuICAgICAgICAgIHNldFBsYXllcjFFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVmcmVzaCBiYWxhbmNlXG4gICAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZnJlc2ggYmFsYW5jZVxuICAgICAgICAgIGlmIChwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCYWxhbmNlID0gYXdhaXQgZ2V0QWNjb3VudEJhbGFuY2UocGxheWVyMldhbGxldC5hZGRyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc2Nyb3cgbG9jayBzdWNjZXNzZnVsIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZXNjcm93IGJhbGFuY2UgLSBpbiByZWFsIG1vZGUsIHdlJ2QgcXVlcnkgdGhlIGNvbnRyYWN0XG4gICAgICAgIGlmIChlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3QgZXNjcm93QmFsYW5jZVJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKGVzY3Jvd0FkZHJlc3MpO1xuICAgICAgICAgIHNldEVzY3Jvd0JhbGFuY2UoZXNjcm93QmFsYW5jZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwbGF5ZXJzIGhhdmUgbG9ja2VkIHRoZWlyIGVzY3JvdyBhZnRlciB0aGlzIHBsYXllcidzIGxvY2tcbiAgICAgIGNvbnN0IGJvdGhQbGF5ZXJzTG9ja2VkID0gcGxheWVyTnVtYmVyID09PSAxIFxuICAgICAgICA/IHRydWUgJiYgcGxheWVyMkVzY3Jvd0xvY2tlZCAgLy8gUGxheWVyIDEganVzdCBsb2NrZWQgKyBjaGVjayBpZiBQbGF5ZXIgMiB3YXMgYWxyZWFkeSBsb2NrZWRcbiAgICAgICAgOiBwbGF5ZXIxRXNjcm93TG9ja2VkICYmIHRydWU7IC8vIENoZWNrIGlmIFBsYXllciAxIHdhcyBhbHJlYWR5IGxvY2tlZCArIFBsYXllciAyIGp1c3QgbG9ja2VkXG4gICAgICAgIFxuICAgICAgaWYgKGJvdGhQbGF5ZXJzTG9ja2VkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQm90aCBwbGF5ZXJzIGhhdmUgZGVwb3NpdGVkIGZ1bmRzIHRvIGVzY3Jvdy4gUmVhZHkgdG8gc3RhcnQgZ2FtZS4uLlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmFsIHBvb2wgYW1vdW50IGlzIG1pbmltdW0gYmV0IMOXIDJcbiAgICAgICAgY29uc3QgZmluYWxQb29sQW1vdW50ID0gbWluaW11bUJldCAqIDI7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBmaW5hbCBiZXQgYW1vdW50IHRvICR7ZmluYWxQb29sQW1vdW50fSBBUFQgKCR7bWluaW11bUJldH0gw5cgMilgKTtcbiAgICAgICAgc2V0RXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgZm9yIHRoZSBvdGhlciBwbGF5ZXIgdG8gbG9jayB0aGVpciBlc2Nyb3dgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2FzTG9ja2VkOiB0cnVlLFxuICAgICAgICBwbGF5ZXJOdW1iZXIsXG4gICAgICAgIG1pbmltdW1CZXRcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9ja2luZyBlc2Nyb3cgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGxvY2sgZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YXNMb2NrZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGxvY2sgZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YFxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFt1c2VTaW11bGF0aW9uTW9kZSwgZXNjcm93QWRkcmVzcywgcGxheWVyMUVzY3Jvd0xvY2tlZCwgcGxheWVyMkVzY3Jvd0xvY2tlZCwgZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIFBheSB3aW5uZXIgZnJvbSBlc2Nyb3dcbiAgY29uc3QgcGF5V2lubmVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHdpbm5lcjogJ3BsYXllcjEnIHwgJ3BsYXllcjInIHwgJ2RyYXcnIHwgbnVsbCxcbiAgICBwbGF5ZXIxV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIyV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIxQmV0OiBudW1iZXIsXG4gICAgcGxheWVyMkJldDogbnVtYmVyLFxuICAgIGZpbmFsQmV0QW1vdW50OiBudW1iZXIsXG4gICAgZ2V0QWNjb3VudEJhbGFuY2U6IChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8bnVtYmVyPlxuICApID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF3aW5uZXIpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFBheWluZyB3aW5uZXI6ICR7d2lubmVyfWApO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHByb2NlZWQgaWYgbm90IGluIHNpbXVsYXRpb24gbW9kZSBhbmQgZXNjcm93IGlzIGxvY2tlZFxuICAgICAgaWYgKCF1c2VTaW11bGF0aW9uTW9kZSAmJiBlc2Nyb3dMb2NrZWQgJiYgZXNjcm93QWRkcmVzcykge1xuICAgICAgICAvLyBIYW5kbGUgZHJhdyBjYXNlXG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gcmV0dXJuaW5nIGZ1bmRzIHRvIGJvdGggcGxheWVyc1wiKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3IgYSBkcmF3LCByZXR1cm4gb3JpZ2luYWwgYmV0IGFtb3VudHMgdG8gZWFjaCBwbGF5ZXJcbiAgICAgICAgICAvLyBDb25uZWN0IHRvIGVzY3JvdyB3YWxsZXQgZmlyc3RcbiAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJQbGVhc2Ugc2VsZWN0IHRoZSBFU0NST1cgd2FsbGV0IGluIHlvdXIgUGV0cmEgZXh0ZW5zaW9uIHRvIHJldHVybiBmdW5kcy5cIik7XG4gICAgICAgICAgY29uc3QgZXNjcm93V2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWVzY3Jvd1dhbGxldENvbm5lY3RlZCB8fCBlc2Nyb3dXYWxsZXRDb25uZWN0ZWQuYWRkcmVzcyAhPT0gZXNjcm93QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gZXNjcm93IHdhbGxldC4gUGxlYXNlIGVuc3VyZSB0aGUgY29ycmVjdCB3YWxsZXQgaXMgc2VsZWN0ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gZnVuZHMgdG8gUGxheWVyIDFcbiAgICAgICAgICBpZiAocGxheWVyMVdhbGxldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFJldHVybmluZyAke3BsYXllcjFCZXR9IEFQVCB0byBQbGF5ZXIgMSBmcm9tIGVzY3Jvd2ApO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZDEgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogXCIweDE6OmNvaW46OnRyYW5zZmVyXCIsXG4gICAgICAgICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXCIweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pblwiXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBbcGxheWVyMVdhbGxldC5hZGRyZXNzLCBNYXRoLmZsb29yKHBsYXllcjFCZXQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlMSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24ocGF5bG9hZDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQbGF5ZXIgMSByZWZ1bmQgdHJhbnNhY3Rpb246XCIsIHR4UmVzcG9uc2UxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIGZ1bmRzIHRvIFBsYXllciAyXG4gICAgICAgICAgaWYgKHBsYXllcjJXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgJHtwbGF5ZXIyQmV0fSBBUFQgdG8gUGxheWVyIDIgZnJvbSBlc2Nyb3dgKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQyID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgICB0eXBlX2FyZ3VtZW50czogW1wiMHgxOjphcHRvc19jb2luOjpBcHRvc0NvaW5cIl0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogW3BsYXllcjJXYWxsZXQuYWRkcmVzcywgTWF0aC5mbG9vcihwbGF5ZXIyQmV0ICogMTAwMDAwMDAwKS50b1N0cmluZygpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdHhSZXNwb25zZTIgPSBhd2FpdCB3aW5kb3cuYXB0b3Muc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGxheWVyIDIgcmVmdW5kIHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICAvLyBIYW5kbGUgd2lubmVyIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd2lubmVyV2FsbGV0ID0gd2lubmVyID09PSAncGxheWVyMScgPyBwbGF5ZXIxV2FsbGV0IDogcGxheWVyMldhbGxldDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXdpbm5lcldhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lubmVyIHdhbGxldCBub3QgZm91bmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBUcmFuc2ZlcnJpbmcgJHtmaW5hbEJldEFtb3VudH0gQVBUIHRvIHdpbm5lciAoJHt3aW5uZXJXYWxsZXQuYWRkcmVzc30pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBlc2Nyb3cgd2FsbGV0XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIHNlbGVjdCB0aGUgRVNDUk9XIHdhbGxldCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byBwYXkgdGhlIHdpbm5lci5cIik7XG4gICAgICAgICAgY29uc3QgZXNjcm93V2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWVzY3Jvd1dhbGxldENvbm5lY3RlZCB8fCBlc2Nyb3dXYWxsZXRDb25uZWN0ZWQuYWRkcmVzcyAhPT0gZXNjcm93QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gZXNjcm93IHdhbGxldC4gUGxlYXNlIGVuc3VyZSB0aGUgY29ycmVjdCB3YWxsZXQgaXMgc2VsZWN0ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmFuc2ZlciBhbGwgZnVuZHMgZnJvbSBlc2Nyb3cgdG8gd2lubmVyXG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtcIjB4MTo6YXB0b3NfY29pbjo6QXB0b3NDb2luXCJdLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbd2lubmVyV2FsbGV0LmFkZHJlc3MsIE1hdGguZmxvb3IoZmluYWxCZXRBbW91bnQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldpbm5lciBwYXltZW50IHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBsYXllciBiYWxhbmNlcyBhZnRlciB0cmFuc2ZlcnNcbiAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocGxheWVyMldhbGxldCkge1xuICAgICAgICAgIGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHBsYXllcjJXYWxsZXQuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICAvLyBTaW11bGF0aW9uIG1vZGUgaGFuZGxpbmdcbiAgICAgIGVsc2UgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gYm90aCBwbGF5ZXJzIHJlY2VpdmUgdGhlaXIgYmV0cyBiYWNrIChzaW11bGF0aW9uKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgUGxheWVyICR7d2lubmVyID09PSAncGxheWVyMScgPyAnMScgOiAnMid9IHdhbGxldCBiYWxhbmNlOiArJHtmaW5hbEJldEFtb3VudH0gQVBUIChzaW11bGF0aW9uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiV2lubmVyIHBheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGF5aW5nIHdpbm5lcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBwYXkgd2lubmVyXCIpO1xuICAgIH1cbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dMb2NrZWQsIGVzY3Jvd0FkZHJlc3NdKTtcblxuICAvLyBSZXNldCBlc2Nyb3cgc3RhdGVcbiAgY29uc3QgcmVzZXRFc2Nyb3dTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gICAgc2V0RXNjcm93QmFsYW5jZSgwKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgdXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgc2V0VXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgZXNjcm93TG9ja2VkLFxuICAgIHNldEVzY3Jvd0xvY2tlZCxcbiAgICBwbGF5ZXIxRXNjcm93TG9ja2VkLCBcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkLFxuICAgIHBsYXllcjJFc2Nyb3dMb2NrZWQsXG4gICAgc2V0UGxheWVyMkVzY3Jvd0xvY2tlZCxcbiAgICBlc2Nyb3dBZGRyZXNzLFxuICAgIHNldEVzY3Jvd0FkZHJlc3MsXG4gICAgZXNjcm93U3RhdHVzLFxuICAgIHNldEVzY3Jvd1N0YXR1cyxcbiAgICBlc2Nyb3dCYWxhbmNlLFxuICAgIHNldEVzY3Jvd0JhbGFuY2UsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHNldEVycm9yLFxuICAgIGluaXRpYWxpemVFc2Nyb3csXG4gICAgY3JlYXRlU2ltdWxhdGVkRXNjcm93LFxuICAgIGNvbm5lY3RFc2Nyb3dXYWxsZXQsXG4gICAgbG9ja0VzY3JvdyxcbiAgICBwYXlXaW5uZXIsXG4gICAgcmVzZXRFc2Nyb3dTdGF0ZSxcbiAgICBlc2Nyb3dBZGFwdGVyXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsIkVzY3Jvd0NvbnRyYWN0QWRhcHRlciIsIkVzY3Jvd1N0YXR1cyIsInVzZUVzY3JvdyIsImVzY3Jvd0FkYXB0ZXIiLCJ1c2VTaW11bGF0aW9uTW9kZSIsInNldFVzZVNpbXVsYXRpb25Nb2RlIiwiZXNjcm93TG9ja2VkIiwic2V0RXNjcm93TG9ja2VkIiwicGxheWVyMUVzY3Jvd0xvY2tlZCIsInNldFBsYXllcjFFc2Nyb3dMb2NrZWQiLCJwbGF5ZXIyRXNjcm93TG9ja2VkIiwic2V0UGxheWVyMkVzY3Jvd0xvY2tlZCIsImVzY3Jvd0FkZHJlc3MiLCJzZXRFc2Nyb3dBZGRyZXNzIiwiZXNjcm93U3RhdHVzIiwic2V0RXNjcm93U3RhdHVzIiwiUEVORElORyIsImVzY3Jvd0JhbGFuY2UiLCJzZXRFc2Nyb3dCYWxhbmNlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxpemVFc2Nyb3ciLCJwbGF5ZXIxV2FsbGV0IiwicGxheWVyMldhbGxldCIsImNvbnNvbGUiLCJsb2ciLCJzaW11bGF0ZWRBZGRyZXNzIiwiRGF0ZSIsIm5vdyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNpbUVycm9yIiwid2luZG93IiwiYWxlcnQiLCJyZXNwb25zZSIsImFwdG9zIiwiY29ubmVjdCIsImFkZHJlc3MiLCJFcnJvciIsImluaXRpYWxpemVFc2Nyb3dSZXN1bHQiLCJ3YXJuIiwibWVzc2FnZSIsImNyZWF0ZVNpbXVsYXRlZEVzY3JvdyIsImNvbm5lY3RFc2Nyb3dXYWxsZXQiLCJsb2NrRXNjcm93IiwicGxheWVyTnVtYmVyIiwicGxheWVyMUJldCIsInBsYXllcjJCZXQiLCJlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkIiwiZ2V0QWNjb3VudEJhbGFuY2UiLCJ0cmFuc2ZlclRvRXNjcm93IiwibWluaW11bUJldCIsIk1hdGgiLCJtaW4iLCJwbGF5ZXJXYWxsZXQiLCJwcmV2QmFsYW5jZSIsImlzV2FsbGV0Q29ubmVjdGVkIiwidHJhbnNmZXJTdWNjZXNzIiwibmV3QmFsYW5jZSIsImVzY3Jvd0JhbGFuY2VSZXN1bHQiLCJib3RoUGxheWVyc0xvY2tlZCIsImZpbmFsUG9vbEFtb3VudCIsIndhc0xvY2tlZCIsInBheVdpbm5lciIsIndpbm5lciIsImZpbmFsQmV0QW1vdW50IiwiZXNjcm93V2FsbGV0Q29ubmVjdGVkIiwicGF5bG9hZDEiLCJ0eXBlIiwiZnVuY3Rpb24iLCJ0eXBlX2FyZ3VtZW50cyIsImFyZ3VtZW50cyIsImZsb29yIiwidG9TdHJpbmciLCJ0eFJlc3BvbnNlMSIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsInBheWxvYWQyIiwidHhSZXNwb25zZTIiLCJ3aW5uZXJXYWxsZXQiLCJwYXlsb2FkIiwidHhSZXNwb25zZSIsInJlc2V0RXNjcm93U3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useEscrow.ts\n"));

/***/ })

});