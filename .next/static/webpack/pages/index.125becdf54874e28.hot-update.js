"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/contracts/EscrowContractAdapter.ts":
/*!************************************************!*\
  !*** ./src/contracts/EscrowContractAdapter.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DisputeResolution: function() { return /* binding */ DisputeResolution; },\n/* harmony export */   EscrowContractAdapter: function() { return /* binding */ EscrowContractAdapter; },\n/* harmony export */   EscrowStatus: function() { return /* binding */ EscrowStatus; }\n/* harmony export */ });\n/* harmony import */ var aptos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aptos */ \"./node_modules/aptos/dist/index.mjs\");\n\nvar EscrowStatus;\n(function(EscrowStatus) {\n    EscrowStatus[EscrowStatus[\"PENDING\"] = 0] = \"PENDING\";\n    EscrowStatus[EscrowStatus[\"FUNDED\"] = 1] = \"FUNDED\";\n    EscrowStatus[EscrowStatus[\"PLAYING\"] = 2] = \"PLAYING\";\n    EscrowStatus[EscrowStatus[\"COMPLETED\"] = 3] = \"COMPLETED\";\n    EscrowStatus[EscrowStatus[\"DISPUTED\"] = 4] = \"DISPUTED\";\n    EscrowStatus[EscrowStatus[\"CANCELLED\"] = 5] = \"CANCELLED\";\n    EscrowStatus[EscrowStatus[\"TIMED_OUT\"] = 6] = \"TIMED_OUT\";\n})(EscrowStatus || (EscrowStatus = {}));\n// Class to interface with the chess escrow contract on Aptos\nclass EscrowContractAdapter {\n    // Set the escrow contract address\n    setEscrowAddress(address) {\n        console.log(\"Setting escrow address to: \".concat(address));\n        this.escrowAddress = address;\n    }\n    // Get the escrow address\n    getEscrowAddress() {\n        return this.escrowAddress;\n    }\n    // Initialize a new escrow contract using any wallet\n    async initializeEscrow(sender, player1Address, player2Address, minimumBet) {\n        let timeoutSeconds = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 24 * 60 * 60;\n        try {\n            // Convert APT to octas (smallest unit) - 1 APT = 10^8 Octas\n            const minimumBetOctas = (minimumBet * 100000000).toString();\n            // Get the wallet address to set as escrow (could be a completely new wallet)\n            let walletAddress;\n            // Try different wallet API styles to get the address\n            if (sender.account) {\n                // Standard Petra wallet\n                const response = await sender.account();\n                walletAddress = response.address;\n            } else if ( true && window.aptos) {\n                // window.aptos API\n                const response = await window.aptos.connect();\n                walletAddress = response.address;\n            } else {\n                throw new Error(\"Could not determine wallet address\");\n            }\n            // Validate the escrow wallet is not the same as player wallets\n            if (walletAddress === player1Address) {\n                throw new Error(\"Escrow wallet cannot be the same as Player 1's wallet\");\n            }\n            if (walletAddress === player2Address) {\n                throw new Error(\"Escrow wallet cannot be the same as Player 2's wallet\");\n            }\n            console.log(\"Using wallet as escrow: \".concat(walletAddress));\n            // Use the moduleAddress as the arbiter for simplicity\n            const arbiterAddress = this.moduleAddress;\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::create_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    player1Address,\n                    player2Address,\n                    minimumBetOctas,\n                    arbiterAddress,\n                    timeoutSeconds.toString()\n                ]\n            };\n            console.log(\"Initializing escrow with payload:\", JSON.stringify(payload, null, 2));\n            const txResponse = await this.submitTransaction(sender, payload);\n            if (txResponse && txResponse.hash) {\n                // Set the escrow address to the wallet address that initialized it\n                this.escrowAddress = walletAddress;\n                console.log(\"Escrow initialized with address: \".concat(walletAddress));\n                console.log(\"Transaction hash: \".concat(txResponse.hash));\n                return walletAddress;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            throw error;\n        }\n    }\n    // Deposit funds into the escrow\n    async deposit(sender, amount) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            // Convert APT to octas\n            const amountInOctas = (amount * 100000000).toString();\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::deposit\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    amountInOctas\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error depositing to escrow:\", error);\n            throw error;\n        }\n    }\n    // Sign to start the game\n    async signToStartGame(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::sign_to_start_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error signing to start game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game with a winner - includes automatic fund release\n    async completeGame(sender, winnerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        console.log(\"Completing game with winner: \".concat(winnerAddress));\n        console.log(\"Using escrow address: \".concat(this.escrowAddress));\n        try {\n            // Verify wallet connection\n            if ( true && window.aptos) {\n                const walletInfo = await window.aptos.connect();\n                console.log(\"Connected wallet for transaction: \".concat(walletInfo.address));\n            }\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::complete_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    winnerAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            // Automatically release funds without requiring approval\n            if (response && response.hash) {\n                console.log(\"Game completed, funds will be automatically transferred to the winner\");\n                console.log(\"Transaction hash:\", response.hash);\n                // Wait for the transaction to be confirmed before releasing funds\n                await this.client.waitForTransactionWithResult(response.hash);\n                try {\n                    await this.releaseFunds(sender);\n                } catch (error) {\n                    console.error(\"Error releasing funds automatically, may need manual release:\", error);\n                }\n            }\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game as a draw - includes automatic fund release\n    async completeGameAsDraw(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        console.log(\"Completing game as draw\");\n        console.log(\"Using escrow address: \".concat(this.escrowAddress));\n        try {\n            // Verify wallet connection\n            if ( true && window.aptos) {\n                const walletInfo = await window.aptos.connect();\n                console.log(\"Connected wallet for transaction: \".concat(walletInfo.address));\n            }\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::complete_game_as_draw\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            // Automatically release funds without requiring approval\n            if (response && response.hash) {\n                console.log(\"Game completed as draw, funds will be automatically returned to players\");\n                console.log(\"Transaction hash:\", response.hash);\n                // Wait for the transaction to be confirmed before releasing funds\n                await this.client.waitForTransactionWithResult(response.hash);\n                try {\n                    await this.releaseFunds(sender);\n                } catch (error) {\n                    console.error(\"Error releasing funds automatically, may need manual release:\", error);\n                }\n            }\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game as draw:\", error);\n            throw error;\n        }\n    }\n    // Release funds to the winner or back to players in case of a draw\n    async releaseFunds(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::release_funds\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            // This transaction doesn't require approval - it's automated\n            const response = await this.submitTransaction(sender, payload);\n            console.log(\"Funds released to the appropriate recipient(s)\");\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error releasing funds:\", error);\n            throw error;\n        }\n    }\n    // Raise a dispute\n    async raiseDispute(sender, reason) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::raise_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    reason\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error raising dispute:\", error);\n            throw error;\n        }\n    }\n    // Resolve a dispute (arbiter only)\n    async resolveDispute(sender, resolution, resolutionNotes) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::resolve_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    resolution.toString(),\n                    resolutionNotes\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error resolving dispute:\", error);\n            throw error;\n        }\n    }\n    // Check if game has timed out\n    async checkTimeout(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::check_timeout\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error checking timeout:\", error);\n            throw error;\n        }\n    }\n    // Cancel the escrow\n    async cancelEscrow(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::cancel_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error cancelling escrow:\", error);\n            throw error;\n        }\n    }\n    // Refund after cancellation\n    async refundAfterCancellation(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::refund_after_cancellation\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error refunding after cancellation:\", error);\n            throw error;\n        }\n    }\n    //\n    // View functions (read-only contract calls)\n    //\n    // Get escrow status\n    async getEscrowStatus() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const resource = await this.client.getAccountResource(this.escrowAddress, \"\".concat(this.moduleAddress, \"::escrow::GameEscrow\"));\n            if (resource && resource.data) {\n                return resource.data.status;\n            }\n            throw new Error(\"Could not retrieve escrow status\");\n        } catch (error) {\n            console.error(\"Error getting escrow status:\", error);\n            throw error;\n        }\n    }\n    // Get winner address\n    async getWinner() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_winner\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<address>\n            // If Some(address), it will be an object with a vector\n            if (result && result.length > 0 && result[0]) {\n                return result[0];\n            }\n            return null; // None case (draw or not set)\n        } catch (error) {\n            console.error(\"Error getting winner:\", error);\n            throw error;\n        }\n    }\n    // Get escrow balance\n    async getEscrowBalance() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_escrow_balance\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting escrow balance:\", error);\n            throw error;\n        }\n    }\n    // Check if both deposits are complete\n    async areBothDepositsComplete() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::are_both_deposits_complete\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                return Boolean(result[0]);\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error checking deposits completion:\", error);\n            throw error;\n        }\n    }\n    // Get minimum bet\n    async getMinimumBet() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_minimum_bet\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting minimum bet:\", error);\n            throw error;\n        }\n    }\n    // Get player info\n    async getPlayerInfo(playerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_player_info\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    playerAddress\n                ]\n            });\n            if (result && result.length >= 3) {\n                return {\n                    hasDeposited: Boolean(result[0]),\n                    depositAmount: Number(result[1]) / 100000000,\n                    signedGameStart: Boolean(result[2])\n                };\n            }\n            throw new Error(\"Invalid player info result\");\n        } catch (error) {\n            console.error(\"Error getting player info:\", error);\n            throw error;\n        }\n    }\n    // Get total escrowed amount\n    async getTotalEscrowedAmount() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_total_escrowed_amount\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting total escrowed amount:\", error);\n            throw error;\n        }\n    }\n    // Get game time remaining\n    async getGameTimeRemaining() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_game_time_remaining\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<u64>\n            if (result && result.length > 0 && result[0]) {\n                return Number(result[0]);\n            }\n            return null; // None case (game not started or not in playing state)\n        } catch (error) {\n            console.error(\"Error getting game time remaining:\", error);\n            throw error;\n        }\n    }\n    // Helper method to submit a transaction\n    async submitTransaction(sender, payload) {\n        try {\n            // For direct wallet API (window.aptos) - try this first\n            if ( true && window.aptos) {\n                console.log(\"Using window.aptos wallet for transaction\");\n                return await window.aptos.signAndSubmitTransaction(payload);\n            }\n            // For Petra and similar wallets\n            if (sender && sender.signAndSubmitTransaction) {\n                console.log(\"Using provided wallet for transaction\");\n                return await sender.signAndSubmitTransaction(payload);\n            }\n            // If we get here, no compatible wallet was found\n            console.error(\"No compatible wallet found for transaction\");\n            throw new Error(\"No compatible wallet found\");\n        } catch (error) {\n            console.error(\"Transaction error:\", error);\n            throw error;\n        }\n    }\n    constructor(nodeUrl, moduleAddress){\n        this.escrowAddress = null;\n        this.client = new aptos__WEBPACK_IMPORTED_MODULE_0__.AptosClient(nodeUrl);\n        this.moduleAddress = moduleAddress;\n        // No longer setting escrow address to module address by default\n        console.log(\"Adapter created with module address:\", moduleAddress);\n    }\n}\nvar DisputeResolution;\n(function(DisputeResolution) {\n    DisputeResolution[DisputeResolution[\"DRAW\"] = 0] = \"DRAW\";\n    DisputeResolution[DisputeResolution[\"PLAYER1_WINS\"] = 1] = \"PLAYER1_WINS\";\n    DisputeResolution[DisputeResolution[\"PLAYER2_WINS\"] = 2] = \"PLAYER2_WINS\";\n    DisputeResolution[DisputeResolution[\"CANCEL\"] = 3] = \"CANCEL\";\n})(DisputeResolution || (DisputeResolution = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b25CRjs7VUFHWXVEOzs7OztHQUFBQSxzQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRyYWN0cy9Fc2Nyb3dDb250cmFjdEFkYXB0ZXIudHM/MTI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHRvc0NsaWVudCwgVHlwZXMsIFR4bkJ1aWxkZXJUeXBlcywgQkNTIH0gZnJvbSAnYXB0b3MnO1xuXG4vLyBFbnVtIGZvciBjb250cmFjdCBzdGF0ZXMgbWF0Y2hpbmcgdGhlIE1vdmUgY29udHJhY3RcbmV4cG9ydCBlbnVtIEVzY3Jvd1N0YXR1cyB7XG4gIFBFTkRJTkcgPSAwLFxuICBGVU5ERUQgPSAxLFxuICBQTEFZSU5HID0gMixcbiAgQ09NUExFVEVEID0gMyxcbiAgRElTUFVURUQgPSA0LFxuICBDQU5DRUxMRUQgPSA1LFxuICBUSU1FRF9PVVQgPSA2XG59XG5cbi8vIENsYXNzIHRvIGludGVyZmFjZSB3aXRoIHRoZSBjaGVzcyBlc2Nyb3cgY29udHJhY3Qgb24gQXB0b3NcbmV4cG9ydCBjbGFzcyBFc2Nyb3dDb250cmFjdEFkYXB0ZXIge1xuICBwcml2YXRlIGNsaWVudDogQXB0b3NDbGllbnQ7XG4gIHByaXZhdGUgbW9kdWxlQWRkcmVzczogc3RyaW5nO1xuICBwcml2YXRlIGVzY3Jvd0FkZHJlc3M6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgbm9kZVVybDogc3RyaW5nLFxuICAgIG1vZHVsZUFkZHJlc3M6IHN0cmluZywgLy8gUmVtb3ZlZCBkZWZhdWx0IHZhbHVlIC0gbXVzdCBiZSBwcm92aWRlZCBleHBsaWNpdGx5XG4gICkge1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IEFwdG9zQ2xpZW50KG5vZGVVcmwpO1xuICAgIHRoaXMubW9kdWxlQWRkcmVzcyA9IG1vZHVsZUFkZHJlc3M7XG4gICAgLy8gTm8gbG9uZ2VyIHNldHRpbmcgZXNjcm93IGFkZHJlc3MgdG8gbW9kdWxlIGFkZHJlc3MgYnkgZGVmYXVsdFxuICAgIGNvbnNvbGUubG9nKFwiQWRhcHRlciBjcmVhdGVkIHdpdGggbW9kdWxlIGFkZHJlc3M6XCIsIG1vZHVsZUFkZHJlc3MpO1xuICB9XG4gIFxuICAvLyBTZXQgdGhlIGVzY3JvdyBjb250cmFjdCBhZGRyZXNzXG4gIHB1YmxpYyBzZXRFc2Nyb3dBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGVzY3JvdyBhZGRyZXNzIHRvOiAke2FkZHJlc3N9YCk7XG4gICAgdGhpcy5lc2Nyb3dBZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBcbiAgLy8gR2V0IHRoZSBlc2Nyb3cgYWRkcmVzc1xuICBwdWJsaWMgZ2V0RXNjcm93QWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5lc2Nyb3dBZGRyZXNzO1xuICB9XG4gIFxuICAvLyBJbml0aWFsaXplIGEgbmV3IGVzY3JvdyBjb250cmFjdCB1c2luZyBhbnkgd2FsbGV0XG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplRXNjcm93KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICBwbGF5ZXIxQWRkcmVzczogc3RyaW5nLFxuICAgIHBsYXllcjJBZGRyZXNzOiBzdHJpbmcsXG4gICAgbWluaW11bUJldDogbnVtYmVyLFxuICAgIHRpbWVvdXRTZWNvbmRzOiBudW1iZXIgPSAyNCAqIDYwICogNjAsIC8vIDI0IGhvdXJzIGluIHNlY29uZHNcbiAgKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgQVBUIHRvIG9jdGFzIChzbWFsbGVzdCB1bml0KSAtIDEgQVBUID0gMTBeOCBPY3Rhc1xuICAgICAgY29uc3QgbWluaW11bUJldE9jdGFzID0gKG1pbmltdW1CZXQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgd2FsbGV0IGFkZHJlc3MgdG8gc2V0IGFzIGVzY3JvdyAoY291bGQgYmUgYSBjb21wbGV0ZWx5IG5ldyB3YWxsZXQpXG4gICAgICBsZXQgd2FsbGV0QWRkcmVzcztcbiAgICAgIFxuICAgICAgLy8gVHJ5IGRpZmZlcmVudCB3YWxsZXQgQVBJIHN0eWxlcyB0byBnZXQgdGhlIGFkZHJlc3NcbiAgICAgIGlmIChzZW5kZXIuYWNjb3VudCkge1xuICAgICAgICAvLyBTdGFuZGFyZCBQZXRyYSB3YWxsZXRcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZW5kZXIuYWNjb3VudCgpO1xuICAgICAgICB3YWxsZXRBZGRyZXNzID0gcmVzcG9uc2UuYWRkcmVzcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFwdG9zKSB7XG4gICAgICAgIC8vIHdpbmRvdy5hcHRvcyBBUElcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICB3YWxsZXRBZGRyZXNzID0gcmVzcG9uc2UuYWRkcmVzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgd2FsbGV0IGFkZHJlc3NcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBlc2Nyb3cgd2FsbGV0IGlzIG5vdCB0aGUgc2FtZSBhcyBwbGF5ZXIgd2FsbGV0c1xuICAgICAgaWYgKHdhbGxldEFkZHJlc3MgPT09IHBsYXllcjFBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyB3YWxsZXQgY2Fubm90IGJlIHRoZSBzYW1lIGFzIFBsYXllciAxJ3Mgd2FsbGV0XCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAod2FsbGV0QWRkcmVzcyA9PT0gcGxheWVyMkFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IHdhbGxldCBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgUGxheWVyIDIncyB3YWxsZXRcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB3YWxsZXQgYXMgZXNjcm93OiAke3dhbGxldEFkZHJlc3N9YCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgbW9kdWxlQWRkcmVzcyBhcyB0aGUgYXJiaXRlciBmb3Igc2ltcGxpY2l0eVxuICAgICAgY29uc3QgYXJiaXRlckFkZHJlc3MgPSB0aGlzLm1vZHVsZUFkZHJlc3M7XG4gICAgICBcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6Y2hlc3NfZXNjcm93OjpjcmVhdGVfZXNjcm93YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICBwbGF5ZXIxQWRkcmVzcyxcbiAgICAgICAgICBwbGF5ZXIyQWRkcmVzcyxcbiAgICAgICAgICBtaW5pbXVtQmV0T2N0YXMsXG4gICAgICAgICAgYXJiaXRlckFkZHJlc3MsXG4gICAgICAgICAgdGltZW91dFNlY29uZHMudG9TdHJpbmcoKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBlc2Nyb3cgd2l0aCBwYXlsb2FkOlwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkLCBudWxsLCAyKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHR4UmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGlmICh0eFJlc3BvbnNlICYmIHR4UmVzcG9uc2UuaGFzaCkge1xuICAgICAgICAvLyBTZXQgdGhlIGVzY3JvdyBhZGRyZXNzIHRvIHRoZSB3YWxsZXQgYWRkcmVzcyB0aGF0IGluaXRpYWxpemVkIGl0XG4gICAgICAgIHRoaXMuZXNjcm93QWRkcmVzcyA9IHdhbGxldEFkZHJlc3M7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFc2Nyb3cgaW5pdGlhbGl6ZWQgd2l0aCBhZGRyZXNzOiAke3dhbGxldEFkZHJlc3N9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcmFuc2FjdGlvbiBoYXNoOiAke3R4UmVzcG9uc2UuaGFzaH1gKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldEFkZHJlc3M7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBEZXBvc2l0IGZ1bmRzIGludG8gdGhlIGVzY3Jvd1xuICBwdWJsaWMgYXN5bmMgZGVwb3NpdChcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCBBUFQgdG8gb2N0YXNcbiAgICAgIGNvbnN0IGFtb3VudEluT2N0YXMgPSAoYW1vdW50ICogMTAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6ZGVwb3NpdGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzLCBhbW91bnRJbk9jdGFzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlcG9zaXRpbmcgdG8gZXNjcm93OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNpZ24gdG8gc3RhcnQgdGhlIGdhbWVcbiAgcHVibGljIGFzeW5jIHNpZ25Ub1N0YXJ0R2FtZShcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnNpZ25fdG9fc3RhcnRfZ2FtZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNpZ25pbmcgdG8gc3RhcnQgZ2FtZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDb21wbGV0ZSB0aGUgZ2FtZSB3aXRoIGEgd2lubmVyIC0gaW5jbHVkZXMgYXV0b21hdGljIGZ1bmQgcmVsZWFzZVxuICBwdWJsaWMgYXN5bmMgY29tcGxldGVHYW1lKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICB3aW5uZXJBZGRyZXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ29tcGxldGluZyBnYW1lIHdpdGggd2lubmVyOiAke3dpbm5lckFkZHJlc3N9YCk7XG4gICAgY29uc29sZS5sb2coYFVzaW5nIGVzY3JvdyBhZGRyZXNzOiAke3RoaXMuZXNjcm93QWRkcmVzc31gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZ5IHdhbGxldCBjb25uZWN0aW9uXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFwdG9zKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldEluZm8gPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHdhbGxldCBmb3IgdHJhbnNhY3Rpb246ICR7d2FsbGV0SW5mby5hZGRyZXNzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Y29tcGxldGVfZ2FtZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzLCB3aW5uZXJBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVsZWFzZSBmdW5kcyB3aXRob3V0IHJlcXVpcmluZyBhcHByb3ZhbFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIGNvbXBsZXRlZCwgZnVuZHMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZmVycmVkIHRvIHRoZSB3aW5uZXJcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNhY3Rpb24gaGFzaDpcIiwgcmVzcG9uc2UuaGFzaCk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkIGJlZm9yZSByZWxlYXNpbmcgZnVuZHNcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQud2FpdEZvclRyYW5zYWN0aW9uV2l0aFJlc3VsdChyZXNwb25zZS5oYXNoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlbGVhc2VGdW5kcyhzZW5kZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWxlYXNpbmcgZnVuZHMgYXV0b21hdGljYWxseSwgbWF5IG5lZWQgbWFudWFsIHJlbGVhc2U6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wbGV0aW5nIGdhbWU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ29tcGxldGUgdGhlIGdhbWUgYXMgYSBkcmF3IC0gaW5jbHVkZXMgYXV0b21hdGljIGZ1bmQgcmVsZWFzZVxuICBwdWJsaWMgYXN5bmMgY29tcGxldGVHYW1lQXNEcmF3KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDb21wbGV0aW5nIGdhbWUgYXMgZHJhd2ApO1xuICAgIGNvbnNvbGUubG9nKGBVc2luZyBlc2Nyb3cgYWRkcmVzczogJHt0aGlzLmVzY3Jvd0FkZHJlc3N9YCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFZlcmlmeSB3YWxsZXQgY29ubmVjdGlvblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hcHRvcykge1xuICAgICAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgY29uc29sZS5sb2coYENvbm5lY3RlZCB3YWxsZXQgZm9yIHRyYW5zYWN0aW9uOiAke3dhbGxldEluZm8uYWRkcmVzc31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmNvbXBsZXRlX2dhbWVfYXNfZHJhd2AsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVsZWFzZSBmdW5kcyB3aXRob3V0IHJlcXVpcmluZyBhcHByb3ZhbFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIGNvbXBsZXRlZCBhcyBkcmF3LCBmdW5kcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmV0dXJuZWQgdG8gcGxheWVyc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvbiBoYXNoOlwiLCByZXNwb25zZS5oYXNoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWQgYmVmb3JlIHJlbGVhc2luZyBmdW5kc1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25XaXRoUmVzdWx0KHJlc3BvbnNlLmhhc2gpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVsZWFzZUZ1bmRzKHNlbmRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlbGVhc2luZyBmdW5kcyBhdXRvbWF0aWNhbGx5LCBtYXkgbmVlZCBtYW51YWwgcmVsZWFzZTpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbXBsZXRpbmcgZ2FtZSBhcyBkcmF3OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFJlbGVhc2UgZnVuZHMgdG8gdGhlIHdpbm5lciBvciBiYWNrIHRvIHBsYXllcnMgaW4gY2FzZSBvZiBhIGRyYXdcbiAgcHVibGljIGFzeW5jIHJlbGVhc2VGdW5kcyhcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnJlbGVhc2VfZnVuZHNgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCByZXF1aXJlIGFwcHJvdmFsIC0gaXQncyBhdXRvbWF0ZWRcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgY29uc29sZS5sb2coXCJGdW5kcyByZWxlYXNlZCB0byB0aGUgYXBwcm9wcmlhdGUgcmVjaXBpZW50KHMpXCIpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWxlYXNpbmcgZnVuZHM6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmFpc2UgYSBkaXNwdXRlXG4gIHB1YmxpYyBhc3luYyByYWlzZURpc3B1dGUoXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHJlYXNvbjogc3RyaW5nLFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6ZXNjcm93OjpyYWlzZV9kaXNwdXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHJlYXNvbl1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByYWlzaW5nIGRpc3B1dGU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVzb2x2ZSBhIGRpc3B1dGUgKGFyYml0ZXIgb25seSlcbiAgcHVibGljIGFzeW5jIHJlc29sdmVEaXNwdXRlKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2UgKGFyYml0ZXIpXG4gICAgcmVzb2x1dGlvbjogbnVtYmVyLCAvLyAwPWRyYXcsIDE9cGxheWVyMSB3aW5zLCAyPXBsYXllcjIgd2lucywgMz1jYW5jZWxcbiAgICByZXNvbHV0aW9uTm90ZXM6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6cmVzb2x2ZV9kaXNwdXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHJlc29sdXRpb24udG9TdHJpbmcoKSwgcmVzb2x1dGlvbk5vdGVzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlc29sdmluZyBkaXNwdXRlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGlmIGdhbWUgaGFzIHRpbWVkIG91dFxuICBwdWJsaWMgYXN5bmMgY2hlY2tUaW1lb3V0KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Y2hlY2tfdGltZW91dGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIHRpbWVvdXQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FuY2VsIHRoZSBlc2Nyb3dcbiAgcHVibGljIGFzeW5jIGNhbmNlbEVzY3JvdyhcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmNhbmNlbF9lc2Nyb3dgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYW5jZWxsaW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZWZ1bmQgYWZ0ZXIgY2FuY2VsbGF0aW9uXG4gIHB1YmxpYyBhc3luYyByZWZ1bmRBZnRlckNhbmNlbGxhdGlvbihcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnJlZnVuZF9hZnRlcl9jYW5jZWxsYXRpb25gLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWZ1bmRpbmcgYWZ0ZXIgY2FuY2VsbGF0aW9uOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vXG4gIC8vIFZpZXcgZnVuY3Rpb25zIChyZWFkLW9ubHkgY29udHJhY3QgY2FsbHMpXG4gIC8vXG4gIFxuICAvLyBHZXQgZXNjcm93IHN0YXR1c1xuICBwdWJsaWMgYXN5bmMgZ2V0RXNjcm93U3RhdHVzKCk6IFByb21pc2U8RXNjcm93U3RhdHVzPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IGF3YWl0IHRoaXMuY2xpZW50LmdldEFjY291bnRSZXNvdXJjZShcbiAgICAgICAgdGhpcy5lc2Nyb3dBZGRyZXNzLFxuICAgICAgICBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OkdhbWVFc2Nyb3dgXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAocmVzb3VyY2UgJiYgcmVzb3VyY2UuZGF0YSkge1xuICAgICAgICByZXR1cm4gKHJlc291cmNlLmRhdGEgYXMgYW55KS5zdGF0dXMgYXMgRXNjcm93U3RhdHVzO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmV0cmlldmUgZXNjcm93IHN0YXR1c1wiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZXNjcm93IHN0YXR1czpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgd2lubmVyIGFkZHJlc3NcbiAgcHVibGljIGFzeW5jIGdldFdpbm5lcigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnZpZXcoe1xuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6ZXNjcm93OjpnZXRfd2lubmVyYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IHdpdGggdGhlIE9wdGlvbjxhZGRyZXNzPlxuICAgICAgLy8gSWYgU29tZShhZGRyZXNzKSwgaXQgd2lsbCBiZSBhbiBvYmplY3Qgd2l0aCBhIHZlY3RvclxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXSBhcyBzdHJpbmc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsOyAvLyBOb25lIGNhc2UgKGRyYXcgb3Igbm90IHNldClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgd2lubmVyOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEdldCBlc2Nyb3cgYmFsYW5jZVxuICBwdWJsaWMgYXN5bmMgZ2V0RXNjcm93QmFsYW5jZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF9lc2Nyb3dfYmFsYW5jZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHRbMF0pIC8gMTAwMDAwMDAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZXNjcm93IGJhbGFuY2U6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgYm90aCBkZXBvc2l0cyBhcmUgY29tcGxldGVcbiAgcHVibGljIGFzeW5jIGFyZUJvdGhEZXBvc2l0c0NvbXBsZXRlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmFyZV9ib3RoX2RlcG9zaXRzX2NvbXBsZXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihyZXN1bHRbMF0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBkZXBvc2l0cyBjb21wbGV0aW9uOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEdldCBtaW5pbXVtIGJldFxuICBwdWJsaWMgYXN5bmMgZ2V0TWluaW11bUJldCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF9taW5pbXVtX2JldGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHRbMF0pIC8gMTAwMDAwMDAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgbWluaW11bSBiZXQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHBsYXllciBpbmZvXG4gIHB1YmxpYyBhc3luYyBnZXRQbGF5ZXJJbmZvKHBsYXllckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGhhc0RlcG9zaXRlZDogYm9vbGVhbjtcbiAgICBkZXBvc2l0QW1vdW50OiBudW1iZXI7XG4gICAgc2lnbmVkR2FtZVN0YXJ0OiBib29sZWFuO1xuICB9PiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Z2V0X3BsYXllcl9pbmZvYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHBsYXllckFkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNEZXBvc2l0ZWQ6IEJvb2xlYW4ocmVzdWx0WzBdKSxcbiAgICAgICAgICBkZXBvc2l0QW1vdW50OiBOdW1iZXIocmVzdWx0WzFdKSAvIDEwMDAwMDAwMCwgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgICBzaWduZWRHYW1lU3RhcnQ6IEJvb2xlYW4ocmVzdWx0WzJdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBsYXllciBpbmZvIHJlc3VsdFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgcGxheWVyIGluZm86XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHRvdGFsIGVzY3Jvd2VkIGFtb3VudFxuICBwdWJsaWMgYXN5bmMgZ2V0VG90YWxFc2Nyb3dlZEFtb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF90b3RhbF9lc2Nyb3dlZF9hbW91bnRgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIENvbnZlcnQgb2N0YXMgdG8gQVBUXG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0WzBdKSAvIDEwMDAwMDAwMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHRvdGFsIGVzY3Jvd2VkIGFtb3VudDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgZ2FtZSB0aW1lIHJlbWFpbmluZ1xuICBwdWJsaWMgYXN5bmMgZ2V0R2FtZVRpbWVSZW1haW5pbmcoKTogUHJvbWlzZTxudW1iZXIgfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Z2V0X2dhbWVfdGltZV9yZW1haW5pbmdgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgd2l0aCB0aGUgT3B0aW9uPHU2ND5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0WzBdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vbmUgY2FzZSAoZ2FtZSBub3Qgc3RhcnRlZCBvciBub3QgaW4gcGxheWluZyBzdGF0ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZ2FtZSB0aW1lIHJlbWFpbmluZzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIHN1Ym1pdCBhIHRyYW5zYWN0aW9uXG4gIHByaXZhdGUgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24oXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHBheWxvYWQ6IGFueVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3IgZGlyZWN0IHdhbGxldCBBUEkgKHdpbmRvdy5hcHRvcykgLSB0cnkgdGhpcyBmaXJzdFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hcHRvcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHdpbmRvdy5hcHRvcyB3YWxsZXQgZm9yIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIFBldHJhIGFuZCBzaW1pbGFyIHdhbGxldHNcbiAgICAgIGlmIChzZW5kZXIgJiYgc2VuZGVyLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHByb3ZpZGVkIHdhbGxldCBmb3IgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kZXIuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgbm8gY29tcGF0aWJsZSB3YWxsZXQgd2FzIGZvdW5kXG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gY29tcGF0aWJsZSB3YWxsZXQgZm91bmQgZm9yIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tcGF0aWJsZSB3YWxsZXQgZm91bmRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcmFuc2FjdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBhbiBlbnVtIGZvciBkaXNwdXRlIHJlc29sdXRpb24gY29kZXNcbmV4cG9ydCBlbnVtIERpc3B1dGVSZXNvbHV0aW9uIHtcbiAgRFJBVyA9IDAsXG4gIFBMQVlFUjFfV0lOUyA9IDEsXG4gIFBMQVlFUjJfV0lOUyA9IDIsXG4gIENBTkNFTCA9IDNcbn0gIl0sIm5hbWVzIjpbIkFwdG9zQ2xpZW50IiwiRXNjcm93U3RhdHVzIiwiRXNjcm93Q29udHJhY3RBZGFwdGVyIiwic2V0RXNjcm93QWRkcmVzcyIsImFkZHJlc3MiLCJjb25zb2xlIiwibG9nIiwiZXNjcm93QWRkcmVzcyIsImdldEVzY3Jvd0FkZHJlc3MiLCJpbml0aWFsaXplRXNjcm93Iiwic2VuZGVyIiwicGxheWVyMUFkZHJlc3MiLCJwbGF5ZXIyQWRkcmVzcyIsIm1pbmltdW1CZXQiLCJ0aW1lb3V0U2Vjb25kcyIsIm1pbmltdW1CZXRPY3RhcyIsInRvU3RyaW5nIiwid2FsbGV0QWRkcmVzcyIsImFjY291bnQiLCJyZXNwb25zZSIsIndpbmRvdyIsImFwdG9zIiwiY29ubmVjdCIsIkVycm9yIiwiYXJiaXRlckFkZHJlc3MiLCJtb2R1bGVBZGRyZXNzIiwicGF5bG9hZCIsInR5cGUiLCJmdW5jdGlvbiIsInR5cGVfYXJndW1lbnRzIiwiYXJndW1lbnRzIiwiSlNPTiIsInN0cmluZ2lmeSIsInR4UmVzcG9uc2UiLCJzdWJtaXRUcmFuc2FjdGlvbiIsImhhc2giLCJlcnJvciIsImRlcG9zaXQiLCJhbW91bnQiLCJhbW91bnRJbk9jdGFzIiwic2lnblRvU3RhcnRHYW1lIiwiY29tcGxldGVHYW1lIiwid2lubmVyQWRkcmVzcyIsIndhbGxldEluZm8iLCJjbGllbnQiLCJ3YWl0Rm9yVHJhbnNhY3Rpb25XaXRoUmVzdWx0IiwicmVsZWFzZUZ1bmRzIiwiY29tcGxldGVHYW1lQXNEcmF3IiwicmFpc2VEaXNwdXRlIiwicmVhc29uIiwicmVzb2x2ZURpc3B1dGUiLCJyZXNvbHV0aW9uIiwicmVzb2x1dGlvbk5vdGVzIiwiY2hlY2tUaW1lb3V0IiwiY2FuY2VsRXNjcm93IiwicmVmdW5kQWZ0ZXJDYW5jZWxsYXRpb24iLCJnZXRFc2Nyb3dTdGF0dXMiLCJyZXNvdXJjZSIsImdldEFjY291bnRSZXNvdXJjZSIsImRhdGEiLCJzdGF0dXMiLCJnZXRXaW5uZXIiLCJyZXN1bHQiLCJ2aWV3IiwibGVuZ3RoIiwiZ2V0RXNjcm93QmFsYW5jZSIsIk51bWJlciIsImFyZUJvdGhEZXBvc2l0c0NvbXBsZXRlIiwiQm9vbGVhbiIsImdldE1pbmltdW1CZXQiLCJnZXRQbGF5ZXJJbmZvIiwicGxheWVyQWRkcmVzcyIsImhhc0RlcG9zaXRlZCIsImRlcG9zaXRBbW91bnQiLCJzaWduZWRHYW1lU3RhcnQiLCJnZXRUb3RhbEVzY3Jvd2VkQW1vdW50IiwiZ2V0R2FtZVRpbWVSZW1haW5pbmciLCJzaWduQW5kU3VibWl0VHJhbnNhY3Rpb24iLCJjb25zdHJ1Y3RvciIsIm5vZGVVcmwiLCJEaXNwdXRlUmVzb2x1dGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contracts/EscrowContractAdapter.ts\n"));

/***/ })

});