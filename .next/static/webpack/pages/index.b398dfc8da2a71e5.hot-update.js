/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: function() { return /* binding */ BISHOP; },\n/* harmony export */   BLACK: function() { return /* binding */ BLACK; },\n/* harmony export */   Chess: function() { return /* binding */ Chess; },\n/* harmony export */   DEFAULT_POSITION: function() { return /* binding */ DEFAULT_POSITION; },\n/* harmony export */   KING: function() { return /* binding */ KING; },\n/* harmony export */   KNIGHT: function() { return /* binding */ KNIGHT; },\n/* harmony export */   Move: function() { return /* binding */ Move; },\n/* harmony export */   PAWN: function() { return /* binding */ PAWN; },\n/* harmony export */   QUEEN: function() { return /* binding */ QUEEN; },\n/* harmony export */   ROOK: function() { return /* binding */ ROOK; },\n/* harmony export */   SQUARES: function() { return /* binding */ SQUARES; },\n/* harmony export */   WHITE: function() { return /* binding */ WHITE; },\n/* harmony export */   validateFen: function() { return /* binding */ validateFen; }\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : {};\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        delete this._header['SetUp'];\n        delete this._header['FEN'];\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === KING &&\n            this._board[Ox88.e1]?.color === WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === KING &&\n            this._board[Ox88.e8]?.color === BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== ROOK ||\n            this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== ROOK ||\n            this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== ROOK ||\n            this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== ROOK ||\n            this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if ((difference > 0 && piece.color === WHITE) ||\n                        (difference <= 0 && piece.color === BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /*\n     * @deprecated Use `setHeader` and `getHeaders` instead.\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    setHeader(key, value) {\n        this._header[key] = value;\n        return this._header;\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n            return true;\n        }\n        return false;\n    }\n    getHeaders() {\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[KING] === undefined || rights[KING] === result[KING]) &&\n            (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BELFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QyxVQUFVLDZCQUE2QjtBQUN2QztBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0EscUJBQXFCLDBDQUEwQyxPQUFPO0FBQ3RFO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QixJQUFJO0FBQ3ZFLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQSxZQUFZLDBCQUEwQixJQUFJO0FBQzFDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0QsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0Qyx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGVzcy5qcy9kaXN0L2VzbS9jaGVzcy5qcz8zMmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyNSwgSmVmZiBIbHl3YSAoamhseXdhQGdtYWlsLmNvbSlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5leHBvcnQgY29uc3QgV0hJVEUgPSAndyc7XG5leHBvcnQgY29uc3QgQkxBQ0sgPSAnYic7XG5leHBvcnQgY29uc3QgUEFXTiA9ICdwJztcbmV4cG9ydCBjb25zdCBLTklHSFQgPSAnbic7XG5leHBvcnQgY29uc3QgQklTSE9QID0gJ2InO1xuZXhwb3J0IGNvbnN0IFJPT0sgPSAncic7XG5leHBvcnQgY29uc3QgUVVFRU4gPSAncSc7XG5leHBvcnQgY29uc3QgS0lORyA9ICdrJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPU0lUSU9OID0gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxJztcbmV4cG9ydCBjbGFzcyBNb3ZlIHtcbiAgICBjb2xvcjtcbiAgICBmcm9tO1xuICAgIHRvO1xuICAgIHBpZWNlO1xuICAgIGNhcHR1cmVkO1xuICAgIHByb21vdGlvbjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZpZWxkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4wLlxuICAgICAqIFBsZWFzZSB1c2UgbW92ZSBkZXNjcmlwdG9yIGZ1bmN0aW9ucyBpbnN0ZWFkOiBgaXNDYXB0dXJlYCwgYGlzUHJvbW90aW9uYCxcbiAgICAgKiBgaXNFblBhc3NhbnRgLCBgaXNLaW5nc2lkZUNhc3RsZWAsIGBpc1F1ZWVuc2lkZUNhc3RsZWAsIGBpc0Nhc3RsZWAsIGFuZFxuICAgICAqIGBpc0JpZ1Bhd25gXG4gICAgICovXG4gICAgZmxhZ3M7XG4gICAgc2FuO1xuICAgIGxhbjtcbiAgICBiZWZvcmU7XG4gICAgYWZ0ZXI7XG4gICAgY29uc3RydWN0b3IoY2hlc3MsIGludGVybmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IGludGVybmFsO1xuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5waWVjZSA9IHBpZWNlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tQWxnZWJyYWljO1xuICAgICAgICB0aGlzLnRvID0gdG9BbGdlYnJhaWM7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEhBQ0s6IFRoZSBjaGVzc1snX21ldGhvZCddKCkgY2FsbHMgYmVsb3cgaW52b2tlIHByaXZhdGUgbWV0aG9kcyBpbiB0aGVcbiAgICAgICAgICogQ2hlc3MgY2xhc3MgdG8gZ2VuZXJhdGUgU0FOIGFuZCBGRU4uIEl0J3MgYSBiaXQgb2YgYSBoYWNrLCBidXQgbWFrZXMgdGhlXG4gICAgICAgICAqIGNvZGUgY2xlYW5lciBlbHNld2hlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNhbiA9IGNoZXNzWydfbW92ZVRvU2FuJ10oaW50ZXJuYWwsIGNoZXNzWydfbW92ZXMnXSh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sYW4gPSBmcm9tQWxnZWJyYWljICsgdG9BbGdlYnJhaWM7XG4gICAgICAgIHRoaXMuYmVmb3JlID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBGRU4gZm9yIHRoZSAnYWZ0ZXInIGtleVxuICAgICAgICBjaGVzc1snX21ha2VNb3ZlJ10oaW50ZXJuYWwpO1xuICAgICAgICB0aGlzLmFmdGVyID0gY2hlc3MuZmVuKCk7XG4gICAgICAgIGNoZXNzWydfdW5kb01vdmUnXSgpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbW92ZSBmbGFnc1xuICAgICAgICB0aGlzLmZsYWdzID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZmxhZyBpbiBCSVRTKSB7XG4gICAgICAgICAgICBpZiAoQklUU1tmbGFnXSAmIGZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZWQgPSBjYXB0dXJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbW90aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGlvbiA9IHByb21vdGlvbjtcbiAgICAgICAgICAgIHRoaXMubGFuICs9IHByb21vdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NhcHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0NBUFRVUkUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNQcm9tb3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1BST01PVElPTiddKSA+IC0xO1xuICAgIH1cbiAgICBpc0VuUGFzc2FudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MuaW5kZXhPZihGTEFHU1snRVBfQ0FQVFVSRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0tpbmdzaWRlQ2FzdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncy5pbmRleE9mKEZMQUdTWydLU0lERV9DQVNUTEUnXSkgPiAtMTtcbiAgICB9XG4gICAgaXNRdWVlbnNpZGVDYXN0bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ1FTSURFX0NBU1RMRSddKSA+IC0xO1xuICAgIH1cbiAgICBpc0JpZ1Bhd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdzLmluZGV4T2YoRkxBR1NbJ0JJR19QQVdOJ10pID4gLTE7XG4gICAgfVxufVxuY29uc3QgRU1QVFkgPSAtMTtcbmNvbnN0IEZMQUdTID0ge1xuICAgIE5PUk1BTDogJ24nLFxuICAgIENBUFRVUkU6ICdjJyxcbiAgICBCSUdfUEFXTjogJ2InLFxuICAgIEVQX0NBUFRVUkU6ICdlJyxcbiAgICBQUk9NT1RJT046ICdwJyxcbiAgICBLU0lERV9DQVNUTEU6ICdrJyxcbiAgICBRU0lERV9DQVNUTEU6ICdxJyxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBTUVVBUkVTID0gW1xuICAgICdhOCcsICdiOCcsICdjOCcsICdkOCcsICdlOCcsICdmOCcsICdnOCcsICdoOCcsXG4gICAgJ2E3JywgJ2I3JywgJ2M3JywgJ2Q3JywgJ2U3JywgJ2Y3JywgJ2c3JywgJ2g3JyxcbiAgICAnYTYnLCAnYjYnLCAnYzYnLCAnZDYnLCAnZTYnLCAnZjYnLCAnZzYnLCAnaDYnLFxuICAgICdhNScsICdiNScsICdjNScsICdkNScsICdlNScsICdmNScsICdnNScsICdoNScsXG4gICAgJ2E0JywgJ2I0JywgJ2M0JywgJ2Q0JywgJ2U0JywgJ2Y0JywgJ2c0JywgJ2g0JyxcbiAgICAnYTMnLCAnYjMnLCAnYzMnLCAnZDMnLCAnZTMnLCAnZjMnLCAnZzMnLCAnaDMnLFxuICAgICdhMicsICdiMicsICdjMicsICdkMicsICdlMicsICdmMicsICdnMicsICdoMicsXG4gICAgJ2ExJywgJ2IxJywgJ2MxJywgJ2QxJywgJ2UxJywgJ2YxJywgJ2cxJywgJ2gxJ1xuXTtcbmNvbnN0IEJJVFMgPSB7XG4gICAgTk9STUFMOiAxLFxuICAgIENBUFRVUkU6IDIsXG4gICAgQklHX1BBV046IDQsXG4gICAgRVBfQ0FQVFVSRTogOCxcbiAgICBQUk9NT1RJT046IDE2LFxuICAgIEtTSURFX0NBU1RMRTogMzIsXG4gICAgUVNJREVfQ0FTVExFOiA2NCxcbn07XG4vKlxuICogTk9URVMgQUJPVVQgMHg4OCBNT1ZFIEdFTkVSQVRJT04gQUxHT1JJVEhNXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGx5d2EvY2hlc3MuanMvaXNzdWVzLzIzMFxuICpcbiAqIEEgbG90IG9mIHBlb3BsZSBhcmUgY29uZnVzZWQgd2hlbiB0aGV5IGZpcnN0IHNlZSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAqIG9mIGNoZXNzLmpzLiBJdCB1c2VzIHRoZSAweDg4IE1vdmUgR2VuZXJhdGlvbiBBbGdvcml0aG0gd2hpY2ggaW50ZXJuYWxseVxuICogc3RvcmVzIHRoZSBib2FyZCBhcyBhbiA4eDE2IGFycmF5LiBUaGlzIGlzIHB1cmVseSBmb3IgZWZmaWNpZW5jeSBidXQgaGFzIGFcbiAqIGNvdXBsZSBvZiBpbnRlcmVzdGluZyBiZW5lZml0czpcbiAqXG4gKiAxLiAweDg4IG9mZmVycyBhIHZlcnkgaW5leHBlbnNpdmUgXCJvZmYgdGhlIGJvYXJkXCIgY2hlY2suIEJpdHdpc2UgQU5EICgmKSBhbnlcbiAqICAgIHNxdWFyZSB3aXRoIDB4ODgsIGlmIHRoZSByZXN1bHQgaXMgbm9uLXplcm8gdGhlbiB0aGUgc3F1YXJlIGlzIG9mZiB0aGVcbiAqICAgIGJvYXJkLiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSBrbmlnaHQgc3F1YXJlIEE4ICgwIGluIDB4ODggbm90YXRpb24pLFxuICogICAgdGhlcmUgYXJlIDggcG9zc2libGUgZGlyZWN0aW9ucyBpbiB3aGljaCB0aGUga25pZ2h0IGNhbiBtb3ZlLiBUaGVzZVxuICogICAgZGlyZWN0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhlIDh4MTYgYm9hcmQgYW5kIGFyZSBzdG9yZWQgaW4gdGhlXG4gKiAgICBQSUVDRV9PRkZTRVRTIG1hcC4gT25lIHBvc3NpYmxlIG1vdmUgaXMgQTggLSAxOCAodXAgb25lIHNxdWFyZSwgYW5kIHR3b1xuICogICAgc3F1YXJlcyB0byB0aGUgbGVmdCAtIHdoaWNoIGlzIG9mZiB0aGUgYm9hcmQpLiAwIC0gMTggPSAtMTggJiAweDg4ID0gMHg4OFxuICogICAgKGJlY2F1c2Ugb2YgdHdvLWNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gb2YgLTE4KS4gVGhlIG5vbi16ZXJvIHJlc3VsdFxuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvZmYgdGhlIGJvYXJkIGFuZCB0aGUgbW92ZSBpcyBpbGxlZ2FsLiBUYWtlIHRoZVxuICogICAgb3Bwb3NpdGUgbW92ZSAoZnJvbSBBOCB0byBDNyksIDAgKyAxOCA9IDE4ICYgMHg4OCA9IDAuIEEgcmVzdWx0IG9mIHplcm9cbiAqICAgIG1lYW5zIHRoZSBzcXVhcmUgaXMgb24gdGhlIGJvYXJkLlxuICpcbiAqIDIuIFRoZSByZWxhdGl2ZSBkaXN0YW5jZSAob3IgZGlmZmVyZW5jZSkgYmV0d2VlbiB0d28gc3F1YXJlcyBvbiBhIDh4MTYgYm9hcmRcbiAqICAgIGlzIHVuaXF1ZSBhbmQgY2FuIGJlIHVzZWQgdG8gaW5leHBlbnNpdmVseSBkZXRlcm1pbmUgaWYgYSBwaWVjZSBvbiBhXG4gKiAgICBzcXVhcmUgY2FuIGF0dGFjayBhbnkgb3RoZXIgYXJiaXRyYXJ5IHNxdWFyZS4gRm9yIGV4YW1wbGUsIGxldCdzIHNlZSBpZiBhXG4gKiAgICBwYXduIG9uIEU3IGNhbiBhdHRhY2sgRTIuIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gRTcgKDIwKSAtIEUyICgxMDApIGlzXG4gKiAgICAtODAuIFdlIGFkZCAxMTkgdG8gbWFrZSB0aGUgQVRUQUNLUyBhcnJheSBpbmRleCBub24tbmVnYXRpdmUgKGJlY2F1c2UgdGhlXG4gKiAgICB3b3JzdCBjYXNlIGRpZmZlcmVuY2UgaXMgQTggLSBIMSA9IC0xMTkpLiBUaGUgQVRUQUNLUyBhcnJheSBjb250YWlucyBhXG4gKiAgICBiaXRtYXNrIG9mIHBpZWNlcyB0aGF0IGNhbiBhdHRhY2sgZnJvbSB0aGF0IGRpc3RhbmNlIGFuZCBkaXJlY3Rpb24uXG4gKiAgICBBVFRBQ0tTWy04MCArIDExOT0zOV0gZ2l2ZXMgdXMgMjQgb3IgMGIxMTAwMCBpbiBiaW5hcnkuIExvb2sgYXQgdGhlXG4gKiAgICBQSUVDRV9NQVNLUyBtYXAgdG8gZGV0ZXJtaW5lIHRoZSBtYXNrIGZvciBhIGdpdmVuIHBpZWNlIHR5cGUuIEluIG91ciBwYXduXG4gKiAgICBleGFtcGxlLCB3ZSB3b3VsZCBjaGVjayB0byBzZWUgaWYgMjQgJiAweDEgaXMgbm9uLXplcm8sIHdoaWNoIGl0IGlzXG4gKiAgICBub3QuIFNvLCBuYXR1cmFsbHksIGEgcGF3biBvbiBFNyBjYW4ndCBhdHRhY2sgYSBwaWVjZSBvbiBFMi4gSG93ZXZlciwgYVxuICogICAgcm9vayBjYW4gc2luY2UgMjQgJiAweDggaXMgbm9uLXplcm8uIFRoZSBvbmx5IHRoaW5nIGxlZnQgdG8gY2hlY2sgaXMgdGhhdFxuICogICAgdGhlcmUgYXJlIG5vIGJsb2NraW5nIHBpZWNlcyBiZXR3ZWVuIEU3IGFuZCBFMi4gVGhhdCdzIHdoZXJlIHRoZSBSQVlTXG4gKiAgICBhcnJheSBjb21lcyBpbi4gSXQgcHJvdmlkZXMgYW4gb2Zmc2V0IChpbiB0aGlzIGNhc2UgMTYpIHRvIGFkZCB0byBFNyAoMjApXG4gKiAgICB0byBjaGVjayBmb3IgYmxvY2tpbmcgcGllY2VzLiBFNyAoMjApICsgMTYgPSBFNiAoMzYpICsgMTYgPSBFNSAoNTIpIGV0Yy5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IE94ODggPSB7XG4gICAgYTg6IDAsIGI4OiAxLCBjODogMiwgZDg6IDMsIGU4OiA0LCBmODogNSwgZzg6IDYsIGg4OiA3LFxuICAgIGE3OiAxNiwgYjc6IDE3LCBjNzogMTgsIGQ3OiAxOSwgZTc6IDIwLCBmNzogMjEsIGc3OiAyMiwgaDc6IDIzLFxuICAgIGE2OiAzMiwgYjY6IDMzLCBjNjogMzQsIGQ2OiAzNSwgZTY6IDM2LCBmNjogMzcsIGc2OiAzOCwgaDY6IDM5LFxuICAgIGE1OiA0OCwgYjU6IDQ5LCBjNTogNTAsIGQ1OiA1MSwgZTU6IDUyLCBmNTogNTMsIGc1OiA1NCwgaDU6IDU1LFxuICAgIGE0OiA2NCwgYjQ6IDY1LCBjNDogNjYsIGQ0OiA2NywgZTQ6IDY4LCBmNDogNjksIGc0OiA3MCwgaDQ6IDcxLFxuICAgIGEzOiA4MCwgYjM6IDgxLCBjMzogODIsIGQzOiA4MywgZTM6IDg0LCBmMzogODUsIGczOiA4NiwgaDM6IDg3LFxuICAgIGEyOiA5NiwgYjI6IDk3LCBjMjogOTgsIGQyOiA5OSwgZTI6IDEwMCwgZjI6IDEwMSwgZzI6IDEwMiwgaDI6IDEwMyxcbiAgICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XG59O1xuY29uc3QgUEFXTl9PRkZTRVRTID0ge1xuICAgIGI6IFsxNiwgMzIsIDE3LCAxNV0sXG4gICAgdzogWy0xNiwgLTMyLCAtMTcsIC0xNV0sXG59O1xuY29uc3QgUElFQ0VfT0ZGU0VUUyA9IHtcbiAgICBuOiBbLTE4LCAtMzMsIC0zMSwgLTE0LCAxOCwgMzMsIDMxLCAxNF0sXG4gICAgYjogWy0xNywgLTE1LCAxNywgMTVdLFxuICAgIHI6IFstMTYsIDEsIDE2LCAtMV0sXG4gICAgcTogWy0xNywgLTE2LCAtMTUsIDEsIDE3LCAxNiwgMTUsIC0xXSxcbiAgICBrOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQVRUQUNLUyA9IFtcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLFxuICAgIDAsIDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAyNCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDU2LCAwLCA1NiwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyLCA1MywgNTYsIDUzLCAyLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIwLCAyLCAyNCwgMiwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAyMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAyMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDAsIDIwXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBSQVlTID0gW1xuICAgIDE3LCAwLCAwLCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsXG4gICAgMCwgMTcsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAxNSwgMCwgMCxcbiAgICAwLCAwLCAxNywgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDE3LCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMTcsIDAsIDAsIDE2LCAwLCAwLCAxNSwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAxNywgMCwgMTYsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDE3LCAxNiwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgLTE1LCAtMTYsIC0xNywgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAtMTUsIDAsIC0xNiwgMCwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIC0xNSwgMCwgMCwgLTE2LCAwLCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgLTE1LCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAtMTUsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLFxuICAgIDAsIC0xNSwgMCwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsXG4gICAgLTE1LCAwLCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIDAsIC0xN1xuXTtcbmNvbnN0IFBJRUNFX01BU0tTID0geyBwOiAweDEsIG46IDB4MiwgYjogMHg0LCByOiAweDgsIHE6IDB4MTAsIGs6IDB4MjAgfTtcbmNvbnN0IFNZTUJPTFMgPSAncG5icnFrUE5CUlFLJztcbmNvbnN0IFBST01PVElPTlMgPSBbS05JR0hULCBCSVNIT1AsIFJPT0ssIFFVRUVOXTtcbmNvbnN0IFJBTktfMSA9IDc7XG5jb25zdCBSQU5LXzIgPSA2O1xuLypcbiAqIGNvbnN0IFJBTktfMyA9IDVcbiAqIGNvbnN0IFJBTktfNCA9IDRcbiAqIGNvbnN0IFJBTktfNSA9IDNcbiAqIGNvbnN0IFJBTktfNiA9IDJcbiAqL1xuY29uc3QgUkFOS183ID0gMTtcbmNvbnN0IFJBTktfOCA9IDA7XG5jb25zdCBTSURFUyA9IHtcbiAgICBbS0lOR106IEJJVFMuS1NJREVfQ0FTVExFLFxuICAgIFtRVUVFTl06IEJJVFMuUVNJREVfQ0FTVExFLFxufTtcbmNvbnN0IFJPT0tTID0ge1xuICAgIHc6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTEsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG4gICAgYjogW1xuICAgICAgICB7IHNxdWFyZTogT3g4OC5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICAgICAgeyBzcXVhcmU6IE94ODguaDgsIGZsYWc6IEJJVFMuS1NJREVfQ0FTVExFIH0sXG4gICAgXSxcbn07XG5jb25zdCBTRUNPTkRfUkFOSyA9IHsgYjogUkFOS183LCB3OiBSQU5LXzIgfTtcbmNvbnN0IFRFUk1JTkFUSU9OX01BUktFUlMgPSBbJzEtMCcsICcwLTEnLCAnMS8yLTEvMicsICcqJ107XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCByYW5rIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gcmFuayhzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlID4+IDQ7XG59XG4vLyBFeHRyYWN0cyB0aGUgemVyby1iYXNlZCBmaWxlIG9mIGFuIDB4ODggc3F1YXJlLlxuZnVuY3Rpb24gZmlsZShzcXVhcmUpIHtcbiAgICByZXR1cm4gc3F1YXJlICYgMHhmO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjKSB7XG4gICAgcmV0dXJuICcwMTIzNDU2Nzg5Jy5pbmRleE9mKGMpICE9PSAtMTtcbn1cbi8vIENvbnZlcnRzIGEgMHg4OCBzcXVhcmUgdG8gYWxnZWJyYWljIG5vdGF0aW9uLlxuZnVuY3Rpb24gYWxnZWJyYWljKHNxdWFyZSkge1xuICAgIGNvbnN0IGYgPSBmaWxlKHNxdWFyZSk7XG4gICAgY29uc3QgciA9IHJhbmsoc3F1YXJlKTtcbiAgICByZXR1cm4gKCdhYmNkZWZnaCcuc3Vic3RyaW5nKGYsIGYgKyAxKSArXG4gICAgICAgICc4NzY1NDMyMScuc3Vic3RyaW5nKHIsIHIgKyAxKSk7XG59XG5mdW5jdGlvbiBzd2FwQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IgPT09IFdISVRFID8gQkxBQ0sgOiBXSElURTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZlbihmZW4pIHtcbiAgICAvLyAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/XG4gICAgY29uc3QgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG11c3QgY29udGFpbiBzaXggc3BhY2UtZGVsaW1pdGVkIGZpZWxkcycsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDJuZCBjcml0ZXJpb246IG1vdmUgbnVtYmVyIGZpZWxkIGlzIGEgaW50ZWdlciB2YWx1ZSA+IDA/XG4gICAgY29uc3QgbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgIGlmIChpc05hTihtb3ZlTnVtYmVyKSB8fCBtb3ZlTnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IG1vdmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gM3JkIGNyaXRlcmlvbjogaGFsZiBtb3ZlIGNvdW50ZXIgaXMgYW4gaW50ZWdlciA+PSAwP1xuICAgIGNvbnN0IGhhbGZNb3ZlcyA9IHBhcnNlSW50KHRva2Vuc1s0XSwgMTApO1xuICAgIGlmIChpc05hTihoYWxmTW92ZXMpIHx8IGhhbGZNb3ZlcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IGhhbGYgbW92ZSBjb3VudGVyIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz9cbiAgICBpZiAoIS9eKC18W2FiY2RlZmdoXVszNl0pJC8udGVzdCh0b2tlbnNbM10pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogZW4tcGFzc2FudCBzcXVhcmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNXRoIGNyaXRlcmlvbjogM3RoIGZpZWxkIGlzIGEgdmFsaWQgY2FzdGxlLXN0cmluZz9cbiAgICBpZiAoL1tea0txUS1dLy50ZXN0KHRva2Vuc1syXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBjYXN0bGluZyBhdmFpbGFiaWxpdHkgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gNnRoIGNyaXRlcmlvbjogMm5kIGZpZWxkIGlzIFwid1wiICh3aGl0ZSkgb3IgXCJiXCIgKGJsYWNrKT9cbiAgICBpZiAoIS9eKHd8YikkLy50ZXN0KHRva2Vuc1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBzaWRlLXRvLW1vdmUgaXMgaW52YWxpZCcgfTtcbiAgICB9XG4gICAgLy8gN3RoIGNyaXRlcmlvbjogMXN0IGZpZWxkIGNvbnRhaW5zIDggcm93cz9cbiAgICBjb25zdCByb3dzID0gdG9rZW5zWzBdLnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvd3MubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDh0aCBjcml0ZXJpb246IGV2ZXJ5IHJvdyBpcyB2YWxpZD9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJpZ2h0IHN1bSBvZiBmaWVsZHMgQU5EIG5vdCB0d28gbnVtYmVycyBpbiBzdWNjZXNzaW9uXG4gICAgICAgIGxldCBzdW1GaWVsZHMgPSAwO1xuICAgICAgICBsZXQgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzW2ldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1dhc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChjb25zZWN1dGl2ZSBudW1iZXIpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IHBhcnNlSW50KHJvd3NbaV1ba10sIDEwKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1dhc051bWJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKGludmFsaWQgcGllY2UpJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VtRmllbGRzICs9IDE7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtRmllbGRzICE9PSA4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBwaWVjZSBkYXRhIGlzIGludmFsaWQgKHRvbyBtYW55IHNxdWFyZXMgaW4gcmFuayknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA5dGggY3JpdGVyaW9uOiBpcyBlbi1wYXNzYW50IHNxdWFyZSBsZWdhbD9cbiAgICBpZiAoKHRva2Vuc1szXVsxXSA9PSAnMycgJiYgdG9rZW5zWzFdID09ICd3JykgfHxcbiAgICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJykpIHtcbiAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgRkVOOiBpbGxlZ2FsIGVuLXBhc3NhbnQgc3F1YXJlJyB9O1xuICAgIH1cbiAgICAvLyAxMHRoIGNyaXRlcmlvbjogZG9lcyBjaGVzcyBwb3NpdGlvbiBjb250YWluIGV4YWN0IHR3byBraW5ncz9cbiAgICBjb25zdCBraW5ncyA9IFtcbiAgICAgICAgeyBjb2xvcjogJ3doaXRlJywgcmVnZXg6IC9LL2cgfSxcbiAgICAgICAgeyBjb2xvcjogJ2JsYWNrJywgcmVnZXg6IC9rL2cgfSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgeyBjb2xvciwgcmVnZXggfSBvZiBraW5ncykge1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodG9rZW5zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiBtaXNzaW5nICR7Y29sb3J9IGtpbmdgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0b2tlbnNbMF0ubWF0Y2gocmVnZXgpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgSW52YWxpZCBGRU46IHRvbyBtYW55ICR7Y29sb3J9IGtpbmdzYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDExdGggY3JpdGVyaW9uOiBhcmUgYW55IHBhd25zIG9uIHRoZSBmaXJzdCBvciBlaWdodGggcm93cz9cbiAgICBpZiAoQXJyYXkuZnJvbShyb3dzWzBdICsgcm93c1s3XSkuc29tZSgoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpID09PSAnUCcpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBzb21lIHBhd25zIGFyZSBvbiB0aGUgZWRnZSByb3dzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbn1cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBhbWJpZ3VvdXMgbW92ZXNcbmZ1bmN0aW9uIGdldERpc2FtYmlndWF0b3IobW92ZSwgbW92ZXMpIHtcbiAgICBjb25zdCBmcm9tID0gbW92ZS5mcm9tO1xuICAgIGNvbnN0IHRvID0gbW92ZS50bztcbiAgICBjb25zdCBwaWVjZSA9IG1vdmUucGllY2U7XG4gICAgbGV0IGFtYmlndWl0aWVzID0gMDtcbiAgICBsZXQgc2FtZVJhbmsgPSAwO1xuICAgIGxldCBzYW1lRmlsZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFtYmlnRnJvbSA9IG1vdmVzW2ldLmZyb207XG4gICAgICAgIGNvbnN0IGFtYmlnVG8gPSBtb3Zlc1tpXS50bztcbiAgICAgICAgY29uc3QgYW1iaWdQaWVjZSA9IG1vdmVzW2ldLnBpZWNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGwgbmVlZFxuICAgICAgICAgKiB0byBhZGQgYSBkaXNhbWJpZ3VhdG9yIHRvIHRoZSBhbGdlYnJhaWMgbm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwaWVjZSA9PT0gYW1iaWdQaWVjZSAmJiBmcm9tICE9PSBhbWJpZ0Zyb20gJiYgdG8gPT09IGFtYmlnVG8pIHtcbiAgICAgICAgICAgIGFtYmlndWl0aWVzKys7XG4gICAgICAgICAgICBpZiAocmFuayhmcm9tKSA9PT0gcmFuayhhbWJpZ0Zyb20pKSB7XG4gICAgICAgICAgICAgICAgc2FtZVJhbmsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlKGZyb20pID09PSBmaWxlKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lRmlsZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbWJpZ3VpdGllcyA+IDApIHtcbiAgICAgICAgaWYgKHNhbWVSYW5rID4gMCAmJiBzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGVyZSBleGlzdHMgYSBzaW1pbGFyIG1vdmluZyBwaWVjZSBvbiB0aGUgc2FtZSByYW5rIGFuZCBmaWxlIGFzXG4gICAgICAgICAgICAgKiB0aGUgbW92ZSBpbiBxdWVzdGlvbiwgdXNlIHRoZSBzcXVhcmUgYXMgdGhlIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzYW1lRmlsZSA+IDApIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpZiB0aGUgbW92aW5nIHBpZWNlIHJlc3RzIG9uIHRoZSBzYW1lIGZpbGUsIHVzZSB0aGUgcmFuayBzeW1ib2wgYXMgdGhlXG4gICAgICAgICAgICAgKiBkaXNhbWJpZ3VhdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBhZGRNb3ZlKG1vdmVzLCBjb2xvciwgZnJvbSwgdG8sIHBpZWNlLCBjYXB0dXJlZCA9IHVuZGVmaW5lZCwgZmxhZ3MgPSBCSVRTLk5PUk1BTCkge1xuICAgIGNvbnN0IHIgPSByYW5rKHRvKTtcbiAgICBpZiAocGllY2UgPT09IFBBV04gJiYgKHIgPT09IFJBTktfMSB8fCByID09PSBSQU5LXzgpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUFJPTU9USU9OUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvbW90aW9uID0gUFJPTU9USU9OU1tpXTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgcGllY2UsXG4gICAgICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICAgICAgcHJvbW90aW9uLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncyB8IEJJVFMuUFJPTU9USU9OLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgIGNhcHR1cmVkLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluZmVyUGllY2VUeXBlKHNhbikge1xuICAgIGxldCBwaWVjZVR5cGUgPSBzYW4uY2hhckF0KDApO1xuICAgIGlmIChwaWVjZVR5cGUgPj0gJ2EnICYmIHBpZWNlVHlwZSA8PSAnaCcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNhbi5tYXRjaCgvW2EtaF1cXGQuKlthLWhdXFxkLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVdOO1xuICAgIH1cbiAgICBwaWVjZVR5cGUgPSBwaWVjZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocGllY2VUeXBlID09PSAnbycpIHtcbiAgICAgICAgcmV0dXJuIEtJTkc7XG4gICAgfVxuICAgIHJldHVybiBwaWVjZVR5cGU7XG59XG4vLyBwYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbmZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmUpIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpO1xufVxuZnVuY3Rpb24gdHJpbUZlbihmZW4pIHtcbiAgICAvKlxuICAgICAqIHJlbW92ZSBsYXN0IHR3byBmaWVsZHMgaW4gRkVOIHN0cmluZyBhcyB0aGV5J3JlIG5vdCBuZWVkZWQgd2hlbiBjaGVja2luZ1xuICAgICAqIGZvciByZXBldGl0aW9uXG4gICAgICovXG4gICAgcmV0dXJuIGZlbi5zcGxpdCgnICcpLnNsaWNlKDAsIDQpLmpvaW4oJyAnKTtcbn1cbmV4cG9ydCBjbGFzcyBDaGVzcyB7XG4gICAgX2JvYXJkID0gbmV3IEFycmF5KDEyOCk7XG4gICAgX3R1cm4gPSBXSElURTtcbiAgICBfaGVhZGVyID0ge307XG4gICAgX2tpbmdzID0geyB3OiBFTVBUWSwgYjogRU1QVFkgfTtcbiAgICBfZXBTcXVhcmUgPSAtMTtcbiAgICBfaGFsZk1vdmVzID0gMDtcbiAgICBfbW92ZU51bWJlciA9IDA7XG4gICAgX2hpc3RvcnkgPSBbXTtcbiAgICBfY29tbWVudHMgPSB7fTtcbiAgICBfY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAvLyB0cmFja3MgbnVtYmVyIG9mIHRpbWVzIGEgcG9zaXRpb24gaGFzIGJlZW4gc2VlbiBmb3IgcmVwZXRpdGlvbiBjaGVja2luZ1xuICAgIF9wb3NpdGlvbkNvdW50ID0ge307XG4gICAgY29uc3RydWN0b3IoZmVuID0gREVGQVVMVF9QT1NJVElPTiwgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uIH0pO1xuICAgIH1cbiAgICBjbGVhcih7IHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgICAgIHRoaXMuX3R1cm4gPSBXSElURTtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0gcHJlc2VydmVIZWFkZXJzID8gdGhpcy5faGVhZGVyIDoge307XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQ291bnQgPSB7fTtcbiAgICAgICAgLypcbiAgICAgICAgICogRGVsZXRlIHRoZSBTZXRVcCBhbmQgRkVOIGhlYWRlcnMgKGlmIHByZXNlcnZlZCksIHRoZSBib2FyZCBpcyBlbXB0eSBhbmRcbiAgICAgICAgICogdGhlc2UgaGVhZGVycyBkb24ndCBtYWtlIHNlbnNlIGluIHRoaXMgc3RhdGUuIFRoZXknbGwgZ2V0IGFkZGVkIGxhdGVyXG4gICAgICAgICAqIHZpYSAubG9hZCgpIG9yIC5wdXQoKVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnU2V0VXAnXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgfVxuICAgIGxvYWQoZmVuLCB7IHNraXBWYWxpZGF0aW9uID0gZmFsc2UsIHByZXNlcnZlSGVhZGVycyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIC8vIGFwcGVuZCBjb21tb25seSBvbWl0dGVkIGZlbiB0b2tlbnNcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudHMgPSBbJy0nLCAnLScsICcwJywgJzEnXTtcbiAgICAgICAgICAgIGZlbiA9IHRva2Vucy5jb25jYXQoYWRqdXN0bWVudHMuc2xpY2UoLSg2IC0gdG9rZW5zLmxlbmd0aCkpKS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2ssIGVycm9yIH0gPSB2YWxpZGF0ZUZlbihmZW4pO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0b2tlbnNbMF07XG4gICAgICAgIGxldCBzcXVhcmUgPSAwO1xuICAgICAgICB0aGlzLmNsZWFyKHsgcHJlc2VydmVIZWFkZXJzIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHBvc2l0aW9uLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChwaWVjZSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RpZ2l0KHBpZWNlKSkge1xuICAgICAgICAgICAgICAgIHNxdWFyZSArPSBwYXJzZUludChwaWVjZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwaWVjZSA8ICdhJyA/IFdISVRFIDogQkxBQ0s7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHV0KHsgdHlwZTogcGllY2UudG9Mb3dlckNhc2UoKSwgY29sb3IgfSwgYWxnZWJyYWljKHNxdWFyZSkpO1xuICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R1cm4gPSB0b2tlbnNbMV07XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignSycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdRJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyB8PSBCSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ2snKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZigncScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgfD0gQklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSB0b2tlbnNbM10gPT09ICctJyA/IEVNUFRZIDogT3g4OFt0b2tlbnNbM11dO1xuICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKTtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cChmZW4pO1xuICAgICAgICB0aGlzLl9pbmNQb3NpdGlvbkNvdW50KGZlbik7XG4gICAgfVxuICAgIGZlbigpIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gMDtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGU6IHBpZWNlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgICAgICBmZW4gKz0gY29sb3IgPT09IFdISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBPeDg4LmgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhc3RsaW5nID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ0snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ1EnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ2snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ3EnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gZW1wdHkgY2FzdGxpbmcgZmxhZz9cbiAgICAgICAgY2FzdGxpbmcgPSBjYXN0bGluZyB8fCAnLSc7XG4gICAgICAgIGxldCBlcFNxdWFyZSA9ICctJztcbiAgICAgICAgLypcbiAgICAgICAgICogb25seSBwcmludCB0aGUgZXAgc3F1YXJlIGlmIGVuIHBhc3NhbnQgaXMgYSB2YWxpZCBtb3ZlIChwYXduIGlzIHByZXNlbnRcbiAgICAgICAgICogYW5kIGVwIGNhcHR1cmUgaXMgbm90IHBpbm5lZClcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSAhPT0gRU1QVFkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ1Bhd25TcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IDE2IDogLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc3F1YXJlIG9mZiB0aGUgYm9hcmQ/XG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSBjb2xvciAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXduIG1ha2VzIGFuIGVwIGNhcHR1cmUsIGRvZXMgaXQgbGVhdmUgaXQncyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlOiBQQVdOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogQklUUy5FUF9DQVBUVVJFLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVwIGlzIGxlZ2FsLCBicmVhayBhbmQgc2V0IHRoZSBlcCBzcXVhcmUgaW4gdGhlIEZFTiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gYWxnZWJyYWljKHRoaXMuX2VwU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmZW4sXG4gICAgICAgICAgICB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmcsXG4gICAgICAgICAgICBlcFNxdWFyZSxcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIF0uam9pbignICcpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydTZXRVcCddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICB9XG4gICAgcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdXQoeyB0eXBlLCBjb2xvciB9LCBzcXVhcmUpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDYXN0bGluZ1JpZ2h0cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3B1dCh7IHR5cGUsIGNvbG9yIH0sIHNxdWFyZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgcGllY2VcbiAgICAgICAgaWYgKFNZTUJPTFMuaW5kZXhPZih0eXBlLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciB2YWxpZCBzcXVhcmVcbiAgICAgICAgaWYgKCEoc3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3EgPSBPeDg4W3NxdWFyZV07XG4gICAgICAgIC8vIGRvbid0IGxldCB0aGUgdXNlciBwbGFjZSBtb3JlIHRoYW4gb25lIGtpbmdcbiAgICAgICAgaWYgKHR5cGUgPT0gS0lORyAmJlxuICAgICAgICAgICAgISh0aGlzLl9raW5nc1tjb2xvcl0gPT0gRU1QVFkgfHwgdGhpcy5fa2luZ3NbY29sb3JdID09IHNxKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQaWVjZU9uU3F1YXJlID0gdGhpcy5fYm9hcmRbc3FdO1xuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIGtpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHBpZWNlIGZyb20gYXJncywgc2V0IHRoZSBgX2tpbmdzYCByZXNwZWN0aXZlIGVudHJ5IHRvIGBFTVBUWWBcbiAgICAgICAgaWYgKGN1cnJlbnRQaWVjZU9uU3F1YXJlICYmIGN1cnJlbnRQaWVjZU9uU3F1YXJlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2N1cnJlbnRQaWVjZU9uU3F1YXJlLmNvbG9yXSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvYXJkW3NxXSA9IHsgdHlwZTogdHlwZSwgY29sb3I6IGNvbG9yIH07XG4gICAgICAgIGlmICh0eXBlID09PSBLSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9raW5nc1tjb2xvcl0gPSBzcTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlKHNxdWFyZSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuZ2V0KHNxdWFyZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtPeDg4W3NxdWFyZV1dO1xuICAgICAgICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbcGllY2UuY29sb3JdID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5QYXNzYW50U3F1YXJlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNldHVwKHRoaXMuZmVuKCkpO1xuICAgICAgICByZXR1cm4gcGllY2U7XG4gICAgfVxuICAgIF91cGRhdGVDYXN0bGluZ1JpZ2h0cygpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVLaW5nSW5QbGFjZSA9IHRoaXMuX2JvYXJkW094ODguZTFdPy50eXBlID09PSBLSU5HICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtPeDg4LmUxXT8uY29sb3IgPT09IFdISVRFO1xuICAgICAgICBjb25zdCBibGFja0tpbmdJblBsYWNlID0gdGhpcy5fYm9hcmRbT3g4OC5lOF0/LnR5cGUgPT09IEtJTkcgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguZThdPy5jb2xvciA9PT0gQkxBQ0s7XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYTFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDFdPy5jb2xvciAhPT0gV0hJVEUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5hOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguYThdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbT3g4OC5oOF0/LnR5cGUgIT09IFJPT0sgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW094ODguaDhdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVFblBhc3NhbnRTcXVhcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSA9PT0gRU1QVFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gLTE2IDogMTYpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3F1YXJlID0gdGhpcy5fZXBTcXVhcmUgKyAodGhpcy5fdHVybiA9PT0gV0hJVEUgPyAxNiA6IC0xNik7XG4gICAgICAgIGNvbnN0IGF0dGFja2VycyA9IFtjdXJyZW50U3F1YXJlICsgMSwgY3VycmVudFNxdWFyZSAtIDFdO1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbc3RhcnRTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFt0aGlzLl9lcFNxdWFyZV0gIT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW2N1cnJlbnRTcXVhcmVdPy5jb2xvciAhPT0gc3dhcENvbG9yKHRoaXMuX3R1cm4pIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8udHlwZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5DYXB0dXJlID0gKHNxdWFyZSkgPT4gIShzcXVhcmUgJiAweDg4KSAmJlxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IHRoaXMuX3R1cm4gJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LnR5cGUgPT09IFBBV047XG4gICAgICAgIGlmICghYXR0YWNrZXJzLnNvbWUoY2FuQ2FwdHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGFja2VkKGNvbG9yLCBzcXVhcmUsIHZlcmJvc2UpIHtcbiAgICAgICAgY29uc3QgYXR0YWNrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVtcHR5IHNxdWFyZSBvciB3cm9uZyBjb2xvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IGkgLSBzcXVhcmU7XG4gICAgICAgICAgICAvLyBza2lwIC0gdG8vZnJvbSBzcXVhcmUgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xuICAgICAgICAgICAgaWYgKEFUVEFDS1NbaW5kZXhdICYgUElFQ0VfTUFTS1NbcGllY2UudHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRpZmZlcmVuY2UgPiAwICYmIHBpZWNlLmNvbG9yID09PSBXSElURSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmZXJlbmNlIDw9IDAgJiYgcGllY2UuY29sb3IgPT09IEJMQUNLKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2tlcnMucHVzaChhbGdlYnJhaWMoaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGllY2UgaXMgYSBrbmlnaHQgb3IgYSBraW5nXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBSQVlTW2luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiAhPT0gc3F1YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtqXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGogKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFja2Vycy5wdXNoKGFsZ2VicmFpYyhpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFja2VycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2tlcnMoc3F1YXJlLCBhdHRhY2tlZEJ5KSB7XG4gICAgICAgIGlmICghYXR0YWNrZWRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKHRoaXMuX3R1cm4sIE94ODhbc3F1YXJlXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNrZWQoYXR0YWNrZWRCeSwgT3g4OFtzcXVhcmVdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gdGhpcy5fa2luZ3NbY29sb3JdO1xuICAgICAgICByZXR1cm4gc3F1YXJlID09PSAtMSA/IGZhbHNlIDogdGhpcy5fYXR0YWNrZWQoc3dhcENvbG9yKGNvbG9yKSwgc3F1YXJlKTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UG9zaXRpb25Db3VudCh0aGlzLmZlbigpKSA+PSAzO1xuICAgIH1cbiAgICBpc0RyYXdCeUZpZnR5TW92ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYWxmTW92ZXMgPj0gMTAwOyAvLyA1MCBtb3ZlcyBwZXIgc2lkZSA9IDEwMCBoYWxmIG1vdmVzXG4gICAgfVxuICAgIGlzRHJhdygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzRHJhd0J5RmlmdHlNb3ZlcygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzU3RhbGVtYXRlKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzVGhyZWVmb2xkUmVwZXRpdGlvbigpKTtcbiAgICB9XG4gICAgaXNHYW1lT3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja21hdGUoKSB8fCB0aGlzLmlzU3RhbGVtYXRlKCkgfHwgdGhpcy5pc0RyYXcoKTtcbiAgICB9XG4gICAgbW92ZXMoeyB2ZXJib3NlID0gZmFsc2UsIHNxdWFyZSA9IHVuZGVmaW5lZCwgcGllY2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgc3F1YXJlLCBwaWVjZSB9KTtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IG5ldyBNb3ZlKHRoaXMsIG1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IHRoaXMuX21vdmVUb1Nhbihtb3ZlLCBtb3ZlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9tb3Zlcyh7IGxlZ2FsID0gdHJ1ZSwgcGllY2UgPSB1bmRlZmluZWQsIHNxdWFyZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZvclNxdWFyZSA9IHNxdWFyZSA/IHNxdWFyZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmb3JQaWVjZSA9IHBpZWNlPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBsZXQgZmlyc3RTcXVhcmUgPSBPeDg4LmE4O1xuICAgICAgICBsZXQgbGFzdFNxdWFyZSA9IE94ODguaDE7XG4gICAgICAgIGxldCBzaW5nbGVTcXVhcmUgPSBmYWxzZTtcbiAgICAgICAgLy8gYXJlIHdlIGdlbmVyYXRpbmcgbW92ZXMgZm9yIGEgc2luZ2xlIHNxdWFyZT9cbiAgICAgICAgaWYgKGZvclNxdWFyZSkge1xuICAgICAgICAgICAgLy8gaWxsZWdhbCBzcXVhcmUsIHJldHVybiBlbXB0eSBtb3Zlc1xuICAgICAgICAgICAgaWYgKCEoZm9yU3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RTcXVhcmUgPSBsYXN0U3F1YXJlID0gT3g4OFtmb3JTcXVhcmVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVNxdWFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IGZpcnN0U3F1YXJlOyBmcm9tIDw9IGxhc3RTcXVhcmU7IGZyb20rKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChmcm9tICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGZyb20gKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtcHR5IHNxdWFyZSBvciBvcHBvbmVudCwgc2tpcFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtmcm9tXSB8fCB0aGlzLl9ib2FyZFtmcm9tXS5jb2xvciA9PT0gdGhlbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzLl9ib2FyZFtmcm9tXTtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3F1YXJlLCBub24tY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04pO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgc3F1YXJlXG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTRUNPTkRfUkFOS1t1c10gPT09IHJhbmsoZnJvbSkgJiYgIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCB1bmRlZmluZWQsIEJJVFMuQklHX1BBV04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhd24gY2FwdHVyZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10/LmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSB0aGlzLl9lcFNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCBQQVdOLCBCSVRTLkVQX0NBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gUElFQ0VfT0ZGU0VUU1t0eXBlXS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3R5cGVdW2pdO1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duIGNvbG9yLCBzdG9wIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbdG9dLmNvbG9yID09PSB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCB0eXBlLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJyZWFrLCBpZiBrbmlnaHQgb3Iga2luZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEtOSUdIVCB8fCB0eXBlID09PSBLSU5HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZWNrIGZvciBjYXN0bGluZyBpZiB3ZSdyZTpcbiAgICAgICAgICogICBhKSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3JcbiAgICAgICAgICogICBiKSBkb2luZyBzaW5nbGUgc3F1YXJlIG1vdmUgZ2VuZXJhdGlvbiBvbiB0aGUga2luZydzIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvclBpZWNlID09PSB1bmRlZmluZWQgfHwgZm9yUGllY2UgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlU3F1YXJlIHx8IGxhc3RTcXVhcmUgPT09IHRoaXMuX2tpbmdzW3VzXSkge1xuICAgICAgICAgICAgICAgIC8vIGtpbmctc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gKyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSArIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdGcm9tICsgMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgS0lORywgdW5kZWZpbmVkLCBCSVRTLktTSURFX0NBU1RMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVlZW4tc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gLSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gLSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuUVNJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXG4gICAgICAgICAqIHRvIGJlIGNhcHR1cmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFsZWdhbCB8fCB0aGlzLl9raW5nc1t1c10gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzXG4gICAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKHVzKSkge1xuICAgICAgICAgICAgICAgIGxlZ2FsTW92ZXMucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgIH1cbiAgICBtb3ZlKG1vdmUsIHsgc3RyaWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBtb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKCdOeGI3JykgICAgICAgPC0gYXJndW1lbnQgaXMgYSBjYXNlLXNlbnNpdGl2ZSBTQU4gc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKHsgZnJvbTogJ2g3JywgPC0gYXJndW1lbnQgaXMgYSBtb3ZlIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgIHRvIDonaDgnLFxuICAgICAgICAgKiAgICAgICAgIHByb21vdGlvbjogJ3EnIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHN0cmljdCBhcmd1bWVudCBtYXkgYmUgc3VwcGxpZWQgdG8gdGVsbCBjaGVzcy5qcyB0b1xuICAgICAgICAgKiBzdHJpY3RseSBmb2xsb3cgdGhlIFNBTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1vdmVPYmogPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtb3ZlT2JqID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHwgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGZpbmQgbW92ZVxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHttb3ZlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7SlNPTi5zdHJpbmdpZnkobW92ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZSBtb3ZlXG4gICAgICAgICAqIGlzIG1hZGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZXR0eU1vdmUgPSBuZXcgTW92ZSh0aGlzLCBtb3ZlT2JqKTtcbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZU9iaik7XG4gICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQocHJldHR5TW92ZS5hZnRlcik7XG4gICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgIH1cbiAgICBfcHVzaChtb3ZlKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBtb3ZlLFxuICAgICAgICAgICAga2luZ3M6IHsgYjogdGhpcy5fa2luZ3MuYiwgdzogdGhpcy5fa2luZ3MudyB9LFxuICAgICAgICAgICAgdHVybjogdGhpcy5fdHVybixcbiAgICAgICAgICAgIGNhc3RsaW5nOiB7IGI6IHRoaXMuX2Nhc3RsaW5nLmIsIHc6IHRoaXMuX2Nhc3RsaW5nLncgfSxcbiAgICAgICAgICAgIGVwU3F1YXJlOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgIGhhbGZNb3ZlczogdGhpcy5faGFsZk1vdmVzLFxuICAgICAgICAgICAgbW92ZU51bWJlcjogdGhpcy5fbW92ZU51bWJlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9tYWtlTW92ZShtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHVzID0gdGhpcy5fdHVybjtcbiAgICAgICAgY29uc3QgdGhlbSA9IHN3YXBDb2xvcih1cyk7XG4gICAgICAgIHRoaXMuX3B1c2gobW92ZSk7XG4gICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0gdGhpcy5fYm9hcmRbbW92ZS5mcm9tXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUuZnJvbV07XG4gICAgICAgIC8vIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3blxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3R1cm4gPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUudG8gLSAxNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS50byArIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBwYXduIHByb21vdGlvbiwgcmVwbGFjZSB3aXRoIG5ldyBwaWVjZVxuICAgICAgICBpZiAobW92ZS5wcm9tb3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW21vdmUudG9dID0geyB0eXBlOiBtb3ZlLnByb21vdGlvbiwgY29sb3I6IHVzIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgbW92ZWQgdGhlIGtpbmdcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW21vdmUudG9dLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3VzXSA9IG1vdmUudG87XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYXN0bGVkLCBtb3ZlIHRoZSByb29rIG5leHQgdG8gdGhlIGtpbmdcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvYXJkW2Nhc3RsaW5nVG9dID0gdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nXG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t1c10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBST09LU1t1c10ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBST09LU1t1c11baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSAmIFJPT0tTW3VzXVtpXS5mbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSBePSBST09LU1t1c11baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIGNhcHR1cmUgYSByb29rXG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t0aGVtXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3RoZW1dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUudG8gPT09IFJPT0tTW3RoZW1dW2ldLnNxdWFyZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSAmIFJPT0tTW3RoZW1dW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdGhlbV0gXj0gUk9PS1NbdGhlbV1baV0uZmxhZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGJpZyBwYXduIG1vdmUsIHVwZGF0ZSB0aGUgZW4gcGFzc2FudCBzcXVhcmVcbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkJJR19QQVdOKSB7XG4gICAgICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzZXQgdGhlIDUwIG1vdmUgY291bnRlciBpZiBhIHBhd24gaXMgbW92ZWQgb3IgYSBwaWVjZSBpcyBjYXB0dXJlZFxuICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXMgPT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlTnVtYmVyKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHVybiA9IHRoZW07XG4gICAgfVxuICAgIHVuZG8oKSB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgY29uc3QgcHJldHR5TW92ZSA9IG5ldyBNb3ZlKHRoaXMsIG1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fZGVjUG9zaXRpb25Db3VudChwcmV0dHlNb3ZlLmFmdGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcmV0dHlNb3ZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdW5kb01vdmUoKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICAgIGlmIChvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZSA9IG9sZC5tb3ZlO1xuICAgICAgICB0aGlzLl9raW5ncyA9IG9sZC5raW5ncztcbiAgICAgICAgdGhpcy5fdHVybiA9IG9sZC50dXJuO1xuICAgICAgICB0aGlzLl9jYXN0bGluZyA9IG9sZC5jYXN0bGluZztcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBvbGQuZXBTcXVhcmU7XG4gICAgICAgIHRoaXMuX2hhbGZNb3ZlcyA9IG9sZC5oYWxmTW92ZXM7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBvbGQubW92ZU51bWJlcjtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS5mcm9tXSA9IHRoaXMuX2JvYXJkW21vdmUudG9dO1xuICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLmZyb21dLnR5cGUgPSBtb3ZlLnBpZWNlOyAvLyB0byB1bmRvIGFueSBwcm9tb3Rpb25zXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFttb3ZlLnRvXTtcbiAgICAgICAgaWYgKG1vdmUuY2FwdHVyZWQpIHtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICAgICAgLy8gZW4gcGFzc2FudCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBtb3ZlLnRvIC0gMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gKyAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbaW5kZXhdID0geyB0eXBlOiBQQVdOLCBjb2xvcjogdGhlbSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVndWxhciBjYXB0dXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUuY2FwdHVyZWQsIGNvbG9yOiB0aGVtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5LU0lERV9DQVNUTEUgfCBCSVRTLlFTSURFX0NBU1RMRSkpIHtcbiAgICAgICAgICAgIGxldCBjYXN0bGluZ1RvLCBjYXN0bGluZ0Zyb207XG4gICAgICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdUbyA9IG1vdmUudG8gLSAyO1xuICAgICAgICAgICAgICAgIGNhc3RsaW5nRnJvbSA9IG1vdmUudG8gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICAgIHBnbih7IG5ld2xpbmUgPSAnXFxuJywgbWF4V2lkdGggPSAwLCB9ID0ge30pIHtcbiAgICAgICAgLypcbiAgICAgICAgICogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xuICAgICAgICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGhlYWRlckV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAvKiBhZGQgdGhlIFBHTiBoZWFkZXIgaW5mb3JtYXRpb24gKi9cbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRPRE86IG9yZGVyIG9mIGVudW1lcmF0ZWQgcHJvcGVydGllcyBpbiBoZWFkZXIgb2JqZWN0IGlzIG5vdFxuICAgICAgICAgICAgICogZ3VhcmFudGVlZCwgc2VlIEVDTUEtMjYyIHNwZWMgKHNlY3Rpb24gMTIuNi40KVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXN1bHQucHVzaCgnWycgKyBpICsgJyBcIicgKyB0aGlzLl9oZWFkZXJbaV0gKyAnXCJdJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgaGVhZGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyRXhpc3RzICYmIHRoaXMuX2hpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRDb21tZW50ID0gKG1vdmVTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxpbWl0ZXIgPSBtb3ZlU3RyaW5nLmxlbmd0aCA+IDAgPyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gYCR7bW92ZVN0cmluZ30ke2RlbGltaXRlcn17JHtjb21tZW50fX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vdmVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBvcCBhbGwgb2YgaGlzdG9yeSBvbnRvIHJldmVyc2VkX2hpc3RvcnlcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgICAgIGxldCBtb3ZlU3RyaW5nID0gJyc7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBvZiBhIGNvbW1lbnRlZCBzdGFydGluZyBwb3NpdGlvbiB3aXRoIG5vIG1vdmVzXG4gICAgICAgIGlmIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQoJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgbGlzdCBvZiBtb3Zlcy4gIGEgbW92ZV9zdHJpbmcgbG9va3MgbGlrZTogXCIzLiBlMyBlNlwiXG4gICAgICAgIHdoaWxlIChyZXZlcnNlZEhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbW92ZVN0cmluZyA9IGFwcGVuZENvbW1lbnQobW92ZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgLy8gbWFrZSBUeXBlU2NyaXB0IHN0b3AgY29tcGxhaW5pbmcgYWJvdXQgbW92ZSBiZWluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvc2l0aW9uIHN0YXJ0ZWQgd2l0aCBibGFjayB0byBtb3ZlLCBzdGFydCBQR04gd2l0aCAjLiAuLi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGlzdG9yeS5sZW5ndGggJiYgbW92ZS5jb2xvciA9PT0gJ2InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCR7dGhpcy5fbW92ZU51bWJlcn0uIC4uLmA7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgYSBjb21tZW50IHByZWNlZGluZyB0aGUgZmlyc3QgbW92ZT9cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nID0gbW92ZVN0cmluZyA/IGAke21vdmVTdHJpbmd9ICR7cHJlZml4fWAgOiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSAndycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgZ2VuZXJhdGVkIG1vdmVfc3RyaW5nIGlmIHdlIGhhdmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSB0aGlzLl9tb3ZlTnVtYmVyICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZVN0cmluZyA9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyArICcgJyArIHRoaXMuX21vdmVUb1Nhbihtb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFyZSB0aGVyZSBhbnkgb3RoZXIgbGVmdG92ZXIgbW92ZXM/XG4gICAgICAgIGlmIChtb3ZlU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KG1vdmVTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyB0aGVyZSBhIHJlc3VsdD9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9oZWFkZXIuUmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbW92ZXMucHVzaCh0aGlzLl9oZWFkZXIuUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBoaXN0b3J5IHNob3VsZCBiZSBiYWNrIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBzdGFydGVkIGdlbmVyYXRpbmcgUEdOLFxuICAgICAgICAgKiBzbyBqb2luIHRvZ2V0aGVyIG1vdmVzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobWF4V2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJykgKyBtb3Zlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAoamFoKTogaHVoP1xuICAgICAgICBjb25zdCBzdHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS5cbiAgICAgICAgY29uc3Qgd3JhcENvbW1lbnQgPSBmdW5jdGlvbiAod2lkdGgsIG1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbW92ZS5zcGxpdCgnICcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0cmlwKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgIHdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdyYXAgdGhlIFBHTiBvdXRwdXQgYXQgbWF4X3dpZHRoXG4gICAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZXNbaV0uaW5jbHVkZXMoJ3snKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSB3cmFwQ29tbWVudChjdXJyZW50V2lkdGgsIG1vdmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbW92ZSB3aWxsIHB1c2ggcGFzdCBtYXhfd2lkdGhcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHRoZSBsaW5lIHdpdGggd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICBjdXJyZW50V2lkdGggKz0gbW92ZXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBzZXRIZWFkZXJgIGFuZCBgZ2V0SGVhZGVyc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBoZWFkZXIoLi4uYXJncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3NbaSArIDFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclthcmdzW2ldXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcltrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXI7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9XG4gICAgbG9hZFBnbihwZ24sIHsgc3RyaWN0ID0gZmFsc2UsIG5ld2xpbmVDaGFyID0gJ1xccj9cXG4nLCB9ID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gbWFzayhzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUGduSGVhZGVyKGhlYWRlcikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyT2JqID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gaGVhZGVyLnNwbGl0KG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhcikpKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSAnJztcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvXlxccypcXFtcXHMqKFtBLVphLXpdKylcXHMqXCIoLiopXCJcXHMqXFxdXFxzKiQvO1xuICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcnNbaV0ucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBoZWFkZXJzW2ldLnJlcGxhY2UocmVnZXgsICckMicpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyT2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyT2JqO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmlwIHdoaXRlc3BhY2UgZnJvbSBoZWFkL3RhaWwgb2YgUEdOIGJsb2NrXG4gICAgICAgIHBnbiA9IHBnbi50cmltKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlZ0V4cCB0byBzcGxpdCBoZWFkZXIuIFRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGhlYWRlciBhbmQgbW92ZXRleHRcbiAgICAgICAgICogd2lsbCBhbHdheXMgaGF2ZSBhIGJsYW5rIGxpbmUgYmV0d2VlbiB0aGVtIChpZSwgdHdvIG5ld2xpbmVfY2hhcidzKS4gSGFuZGxlc1xuICAgICAgICAgKiBjYXNlIHdoZXJlIG1vdmV0ZXh0IGlzIGVtcHR5IGJ5IG1hdGNoaW5nIG5ld2xpbmVDaGFyIHVudGlsIGVuZCBvZiBzdHJpbmcgaXNcbiAgICAgICAgICogbWF0Y2hlZCAtIGVmZmVjdGl2ZWx5IHRyaW1taW5nIGZyb20gdGhlIGVuZCBleHRyYSBuZXdsaW5lQ2hhci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBkZWZhdWx0IG5ld2xpbmVfY2hhciwgd2lsbCBlcXVhbDpcbiAgICAgICAgICogL14oXFxbKCg/Olxccj9cXG4pfC4pKlxcXSkoKD86XFxzKlxccj9cXG4pezJ9fCg/OlxccypcXHI/XFxuKSokKS9cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihcXFxcWygoPzonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpfC4pKlxcXFxdKScgK1xuICAgICAgICAgICAgJygoPzpcXFxccyonICtcbiAgICAgICAgICAgIG1hc2sobmV3bGluZUNoYXIpICtcbiAgICAgICAgICAgICcpezJ9fCg/OlxcXFxzKicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJykqJCknKTtcbiAgICAgICAgLy8gSWYgbm8gaGVhZGVyIGdpdmVuLCBiZWdpbiB3aXRoIG1vdmVzLlxuICAgICAgICBjb25zdCBoZWFkZXJSZWdleFJlc3VsdHMgPSBoZWFkZXJSZWdleC5leGVjKHBnbik7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGhlYWRlclJlZ2V4UmVzdWx0c1xuICAgICAgICAgICAgPyBoZWFkZXJSZWdleFJlc3VsdHMubGVuZ3RoID49IDJcbiAgICAgICAgICAgICAgICA/IGhlYWRlclJlZ2V4UmVzdWx0c1sxXVxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIC8vIFB1dCB0aGUgYm9hcmQgaW4gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgLy8gcGFyc2UgUEdOIGhlYWRlclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VQZ25IZWFkZXIoaGVhZGVyU3RyaW5nKTtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdXNlciBpcyBpbmNsdWRpbmcgZmVuIChwb3NzaWJseSB3aXRoIHdyb25nIHRhZyBjYXNlKVxuICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSAnZmVuJykge1xuICAgICAgICAgICAgICAgIGZlbiA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGUgcGVybWlzc2l2ZSBwYXJzZXIgc2hvdWxkIGF0dGVtcHQgdG8gbG9hZCBhIGZlbiB0YWcsIGV2ZW4gaWYgaXQncyB0aGVcbiAgICAgICAgICogd3JvbmcgY2FzZSBhbmQgZG9lc24ndCBpbmNsdWRlIGEgY29ycmVzcG9uZGluZyBbU2V0VXAgXCIxXCJdIHRhZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoZmVuLCB7IHByZXNlcnZlSGVhZGVyczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBzdHJpY3QgcGFyc2VyIC0gbG9hZCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaW5kaWNhdGVkIGJ5IFtTZXR1cCAnMSddXG4gICAgICAgICAgICAgKiBhbmQgW0ZFTiBwb3NpdGlvbl1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1NldFVwJ10gPT09ICcxJykge1xuICAgICAgICAgICAgICAgIGlmICghKCdGRU4nIGluIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQR046IEZFTiB0YWcgbXVzdCBiZSBzdXBwbGllZCB3aXRoIFNldFVwIHRhZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjbGVhciB0aGUgaGVhZGVycyB3aGVuIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoaGVhZGVyc1snRkVOJ10sIHsgcHJlc2VydmVIZWFkZXJzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIE5COiB0aGUgcmVnZXhlcyBiZWxvdyB0aGF0IGRlbGV0ZSBtb3ZlIG51bWJlcnMsIHJlY3Vyc2l2ZSBhbm5vdGF0aW9ucyxcbiAgICAgICAgICogYW5kIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgbWF5IGFsc28gbWF0Y2ggdGV4dCBpbiBjb21tZW50cy4gVG9cbiAgICAgICAgICogcHJldmVudCB0aGlzLCB3ZSB0cmFuc2Zvcm0gY29tbWVudHMgYnkgaGV4LWVuY29kaW5nIHRoZW0gaW4gcGxhY2UgYW5kXG4gICAgICAgICAqIGRlY29kaW5nIHRoZW0gYWdhaW4gYWZ0ZXIgdGhlIG90aGVyIHRva2VucyBoYXZlIGJlZW4gZGVsZXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hpbGUgdGhlIHNwZWMgc3RhdGVzIHRoYXQgUEdOIGZpbGVzIHNob3VsZCBiZSBBU0NJSSBlbmNvZGVkLCB3ZSB1c2VcbiAgICAgICAgICoge2VuLGRlfWNvZGVVUklDb21wb25lbnQgaGVyZSB0byBzdXBwb3J0IGFyYml0cmFyeSBVVEY4IGFzIGEgY29udmVuaWVuY2VcbiAgICAgICAgICogZm9yIG1vZGVybiB1c2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdG9IZXgocykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBlbmNvZGVVUkkgZG9lc24ndCB0cmFuc2Zvcm0gbW9zdCBBU0NJSSBjaGFyYWN0ZXJzLCBzbyB3ZSBoYW5kbGVcbiAgICAgICAgICAgICAgICAgKiB0aGVzZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIDwgMTI4XG4gICAgICAgICAgICAgICAgICAgID8gYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChjKS5yZXBsYWNlKC8lL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbUhleChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGggPT0gMFxuICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICA6IGRlY29kZVVSSUNvbXBvbmVudCgnJScgKyAocy5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKS5qb2luKCclJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZUNvbW1lbnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZUNoYXIpLCAnZycpLCAnICcpO1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0b0hleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpfX1gO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVDb21tZW50ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXJ0c1dpdGgoJ3snKSAmJiBzLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUhleChzLnNsaWNlKDEsIHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWxldGUgaGVhZGVyIHRvIGdldCB0aGUgbW92ZXNcbiAgICAgICAgbGV0IG1zID0gcGduXG4gICAgICAgICAgICAucmVwbGFjZShoZWFkZXJTdHJpbmcsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgIC8vIGVuY29kZSBjb21tZW50cyBzbyB0aGV5IGRvbid0IGdldCBkZWxldGVkIGJlbG93XG4gICAgICAgIG5ldyBSZWdFeHAoYCh7W159XSp9KSs/fDsoW14ke21hc2sobmV3bGluZUNoYXIpfV0qKWAsICdnJyksIGZ1bmN0aW9uIChfbWF0Y2gsIGJyYWNrZXQsIHNlbWljb2xvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJyYWNrZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZW5jb2RlQ29tbWVudChicmFja2V0KVxuICAgICAgICAgICAgICAgIDogJyAnICsgZW5jb2RlQ29tbWVudChgeyR7c2VtaWNvbG9uLnNsaWNlKDEpfX1gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhciksICdnJyksICcgJyk7XG4gICAgICAgIC8vIGRlbGV0ZSByZWN1cnNpdmUgYW5ub3RhdGlvbiB2YXJpYXRpb25zXG4gICAgICAgIGNvbnN0IHJhdlJlZ2V4ID0gLyhcXChbXigpXStcXCkpKz8vZztcbiAgICAgICAgd2hpbGUgKHJhdlJlZ2V4LnRlc3QobXMpKSB7XG4gICAgICAgICAgICBtcyA9IG1zLnJlcGxhY2UocmF2UmVnZXgsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgbW92ZSBudW1iZXJzXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFxkK1xcLihcXC5cXC4pPy9nLCAnJyk7XG4gICAgICAgIC8vIGRlbGV0ZSAuLi4gaW5kaWNhdGluZyBibGFjayB0byBtb3ZlXG4gICAgICAgIG1zID0gbXMucmVwbGFjZSgvXFwuXFwuXFwuL2csICcnKTtcbiAgICAgICAgLyogZGVsZXRlIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgKi9cbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXCRcXGQrL2csICcnKTtcbiAgICAgICAgLy8gdHJpbSBhbmQgZ2V0IGFycmF5IG9mIG1vdmVzXG4gICAgICAgIGxldCBtb3ZlcyA9IG1zLnRyaW0oKS5zcGxpdChuZXcgUmVnRXhwKC9cXHMrLykpO1xuICAgICAgICAvLyBkZWxldGUgZW1wdHkgZW50cmllc1xuICAgICAgICBtb3ZlcyA9IG1vdmVzLmZpbHRlcigobW92ZSkgPT4gbW92ZSAhPT0gJycpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGhhbGZNb3ZlID0gMDsgaGFsZk1vdmUgPCBtb3Zlcy5sZW5ndGg7IGhhbGZNb3ZlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSBkZWNvZGVDb21tZW50KG1vdmVzW2hhbGZNb3ZlXSk7XG4gICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX21vdmVGcm9tU2FuKG1vdmVzW2hhbGZNb3ZlXSwgc3RyaWN0KTtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbW92ZVxuICAgICAgICAgICAgaWYgKG1vdmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdhcyB0aGUgbW92ZSBhbiBlbmQgb2YgZ2FtZSBtYXJrZXJcbiAgICAgICAgICAgICAgICBpZiAoVEVSTUlOQVRJT05fTUFSS0VSUy5pbmRleE9mKG1vdmVzW2hhbGZNb3ZlXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb3Zlc1toYWxmTW92ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZSBpbiBQR046ICR7bW92ZXNbaGFsZk1vdmVdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBlbmQgb2YgZ2FtZSBtYXJrZXIgaWYgbWFraW5nIGEgdmFsaWQgbW92ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY1Bvc2l0aW9uQ291bnQodGhpcy5mZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogUGVyIHNlY3Rpb24gOC4yLjYgb2YgdGhlIFBHTiBzcGVjLCB0aGUgUmVzdWx0IHRhZyBwYWlyIG11c3QgbWF0Y2ggbWF0Y2hcbiAgICAgICAgICogdGhlIHRlcm1pbmF0aW9uIG1hcmtlci4gT25seSBkbyB0aGlzIHdoZW4gaGVhZGVycyBhcmUgcHJlc2VudCwgYnV0IHRoZVxuICAgICAgICAgKiByZXN1bHQgdGFnIGlzIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiYgIXRoaXMuX2hlYWRlclsnUmVzdWx0J10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCdSZXN1bHQnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQ29udmVydCBhIG1vdmUgZnJvbSAweDg4IGNvb3JkaW5hdGVzIHRvIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvblxuICAgICAqIChTQU4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cmljdCBVc2UgdGhlIHN0cmljdCBTQU4gcGFyc2VyLiBJdCB3aWxsIHRocm93IGVycm9yc1xuICAgICAqIG9uIG92ZXJseSBkaXNhbWJpZ3VhdGVkIG1vdmVzIChzZWUgYmVsb3cpOlxuICAgICAqXG4gICAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XG4gICAgICogNC4gLi4uIE5nZTcgaXMgb3Zlcmx5IGRpc2FtYmlndWF0ZWQgYmVjYXVzZSB0aGUga25pZ2h0IG9uIGM2IGlzIHBpbm5lZFxuICAgICAqIDQuIC4uLiBOZTcgaXMgdGVjaG5pY2FsbHkgdGhlIHZhbGlkIFNBTlxuICAgICAqL1xuICAgIF9tb3ZlVG9TYW4obW92ZSwgbW92ZXMpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8tTyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGNvbnN0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpO1xuICAgICAgICBsZXQgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbGV0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBsZWdhbDogdHJ1ZSwgcGllY2U6IHBpZWNlVHlwZSB9KTtcbiAgICAgICAgLy8gc3RyaWN0IHBhcnNlclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09IHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc3RyaWN0IHBhcnNlciBmYWlsZWRcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpZWNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHByb21vdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGRlZmF1bHQgcGVybWlzc2l2ZSAobm9uLXN0cmljdCkgcGFyc2VyIGFsbG93cyB0aGUgdXNlciB0byBwYXJzZVxuICAgICAgICAgKiBub24tc3RhbmRhcmQgY2hlc3Mgbm90YXRpb25zLiBUaGlzIHBhcnNlciBpcyBvbmx5IHJ1biBhZnRlciB0aGUgc3RyaWN0XG4gICAgICAgICAqIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvbiAoU0FOKSBwYXJzZXIgaGFzIGZhaWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBydW5uaW5nIHRoZSBwZXJtaXNzaXZlIHBhcnNlciwgd2UnbGwgcnVuIGEgcmVnZXggdG8gZ3JhYiB0aGUgcGllY2UsIHRoZVxuICAgICAgICAgKiB0by9mcm9tIHNxdWFyZSwgYW5kIGFuIG9wdGlvbmFsIHByb21vdGlvbiBwaWVjZS4gVGhpcyByZWdleCB3aWxsXG4gICAgICAgICAqIHBhcnNlIGNvbW1vbiBub24tc3RhbmRhcmQgbm90YXRpb24gbGlrZTogUGUyLWU0LCBSYzFjNCwgUWYzeGY3LFxuICAgICAgICAgKiBmN2Y4cSwgYjFjM1xuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBTb21lIHBvc2l0aW9ucyBhbmQgbW92ZXMgbWF5IGJlIGFtYmlndW91cyB3aGVuIHVzaW5nIHRoZSBwZXJtaXNzaXZlXG4gICAgICAgICAqIHBhcnNlci4gRm9yIGV4YW1wbGUsIGluIHRoaXMgcG9zaXRpb246IDZrMS84LzgvQjcvOC84LzgvQk40SzEgdyAtIC0gMCAxLFxuICAgICAgICAgKiB0aGUgbW92ZSBiMWMzIG1heSBiZSBpbnRlcnByZXRlZCBhcyBOYzMgb3IgQjFjMyAoYSBkaXNhbWJpZ3VhdGVkIGJpc2hvcFxuICAgICAgICAgKiBtb3ZlKS4gSW4gdGhlc2UgY2FzZXMsIHRoZSBwZXJtaXNzaXZlIHBhcnNlciB3aWxsIGRlZmF1bHQgdG8gdGhlIG1vc3RcbiAgICAgICAgICogYmFzaWMgaW50ZXJwcmV0YXRpb24gKHdoaWNoIGlzIGIxYzMgcGFyc2luZyB0byBOYzMpLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG92ZXJseURpc2FtYmlndWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF1bMS04XSl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy8pO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgZnJvbSA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBUaGUgW2EtaF0/WzEtOF0/IHBvcnRpb24gb2YgdGhlIHJlZ2V4IGJlbG93IGhhbmRsZXMgbW92ZXMgdGhhdCBtYXkgYmVcbiAgICAgICAgICAgICAqIG92ZXJseSBkaXNhbWJpZ3VhdGVkIChlLmcuIE5nZTcgaXMgdW5uZWNlc3NhcnkgYW5kIG5vbi1zdGFuZGFyZCB3aGVuXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBvbmUgbGVnYWwga25pZ2h0IG1vdmUgdG8gZTcpLiBJbiB0aGlzIGNhc2UsIHRoZSB2YWx1ZSBvZlxuICAgICAgICAgICAgICogJ2Zyb20nIHZhcmlhYmxlIHdpbGwgYmUgYSByYW5rIG9yIGZpbGUsIG5vdCBhIHNxdWFyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF0/WzEtOF0/KXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/Lyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHBpZWNlID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgICAgICB0byA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgcHJvbW90aW9uID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybHlEaXNhbWJpZ3VhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7XG4gICAgICAgICAgICBsZWdhbDogdHJ1ZSxcbiAgICAgICAgICAgIHBpZWNlOiBwaWVjZSA/IHBpZWNlIDogcGllY2VUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmcm9tIHNxdWFyZSwgaXQgY291bGQgYmUganVzdCAneCcgbWlzc2luZyBmcm9tIGEgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKS5yZXBsYWNlKCd4JywgJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZC1jb21wYXJlIG1vdmUgcHJvcGVydGllcyB3aXRoIHRoZSByZXN1bHRzIGZyb20gb3VyIHBlcm1pc3NpdmUgcmVnZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgICAgICAgICBPeDg4W2Zyb21dID09IG1vdmVzW2ldLmZyb20gJiZcbiAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybHlEaXNhbWJpZ3VhdGVkKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTUEVDSUFMIENBU0U6IHdlIHBhcnNlZCBhIG1vdmUgc3RyaW5nIHRoYXQgbWF5IGhhdmUgYW4gdW5uZWVkZWRcbiAgICAgICAgICAgICAgICAgKiByYW5rL2ZpbGUgZGlzYW1iaWd1YXRvciAoZS5nLiBOZ2U3KS4gIFRoZSAnZnJvbScgdmFyaWFibGUgd2lsbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IGFsZ2VicmFpYyhtb3Zlc1tpXS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgICAgICBPeDg4W3RvXSA9PSBtb3Zlc1tpXS50byAmJlxuICAgICAgICAgICAgICAgICAgICAoZnJvbSA9PSBzcXVhcmVbMF0gfHwgZnJvbSA9PSBzcXVhcmVbMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICghcHJvbW90aW9uIHx8IHByb21vdGlvbi50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXNjaWkoKSB7XG4gICAgICAgIGxldCBzID0gJyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXFxuJztcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkaXNwbGF5IHRoZSByYW5rXG4gICAgICAgICAgICBpZiAoZmlsZShpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgJzg3NjU0MzIxJ1tyYW5rKGkpXSArICcgfCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl9ib2FyZFtpXS5jb2xvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBjb2xvciA9PT0gV0hJVEUgPyBwaWVjZS50b1VwcGVyQ2FzZSgpIDogcGllY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzICs9ICcgJyArIHN5bWJvbCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAuICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBzICs9ICd8XFxuJztcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBzICs9ICcgICAgIGEgIGIgIGMgIGQgIGUgIGYgIGcgIGgnO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcGVyZnQoZGVwdGgpIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiBmYWxzZSB9KTtcbiAgICAgICAgbGV0IG5vZGVzID0gMDtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLl90dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VNb3ZlKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNLaW5nQXR0YWNrZWQoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIC0gMSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgKz0gdGhpcy5wZXJmdChkZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm47XG4gICAgfVxuICAgIGJvYXJkKCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IHJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZTogYWxnZWJyYWljKGkpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9ib2FyZFtpXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fYm9hcmRbaV0uY29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBzcXVhcmVDb2xvcihzcXVhcmUpIHtcbiAgICAgICAgaWYgKHNxdWFyZSBpbiBPeDg4KSB7XG4gICAgICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgICAgIHJldHVybiAocmFuayhzcSkgKyBmaWxlKHNxKSkgJSAyID09PSAwID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGlzdG9yeSh7IHZlcmJvc2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IG1vdmVIaXN0b3J5ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG1vdmVIaXN0b3J5LnB1c2gobmV3IE1vdmUodGhpcywgbW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHBvc2l0aW9uIG9jY3VycmVuY2UgY291bnRzIGZvciB0aGUgcHVycG9zZSBvZiByZXBldGl0aW9uXG4gICAgICogY2hlY2tpbmcuIEFsbCB0aHJlZSBtZXRob2RzIChgX2luY2AsIGBfZGVjYCwgYW5kIGBfZ2V0YCkgdHJpbSB0aGVcbiAgICAgKiBpcnJlbGV2ZW50IGluZm9ybWF0aW9uIGZyb20gdGhlIGZlbiwgaW5pdGlhbGlzaW5nIG5ldyBwb3NpdGlvbnMsIGFuZFxuICAgICAqIHJlbW92aW5nIG9sZCBwb3NpdGlvbnMgZnJvbSB0aGUgcmVjb3JkIGlmIHRoZWlyIGNvdW50cyBhcmUgcmVkdWNlZCB0byAwLlxuICAgICAqL1xuICAgIF9nZXRQb3NpdGlvbkNvdW50KGZlbikge1xuICAgICAgICBjb25zdCB0cmltbWVkRmVuID0gdHJpbUZlbihmZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSB8fCAwO1xuICAgIH1cbiAgICBfaW5jUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSArPSAxO1xuICAgIH1cbiAgICBfZGVjUG9zaXRpb25Db3VudChmZW4pIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZEZlbiA9IHRyaW1GZW4oZmVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uQ291bnRbdHJpbW1lZEZlbl0gPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3NpdGlvbkNvdW50W3RyaW1tZWRGZW5dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Db3VudFt0cmltbWVkRmVuXSAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcnVuZUNvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbW1lbnRzID0ge307XG4gICAgICAgIGNvbnN0IGNvcHlDb21tZW50ID0gKGZlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGZlbiBpbiB0aGlzLl9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb21tZW50c1tmZW5dID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weUNvbW1lbnQodGhpcy5mZW4oKSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gcmV2ZXJzZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbW1lbnRzID0gY3VycmVudENvbW1lbnRzO1xuICAgIH1cbiAgICBnZXRDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgfVxuICAgIHNldENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQucmVwbGFjZSgneycsICdbJykucmVwbGFjZSgnfScsICddJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgdG8gYHJlbW92ZUNvbW1lbnRgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICBnZXRDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUmVuYW1lZCB0byBgcmVtb3ZlQ29tbWVudHNgIGZvciBjb25zaXN0ZW5jeVxuICAgICAqL1xuICAgIGRlbGV0ZUNvbW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21tZW50cygpO1xuICAgIH1cbiAgICByZW1vdmVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAoKHJpZ2h0c1tLSU5HXSA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0c1tLSU5HXSA9PT0gcmVzdWx0W0tJTkddKSAmJlxuICAgICAgICAgICAgKHJpZ2h0c1tRVUVFTl0gPT09IHVuZGVmaW5lZCB8fCByaWdodHNbUVVFRU5dID09PSByZXN1bHRbUVVFRU5dKSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chess.js/dist/esm/chess.js\n"));

/***/ }),

/***/ "./src/components/EscrowPanel.tsx":
/*!****************************************!*\
  !*** ./src/components/EscrowPanel.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contracts/EscrowContractAdapter */ \"./src/contracts/EscrowContractAdapter.ts\");\n\n\n\nconst EscrowPanel = (param)=>{\n    let { escrowAddress, escrowStatus, escrowBalance, useSimulationMode, setUseSimulationMode, onConnectEscrowWallet, onDisconnectEscrow, onCreateSimulatedEscrow, onInitializeEscrow, onResetGame, onResetWallets } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"mt-8 p-4 bg-gray-200 rounded\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"text-lg font-bold mb-2\",\n                children: \"Contract Status\"\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                lineNumber: 34,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                        children: \"Escrow Address:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 37,\n                                        columnNumber: 14\n                                    }, undefined),\n                                    \" \",\n                                    escrowAddress || \"Not connected\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 37,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                        children: \"Status:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 38,\n                                        columnNumber: 14\n                                    }, undefined),\n                                    \" \",\n                                    _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_2__.EscrowStatus[escrowStatus]\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 38,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                        children: \"Escrow Balance:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 39,\n                                        columnNumber: 14\n                                    }, undefined),\n                                    \" \",\n                                    escrowBalance,\n                                    \" APT\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                        className: \"font-bold text-indigo-800\",\n                                        children: \"Escrow Wallet\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 43,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    escrowAddress ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-indigo-700\",\n                                                children: \"Escrow wallet connected:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 46,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"font-mono text-sm mt-1\",\n                                                children: escrowAddress\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 47,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"mt-2 bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm\",\n                                                onClick: onDisconnectEscrow,\n                                                children: \"Disconnect Escrow\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 48,\n                                                columnNumber: 17\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 45,\n                                        columnNumber: 15\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-indigo-700 mb-2\",\n                                                children: \"Connect your escrow wallet:\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 57,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded w-full\",\n                                                onClick: onConnectEscrowWallet,\n                                                disabled: useSimulationMode,\n                                                children: \"Connect Escrow Wallet\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 58,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-xs text-indigo-600 mt-1\",\n                                                children: \"The escrow wallet will hold funds during the game and distribute to the winner.\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 65,\n                                                columnNumber: 17\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 56,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 42,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4 p-2 bg-blue-50 border border-blue-200 rounded\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-blue-800 font-medium\",\n                                        children: \"3-Wallet Setup Instructions:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 74,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                        className: \"list-decimal list-inside text-blue-700 pl-2 text-sm space-y-1 mt-1\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                children: \"Connect Player 1 wallet first\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 76,\n                                                columnNumber: 15\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                children: \"Connect Player 2 wallet second (make sure to switch to a different wallet in Petra)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 77,\n                                                columnNumber: 15\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                children: \"Connect the Escrow wallet third (should be a separate wallet from both players)\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 78,\n                                                columnNumber: 15\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                children: \"Place bets and lock escrow to start the game\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 79,\n                                                columnNumber: 15\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                children: \"After game completes, the escrow wallet will pay the winner\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                                lineNumber: 80,\n                                                columnNumber: 15\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 75,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 73,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                        lineNumber: 36,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"checkbox\",\n                                        id: \"simulationMode\",\n                                        checked: useSimulationMode,\n                                        onChange: (e)=>setUseSimulationMode(e.target.checked),\n                                        className: \"mr-2\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        htmlFor: \"simulationMode\",\n                                        children: \"Simulation Mode (No real transactions)\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 93,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 85,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-gray-600 mt-1\",\n                                children: \"Enable simulation mode to test the game flow without actual blockchain transactions.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 95,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4 grid grid-cols-2 gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded\",\n                                        onClick: onInitializeEscrow,\n                                        disabled: useSimulationMode,\n                                        children: \"Initialize Escrow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 99,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-green-500 hover:bg-green-600 text-white px-3 py-2 rounded\",\n                                        onClick: onCreateSimulatedEscrow,\n                                        disabled: !useSimulationMode,\n                                        children: \"Create Simulated Escrow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 106,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded\",\n                                        onClick: onResetGame,\n                                        children: \"Reset Game\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 113,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-2 rounded\",\n                                        onClick: onResetWallets,\n                                        children: \"Reset All Wallets\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                        lineNumber: 119,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                                lineNumber: 98,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                        lineNumber: 84,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/EscrowPanel.tsx\",\n        lineNumber: 33,\n        columnNumber: 5\n    }, undefined);\n};\n_c = EscrowPanel;\n/* harmony default export */ __webpack_exports__[\"default\"] = (EscrowPanel);\nvar _c;\n$RefreshReg$(_c, \"EscrowPanel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c3JjL2NvbXBvbmVudHMvRXNjcm93UGFuZWwudHN4P2U4NTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVzY3Jvd1N0YXR1cyB9IGZyb20gJy4uL2NvbnRyYWN0cy9Fc2Nyb3dDb250cmFjdEFkYXB0ZXInO1xuaW1wb3J0IHsgZm9ybWF0V2FsbGV0QWRkcmVzcyB9IGZyb20gJy4uL3V0aWxzL3RyYW5zYWN0aW9ucyc7XG5cbmludGVyZmFjZSBFc2Nyb3dQYW5lbFByb3BzIHtcbiAgZXNjcm93QWRkcmVzczogc3RyaW5nIHwgbnVsbDtcbiAgZXNjcm93U3RhdHVzOiBFc2Nyb3dTdGF0dXM7XG4gIGVzY3Jvd0JhbGFuY2U6IG51bWJlcjtcbiAgdXNlU2ltdWxhdGlvbk1vZGU6IGJvb2xlYW47XG4gIHNldFVzZVNpbXVsYXRpb25Nb2RlOiAobW9kZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgb25Db25uZWN0RXNjcm93V2FsbGV0OiAoKSA9PiB2b2lkO1xuICBvbkRpc2Nvbm5lY3RFc2Nyb3c6ICgpID0+IHZvaWQ7XG4gIG9uQ3JlYXRlU2ltdWxhdGVkRXNjcm93OiAoKSA9PiB2b2lkO1xuICBvbkluaXRpYWxpemVFc2Nyb3c6ICgpID0+IHZvaWQ7XG4gIG9uUmVzZXRHYW1lOiAoKSA9PiB2b2lkO1xuICBvblJlc2V0V2FsbGV0czogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgRXNjcm93UGFuZWw6IFJlYWN0LkZDPEVzY3Jvd1BhbmVsUHJvcHM+ID0gKHtcbiAgZXNjcm93QWRkcmVzcyxcbiAgZXNjcm93U3RhdHVzLFxuICBlc2Nyb3dCYWxhbmNlLFxuICB1c2VTaW11bGF0aW9uTW9kZSxcbiAgc2V0VXNlU2ltdWxhdGlvbk1vZGUsXG4gIG9uQ29ubmVjdEVzY3Jvd1dhbGxldCxcbiAgb25EaXNjb25uZWN0RXNjcm93LFxuICBvbkNyZWF0ZVNpbXVsYXRlZEVzY3JvdyxcbiAgb25Jbml0aWFsaXplRXNjcm93LFxuICBvblJlc2V0R2FtZSxcbiAgb25SZXNldFdhbGxldHNcbn0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTggcC00IGJnLWdyYXktMjAwIHJvdW5kZWRcIj5cbiAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+Q29udHJhY3QgU3RhdHVzPC9oMz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtNFwiPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxwPjxzdHJvbmc+RXNjcm93IEFkZHJlc3M6PC9zdHJvbmc+IHtlc2Nyb3dBZGRyZXNzIHx8ICdOb3QgY29ubmVjdGVkJ308L3A+XG4gICAgICAgICAgPHA+PHN0cm9uZz5TdGF0dXM6PC9zdHJvbmc+IHtFc2Nyb3dTdGF0dXNbZXNjcm93U3RhdHVzXX08L3A+XG4gICAgICAgICAgPHA+PHN0cm9uZz5Fc2Nyb3cgQmFsYW5jZTo8L3N0cm9uZz4ge2VzY3Jvd0JhbGFuY2V9IEFQVDwvcD5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogRXNjcm93IHdhbGxldCBjb25uZWN0aW9uIHBhbmVsICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTQgYmctaW5kaWdvLTUwIGJvcmRlciBib3JkZXItaW5kaWdvLTIwMCByb3VuZGVkXCI+XG4gICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1ib2xkIHRleHQtaW5kaWdvLTgwMFwiPkVzY3JvdyBXYWxsZXQ8L2g0PlxuICAgICAgICAgICAge2VzY3Jvd0FkZHJlc3MgPyAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMlwiPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTcwMFwiPkVzY3JvdyB3YWxsZXQgY29ubmVjdGVkOjwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LW1vbm8gdGV4dC1zbSBtdC0xXCI+e2VzY3Jvd0FkZHJlc3N9PC9wPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTIgYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0xIHJvdW5kZWQgdGV4dC1zbVwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkRpc2Nvbm5lY3RFc2Nyb3d9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgRGlzY29ubmVjdCBFc2Nyb3dcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWluZGlnby03MDAgbWItMlwiPkNvbm5lY3QgeW91ciBlc2Nyb3cgd2FsbGV0OjwvcD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNjAwIGhvdmVyOmJnLWluZGlnby03MDAgdGV4dC13aGl0ZSBweC0zIHB5LTIgcm91bmRlZCB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17b25Db25uZWN0RXNjcm93V2FsbGV0fVxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3VzZVNpbXVsYXRpb25Nb2RlfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENvbm5lY3QgRXNjcm93IFdhbGxldFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1pbmRpZ28tNjAwIG10LTFcIj5cbiAgICAgICAgICAgICAgICAgIFRoZSBlc2Nyb3cgd2FsbGV0IHdpbGwgaG9sZCBmdW5kcyBkdXJpbmcgdGhlIGdhbWUgYW5kIGRpc3RyaWJ1dGUgdG8gdGhlIHdpbm5lci5cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogV2FsbGV0IENvbm5lY3Rpb24gVGlwcyAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC0yIGJnLWJsdWUtNTAgYm9yZGVyIGJvcmRlci1ibHVlLTIwMCByb3VuZGVkXCI+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWJsdWUtODAwIGZvbnQtbWVkaXVtXCI+My1XYWxsZXQgU2V0dXAgSW5zdHJ1Y3Rpb25zOjwvcD5cbiAgICAgICAgICAgIDxvbCBjbGFzc05hbWU9XCJsaXN0LWRlY2ltYWwgbGlzdC1pbnNpZGUgdGV4dC1ibHVlLTcwMCBwbC0yIHRleHQtc20gc3BhY2UteS0xIG10LTFcIj5cbiAgICAgICAgICAgICAgPGxpPkNvbm5lY3QgUGxheWVyIDEgd2FsbGV0IGZpcnN0PC9saT5cbiAgICAgICAgICAgICAgPGxpPkNvbm5lY3QgUGxheWVyIDIgd2FsbGV0IHNlY29uZCAobWFrZSBzdXJlIHRvIHN3aXRjaCB0byBhIGRpZmZlcmVudCB3YWxsZXQgaW4gUGV0cmEpPC9saT5cbiAgICAgICAgICAgICAgPGxpPkNvbm5lY3QgdGhlIEVzY3JvdyB3YWxsZXQgdGhpcmQgKHNob3VsZCBiZSBhIHNlcGFyYXRlIHdhbGxldCBmcm9tIGJvdGggcGxheWVycyk8L2xpPlxuICAgICAgICAgICAgICA8bGk+UGxhY2UgYmV0cyBhbmQgbG9jayBlc2Nyb3cgdG8gc3RhcnQgdGhlIGdhbWU8L2xpPlxuICAgICAgICAgICAgICA8bGk+QWZ0ZXIgZ2FtZSBjb21wbGV0ZXMsIHRoZSBlc2Nyb3cgd2FsbGV0IHdpbGwgcGF5IHRoZSB3aW5uZXI8L2xpPlxuICAgICAgICAgICAgPC9vbD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgIGlkPVwic2ltdWxhdGlvbk1vZGVcIlxuICAgICAgICAgICAgICBjaGVja2VkPXt1c2VTaW11bGF0aW9uTW9kZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRVc2VTaW11bGF0aW9uTW9kZShlLnRhcmdldC5jaGVja2VkKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXItMlwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJzaW11bGF0aW9uTW9kZVwiPlNpbXVsYXRpb24gTW9kZSAoTm8gcmVhbCB0cmFuc2FjdGlvbnMpPC9sYWJlbD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDAgbXQtMVwiPlxuICAgICAgICAgICAgRW5hYmxlIHNpbXVsYXRpb24gbW9kZSB0byB0ZXN0IHRoZSBnYW1lIGZsb3cgd2l0aG91dCBhY3R1YWwgYmxvY2tjaGFpbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBncmlkIGdyaWQtY29scy0yIGdhcC0yXCI+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCBob3ZlcjpiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlIHB4LTMgcHktMiByb3VuZGVkXCJcbiAgICAgICAgICAgICAgb25DbGljaz17b25Jbml0aWFsaXplRXNjcm93fVxuICAgICAgICAgICAgICBkaXNhYmxlZD17dXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIEluaXRpYWxpemUgRXNjcm93XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIGhvdmVyOmJnLWdyZWVuLTYwMCB0ZXh0LXdoaXRlIHB4LTMgcHktMiByb3VuZGVkXCJcbiAgICAgICAgICAgICAgb25DbGljaz17b25DcmVhdGVTaW11bGF0ZWRFc2Nyb3d9XG4gICAgICAgICAgICAgIGRpc2FibGVkPXshdXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENyZWF0ZSBTaW11bGF0ZWQgRXNjcm93XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcmVkLTUwMCBob3ZlcjpiZy1yZWQtNjAwIHRleHQtd2hpdGUgcHgtMyBweS0yIHJvdW5kZWRcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtvblJlc2V0R2FtZX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgUmVzZXQgR2FtZVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXllbGxvdy01MDAgaG92ZXI6YmcteWVsbG93LTYwMCB0ZXh0LXdoaXRlIHB4LTMgcHktMiByb3VuZGVkXCJcbiAgICAgICAgICAgICAgb25DbGljaz17b25SZXNldFdhbGxldHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFJlc2V0IEFsbCBXYWxsZXRzXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVzY3Jvd1BhbmVsOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJFc2Nyb3dTdGF0dXMiLCJFc2Nyb3dQYW5lbCIsImVzY3Jvd0FkZHJlc3MiLCJlc2Nyb3dTdGF0dXMiLCJlc2Nyb3dCYWxhbmNlIiwidXNlU2ltdWxhdGlvbk1vZGUiLCJzZXRVc2VTaW11bGF0aW9uTW9kZSIsIm9uQ29ubmVjdEVzY3Jvd1dhbGxldCIsIm9uRGlzY29ubmVjdEVzY3JvdyIsIm9uQ3JlYXRlU2ltdWxhdGVkRXNjcm93Iiwib25Jbml0aWFsaXplRXNjcm93Iiwib25SZXNldEdhbWUiLCJvblJlc2V0V2FsbGV0cyIsImRpdiIsImNsYXNzTmFtZSIsImgzIiwicCIsInN0cm9uZyIsImg0IiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwib2wiLCJsaSIsImlucHV0IiwidHlwZSIsImlkIiwiY2hlY2tlZCIsIm9uQ2hhbmdlIiwiZSIsInRhcmdldCIsImxhYmVsIiwiaHRtbEZvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/EscrowPanel.tsx\n"));

/***/ }),

/***/ "./src/components/LoadingComponent.tsx":
/*!*********************************************!*\
  !*** ./src/components/LoadingComponent.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst LoadingComponent = (param)=>{\n    let { message = \"Loading...\" } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center justify-center p-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4\"\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/LoadingComponent.tsx\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-gray-700\",\n                children: message\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/LoadingComponent.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/components/LoadingComponent.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, undefined);\n};\n_c = LoadingComponent;\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoadingComponent);\nvar _c;\n$RefreshReg$(_c, \"LoadingComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nQ29tcG9uZW50LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFNMUIsTUFBTUMsbUJBQW9EO1FBQUMsRUFDekRDLFVBQVUsWUFBWSxFQUN2QjtJQUNDLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7Ozs7OzswQkFDZiw4REFBQ0M7Z0JBQUVELFdBQVU7MEJBQWlCRjs7Ozs7Ozs7Ozs7O0FBR3BDO0tBVE1EO0FBV04sK0RBQWVBLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Mb2FkaW5nQ29tcG9uZW50LnRzeD80YzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBMb2FkaW5nQ29tcG9uZW50UHJvcHMge1xuICBtZXNzYWdlPzogc3RyaW5nO1xufVxuXG5jb25zdCBMb2FkaW5nQ29tcG9uZW50OiBSZWFjdC5GQzxMb2FkaW5nQ29tcG9uZW50UHJvcHM+ID0gKHsgXG4gIG1lc3NhZ2UgPSAnTG9hZGluZy4uLidcbn0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtNlwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXNwaW4gcm91bmRlZC1mdWxsIGgtMTIgdy0xMiBib3JkZXItYi0yIGJvcmRlci1wcmltYXJ5IG1iLTRcIj48L2Rpdj5cbiAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS03MDBcIj57bWVzc2FnZX08L3A+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2FkaW5nQ29tcG9uZW50OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJMb2FkaW5nQ29tcG9uZW50IiwibWVzc2FnZSIsImRpdiIsImNsYXNzTmFtZSIsInAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/LoadingComponent.tsx\n"));

/***/ }),

/***/ "./src/contracts/EscrowContractAdapter.ts":
/*!************************************************!*\
  !*** ./src/contracts/EscrowContractAdapter.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DisputeResolution: function() { return /* binding */ DisputeResolution; },\n/* harmony export */   EscrowContractAdapter: function() { return /* binding */ EscrowContractAdapter; },\n/* harmony export */   EscrowStatus: function() { return /* binding */ EscrowStatus; }\n/* harmony export */ });\n/* harmony import */ var aptos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aptos */ \"./node_modules/aptos/dist/index.mjs\");\n\nvar EscrowStatus;\n(function(EscrowStatus) {\n    EscrowStatus[EscrowStatus[\"PENDING\"] = 0] = \"PENDING\";\n    EscrowStatus[EscrowStatus[\"FUNDED\"] = 1] = \"FUNDED\";\n    EscrowStatus[EscrowStatus[\"PLAYING\"] = 2] = \"PLAYING\";\n    EscrowStatus[EscrowStatus[\"COMPLETED\"] = 3] = \"COMPLETED\";\n    EscrowStatus[EscrowStatus[\"DISPUTED\"] = 4] = \"DISPUTED\";\n    EscrowStatus[EscrowStatus[\"CANCELLED\"] = 5] = \"CANCELLED\";\n    EscrowStatus[EscrowStatus[\"TIMED_OUT\"] = 6] = \"TIMED_OUT\";\n})(EscrowStatus || (EscrowStatus = {}));\n// Class to interface with the chess escrow contract on Aptos\nclass EscrowContractAdapter {\n    // Set the escrow contract address\n    setEscrowAddress(address) {\n        console.log(\"Setting escrow address to: \".concat(address));\n        this.escrowAddress = address;\n    }\n    // Get the escrow address\n    getEscrowAddress() {\n        return this.escrowAddress;\n    }\n    // Initialize a new escrow contract using any wallet\n    async initializeEscrow(sender, player1Address, player2Address, minimumBet) {\n        let timeoutSeconds = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 24 * 60 * 60;\n        try {\n            // Convert APT to octas (smallest unit) - 1 APT = 10^8 Octas\n            const minimumBetOctas = (minimumBet * 100000000).toString();\n            // Get the wallet address to set as escrow (could be a completely new wallet)\n            let walletAddress;\n            // Try different wallet API styles to get the address\n            if (sender.account) {\n                // Standard Petra wallet\n                const response = await sender.account();\n                walletAddress = response.address;\n            } else if ( true && window.aptos) {\n                // window.aptos API\n                const response = await window.aptos.connect();\n                walletAddress = response.address;\n            } else {\n                throw new Error(\"Could not determine wallet address\");\n            }\n            console.log(\"Using wallet as escrow: \".concat(walletAddress));\n            // Use the moduleAddress as the arbiter for simplicity\n            const arbiterAddress = this.moduleAddress;\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::chess_escrow::create_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    player1Address,\n                    player2Address,\n                    minimumBetOctas,\n                    arbiterAddress,\n                    timeoutSeconds.toString()\n                ]\n            };\n            console.log(\"Initializing escrow with payload:\", JSON.stringify(payload, null, 2));\n            const txResponse = await this.submitTransaction(sender, payload);\n            if (txResponse && txResponse.hash) {\n                // Set the escrow address to the wallet address that initialized it\n                this.escrowAddress = walletAddress;\n                console.log(\"Escrow initialized with address: \".concat(walletAddress));\n                console.log(\"Transaction hash: \".concat(txResponse.hash));\n                return walletAddress;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            throw error;\n        }\n    }\n    // Deposit funds into the escrow\n    async deposit(sender, amount) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            // Convert APT to octas\n            const amountInOctas = (amount * 100000000).toString();\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::deposit\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    amountInOctas\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error depositing to escrow:\", error);\n            throw error;\n        }\n    }\n    // Sign to start the game\n    async signToStartGame(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::sign_to_start_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error signing to start game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game with a winner - includes automatic fund release\n    async completeGame(sender, winnerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        console.log(\"Completing game with winner: \".concat(winnerAddress));\n        console.log(\"Using escrow address: \".concat(this.escrowAddress));\n        try {\n            // Verify wallet connection\n            if ( true && window.aptos) {\n                const walletInfo = await window.aptos.connect();\n                console.log(\"Connected wallet for transaction: \".concat(walletInfo.address));\n            }\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::complete_game\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    winnerAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            // Automatically release funds without requiring approval\n            if (response && response.hash) {\n                console.log(\"Game completed, funds will be automatically transferred to the winner\");\n                console.log(\"Transaction hash:\", response.hash);\n                // Wait for the transaction to be confirmed before releasing funds\n                await this.client.waitForTransactionWithResult(response.hash);\n                try {\n                    await this.releaseFunds(sender);\n                } catch (error) {\n                    console.error(\"Error releasing funds automatically, may need manual release:\", error);\n                }\n            }\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game:\", error);\n            throw error;\n        }\n    }\n    // Complete the game as a draw - includes automatic fund release\n    async completeGameAsDraw(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        console.log(\"Completing game as draw\");\n        console.log(\"Using escrow address: \".concat(this.escrowAddress));\n        try {\n            // Verify wallet connection\n            if ( true && window.aptos) {\n                const walletInfo = await window.aptos.connect();\n                console.log(\"Connected wallet for transaction: \".concat(walletInfo.address));\n            }\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::complete_game_as_draw\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            // Automatically release funds without requiring approval\n            if (response && response.hash) {\n                console.log(\"Game completed as draw, funds will be automatically returned to players\");\n                console.log(\"Transaction hash:\", response.hash);\n                // Wait for the transaction to be confirmed before releasing funds\n                await this.client.waitForTransactionWithResult(response.hash);\n                try {\n                    await this.releaseFunds(sender);\n                } catch (error) {\n                    console.error(\"Error releasing funds automatically, may need manual release:\", error);\n                }\n            }\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error completing game as draw:\", error);\n            throw error;\n        }\n    }\n    // Release funds to the winner or back to players in case of a draw\n    async releaseFunds(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::release_funds\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            // This transaction doesn't require approval - it's automated\n            const response = await this.submitTransaction(sender, payload);\n            console.log(\"Funds released to the appropriate recipient(s)\");\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error releasing funds:\", error);\n            throw error;\n        }\n    }\n    // Raise a dispute\n    async raiseDispute(sender, reason) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::raise_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    reason\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error raising dispute:\", error);\n            throw error;\n        }\n    }\n    // Resolve a dispute (arbiter only)\n    async resolveDispute(sender, resolution, resolutionNotes) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::resolve_dispute\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    resolution.toString(),\n                    resolutionNotes\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error resolving dispute:\", error);\n            throw error;\n        }\n    }\n    // Check if game has timed out\n    async checkTimeout(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::check_timeout\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error checking timeout:\", error);\n            throw error;\n        }\n    }\n    // Cancel the escrow\n    async cancelEscrow(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::cancel_escrow\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error cancelling escrow:\", error);\n            throw error;\n        }\n    }\n    // Refund after cancellation\n    async refundAfterCancellation(sender) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const payload = {\n                type: \"entry_function_payload\",\n                function: \"\".concat(this.moduleAddress, \"::escrow::refund_after_cancellation\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            };\n            const response = await this.submitTransaction(sender, payload);\n            return !!response && !!response.hash;\n        } catch (error) {\n            console.error(\"Error refunding after cancellation:\", error);\n            throw error;\n        }\n    }\n    //\n    // View functions (read-only contract calls)\n    //\n    // Get escrow status\n    async getEscrowStatus() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const resource = await this.client.getAccountResource(this.escrowAddress, \"\".concat(this.moduleAddress, \"::escrow::GameEscrow\"));\n            if (resource && resource.data) {\n                return resource.data.status;\n            }\n            throw new Error(\"Could not retrieve escrow status\");\n        } catch (error) {\n            console.error(\"Error getting escrow status:\", error);\n            throw error;\n        }\n    }\n    // Get winner address\n    async getWinner() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_winner\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<address>\n            // If Some(address), it will be an object with a vector\n            if (result && result.length > 0 && result[0]) {\n                return result[0];\n            }\n            return null; // None case (draw or not set)\n        } catch (error) {\n            console.error(\"Error getting winner:\", error);\n            throw error;\n        }\n    }\n    // Get escrow balance\n    async getEscrowBalance() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_escrow_balance\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting escrow balance:\", error);\n            throw error;\n        }\n    }\n    // Check if both deposits are complete\n    async areBothDepositsComplete() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::are_both_deposits_complete\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                return Boolean(result[0]);\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error checking deposits completion:\", error);\n            throw error;\n        }\n    }\n    // Get minimum bet\n    async getMinimumBet() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_minimum_bet\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting minimum bet:\", error);\n            throw error;\n        }\n    }\n    // Get player info\n    async getPlayerInfo(playerAddress) {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_player_info\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress,\n                    playerAddress\n                ]\n            });\n            if (result && result.length >= 3) {\n                return {\n                    hasDeposited: Boolean(result[0]),\n                    depositAmount: Number(result[1]) / 100000000,\n                    signedGameStart: Boolean(result[2])\n                };\n            }\n            throw new Error(\"Invalid player info result\");\n        } catch (error) {\n            console.error(\"Error getting player info:\", error);\n            throw error;\n        }\n    }\n    // Get total escrowed amount\n    async getTotalEscrowedAmount() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_total_escrowed_amount\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            if (result && result.length > 0) {\n                // Convert octas to APT\n                return Number(result[0]) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting total escrowed amount:\", error);\n            throw error;\n        }\n    }\n    // Get game time remaining\n    async getGameTimeRemaining() {\n        if (!this.escrowAddress) {\n            throw new Error(\"Escrow address not set\");\n        }\n        try {\n            const result = await this.client.view({\n                function: \"\".concat(this.moduleAddress, \"::escrow::get_game_time_remaining\"),\n                type_arguments: [],\n                arguments: [\n                    this.escrowAddress\n                ]\n            });\n            // The result will be an array with the Option<u64>\n            if (result && result.length > 0 && result[0]) {\n                return Number(result[0]);\n            }\n            return null; // None case (game not started or not in playing state)\n        } catch (error) {\n            console.error(\"Error getting game time remaining:\", error);\n            throw error;\n        }\n    }\n    // Helper method to submit a transaction\n    async submitTransaction(sender, payload) {\n        try {\n            // For direct wallet API (window.aptos) - try this first\n            if ( true && window.aptos) {\n                console.log(\"Using window.aptos wallet for transaction\");\n                return await window.aptos.signAndSubmitTransaction(payload);\n            }\n            // For Petra and similar wallets\n            if (sender && sender.signAndSubmitTransaction) {\n                console.log(\"Using provided wallet for transaction\");\n                return await sender.signAndSubmitTransaction(payload);\n            }\n            // If we get here, no compatible wallet was found\n            console.error(\"No compatible wallet found for transaction\");\n            throw new Error(\"No compatible wallet found\");\n        } catch (error) {\n            console.error(\"Transaction error:\", error);\n            throw error;\n        }\n    }\n    constructor(nodeUrl, moduleAddress){\n        this.escrowAddress = null;\n        this.client = new aptos__WEBPACK_IMPORTED_MODULE_0__.AptosClient(nodeUrl);\n        this.moduleAddress = moduleAddress;\n        // No longer setting escrow address to module address by default\n        console.log(\"Adapter created with module address:\", moduleAddress);\n    }\n}\nvar DisputeResolution;\n(function(DisputeResolution) {\n    DisputeResolution[DisputeResolution[\"DRAW\"] = 0] = \"DRAW\";\n    DisputeResolution[DisputeResolution[\"PLAYER1_WINS\"] = 1] = \"PLAYER1_WINS\";\n    DisputeResolution[DisputeResolution[\"PLAYER2_WINS\"] = 2] = \"PLAYER2_WINS\";\n    DisputeResolution[DisputeResolution[\"CANCEL\"] = 3] = \"CANCEL\";\n})(DisputeResolution || (DisputeResolution = {}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRTtnQkFDNUMsT0FBT0ksT0FBT0osTUFBTSxDQUFDLEVBQUU7WUFDekI7WUFFQSxPQUFPLE1BQU0sdURBQXVEO1FBQ3RFLEVBQUUsT0FBTzFCLE9BQU87WUFDZC9CLFFBQVErQixLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsTUFBY0Ysa0JBQ1p4QixNQUFXLEVBQ1hnQixPQUFZLEVBQ0U7UUFDZCxJQUFJO1lBQ0Ysd0RBQXdEO1lBQ3hELElBQUksS0FBa0IsSUFBZU4sT0FBT0MsS0FBSyxFQUFFO2dCQUNqRGhCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPLE1BQU1jLE9BQU9DLEtBQUssQ0FBQ3dELHdCQUF3QixDQUFDbkQ7WUFDckQ7WUFFQSxnQ0FBZ0M7WUFDaEMsSUFBSWhCLFVBQVVBLE9BQU9tRSx3QkFBd0IsRUFBRTtnQkFDN0N4RSxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTyxNQUFNSSxPQUFPbUUsd0JBQXdCLENBQUNuRDtZQUMvQztZQUVBLGlEQUFpRDtZQUNqRHJCLFFBQVErQixLQUFLLENBQUM7WUFDZCxNQUFNLElBQUliLE1BQU07UUFDbEIsRUFBRSxPQUFPYSxPQUFPO1lBQ2QvQixRQUFRK0IsS0FBSyxDQUFDLHNCQUFzQkE7WUFDcEMsTUFBTUE7UUFDUjtJQUNGO0lBbG5CQTBDLFlBQ0VDLE9BQWUsRUFDZnRELGFBQXFCLENBQ3JCO2FBTE1sQixnQkFBK0I7UUFNckMsSUFBSSxDQUFDcUMsTUFBTSxHQUFHLElBQUk1Qyw4Q0FBV0EsQ0FBQytFO1FBQzlCLElBQUksQ0FBQ3RELGFBQWEsR0FBR0E7UUFDckIsZ0VBQWdFO1FBQ2hFcEIsUUFBUUMsR0FBRyxDQUFDLHdDQUF3Q21CO0lBQ3REO0FBMm1CRjs7VUFHWXVEOzs7OztHQUFBQSxzQkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRyYWN0cy9Fc2Nyb3dDb250cmFjdEFkYXB0ZXIudHM/MTI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHRvc0NsaWVudCwgVHlwZXMsIFR4bkJ1aWxkZXJUeXBlcywgQkNTIH0gZnJvbSAnYXB0b3MnO1xuXG4vLyBFbnVtIGZvciBjb250cmFjdCBzdGF0ZXMgbWF0Y2hpbmcgdGhlIE1vdmUgY29udHJhY3RcbmV4cG9ydCBlbnVtIEVzY3Jvd1N0YXR1cyB7XG4gIFBFTkRJTkcgPSAwLFxuICBGVU5ERUQgPSAxLFxuICBQTEFZSU5HID0gMixcbiAgQ09NUExFVEVEID0gMyxcbiAgRElTUFVURUQgPSA0LFxuICBDQU5DRUxMRUQgPSA1LFxuICBUSU1FRF9PVVQgPSA2XG59XG5cbi8vIENsYXNzIHRvIGludGVyZmFjZSB3aXRoIHRoZSBjaGVzcyBlc2Nyb3cgY29udHJhY3Qgb24gQXB0b3NcbmV4cG9ydCBjbGFzcyBFc2Nyb3dDb250cmFjdEFkYXB0ZXIge1xuICBwcml2YXRlIGNsaWVudDogQXB0b3NDbGllbnQ7XG4gIHByaXZhdGUgbW9kdWxlQWRkcmVzczogc3RyaW5nO1xuICBwcml2YXRlIGVzY3Jvd0FkZHJlc3M6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgbm9kZVVybDogc3RyaW5nLFxuICAgIG1vZHVsZUFkZHJlc3M6IHN0cmluZywgLy8gUmVtb3ZlZCBkZWZhdWx0IHZhbHVlIC0gbXVzdCBiZSBwcm92aWRlZCBleHBsaWNpdGx5XG4gICkge1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IEFwdG9zQ2xpZW50KG5vZGVVcmwpO1xuICAgIHRoaXMubW9kdWxlQWRkcmVzcyA9IG1vZHVsZUFkZHJlc3M7XG4gICAgLy8gTm8gbG9uZ2VyIHNldHRpbmcgZXNjcm93IGFkZHJlc3MgdG8gbW9kdWxlIGFkZHJlc3MgYnkgZGVmYXVsdFxuICAgIGNvbnNvbGUubG9nKFwiQWRhcHRlciBjcmVhdGVkIHdpdGggbW9kdWxlIGFkZHJlc3M6XCIsIG1vZHVsZUFkZHJlc3MpO1xuICB9XG4gIFxuICAvLyBTZXQgdGhlIGVzY3JvdyBjb250cmFjdCBhZGRyZXNzXG4gIHB1YmxpYyBzZXRFc2Nyb3dBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKGBTZXR0aW5nIGVzY3JvdyBhZGRyZXNzIHRvOiAke2FkZHJlc3N9YCk7XG4gICAgdGhpcy5lc2Nyb3dBZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBcbiAgLy8gR2V0IHRoZSBlc2Nyb3cgYWRkcmVzc1xuICBwdWJsaWMgZ2V0RXNjcm93QWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5lc2Nyb3dBZGRyZXNzO1xuICB9XG4gIFxuICAvLyBJbml0aWFsaXplIGEgbmV3IGVzY3JvdyBjb250cmFjdCB1c2luZyBhbnkgd2FsbGV0XG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplRXNjcm93KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICBwbGF5ZXIxQWRkcmVzczogc3RyaW5nLFxuICAgIHBsYXllcjJBZGRyZXNzOiBzdHJpbmcsXG4gICAgbWluaW11bUJldDogbnVtYmVyLFxuICAgIHRpbWVvdXRTZWNvbmRzOiBudW1iZXIgPSAyNCAqIDYwICogNjAsIC8vIDI0IGhvdXJzIGluIHNlY29uZHNcbiAgKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgQVBUIHRvIG9jdGFzIChzbWFsbGVzdCB1bml0KSAtIDEgQVBUID0gMTBeOCBPY3Rhc1xuICAgICAgY29uc3QgbWluaW11bUJldE9jdGFzID0gKG1pbmltdW1CZXQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgd2FsbGV0IGFkZHJlc3MgdG8gc2V0IGFzIGVzY3JvdyAoY291bGQgYmUgYSBjb21wbGV0ZWx5IG5ldyB3YWxsZXQpXG4gICAgICBsZXQgd2FsbGV0QWRkcmVzcztcbiAgICAgIFxuICAgICAgLy8gVHJ5IGRpZmZlcmVudCB3YWxsZXQgQVBJIHN0eWxlcyB0byBnZXQgdGhlIGFkZHJlc3NcbiAgICAgIGlmIChzZW5kZXIuYWNjb3VudCkge1xuICAgICAgICAvLyBTdGFuZGFyZCBQZXRyYSB3YWxsZXRcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZW5kZXIuYWNjb3VudCgpO1xuICAgICAgICB3YWxsZXRBZGRyZXNzID0gcmVzcG9uc2UuYWRkcmVzcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFwdG9zKSB7XG4gICAgICAgIC8vIHdpbmRvdy5hcHRvcyBBUElcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICB3YWxsZXRBZGRyZXNzID0gcmVzcG9uc2UuYWRkcmVzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgd2FsbGV0IGFkZHJlc3NcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB3YWxsZXQgYXMgZXNjcm93OiAke3dhbGxldEFkZHJlc3N9YCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgbW9kdWxlQWRkcmVzcyBhcyB0aGUgYXJiaXRlciBmb3Igc2ltcGxpY2l0eVxuICAgICAgY29uc3QgYXJiaXRlckFkZHJlc3MgPSB0aGlzLm1vZHVsZUFkZHJlc3M7XG4gICAgICBcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6Y2hlc3NfZXNjcm93OjpjcmVhdGVfZXNjcm93YCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICBwbGF5ZXIxQWRkcmVzcyxcbiAgICAgICAgICBwbGF5ZXIyQWRkcmVzcyxcbiAgICAgICAgICBtaW5pbXVtQmV0T2N0YXMsXG4gICAgICAgICAgYXJiaXRlckFkZHJlc3MsXG4gICAgICAgICAgdGltZW91dFNlY29uZHMudG9TdHJpbmcoKVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBlc2Nyb3cgd2l0aCBwYXlsb2FkOlwiLCBKU09OLnN0cmluZ2lmeShwYXlsb2FkLCBudWxsLCAyKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHR4UmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGlmICh0eFJlc3BvbnNlICYmIHR4UmVzcG9uc2UuaGFzaCkge1xuICAgICAgICAvLyBTZXQgdGhlIGVzY3JvdyBhZGRyZXNzIHRvIHRoZSB3YWxsZXQgYWRkcmVzcyB0aGF0IGluaXRpYWxpemVkIGl0XG4gICAgICAgIHRoaXMuZXNjcm93QWRkcmVzcyA9IHdhbGxldEFkZHJlc3M7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFc2Nyb3cgaW5pdGlhbGl6ZWQgd2l0aCBhZGRyZXNzOiAke3dhbGxldEFkZHJlc3N9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcmFuc2FjdGlvbiBoYXNoOiAke3R4UmVzcG9uc2UuaGFzaH1gKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldEFkZHJlc3M7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBEZXBvc2l0IGZ1bmRzIGludG8gdGhlIGVzY3Jvd1xuICBwdWJsaWMgYXN5bmMgZGVwb3NpdChcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCBBUFQgdG8gb2N0YXNcbiAgICAgIGNvbnN0IGFtb3VudEluT2N0YXMgPSAoYW1vdW50ICogMTAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6ZGVwb3NpdGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzLCBhbW91bnRJbk9jdGFzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlcG9zaXRpbmcgdG8gZXNjcm93OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNpZ24gdG8gc3RhcnQgdGhlIGdhbWVcbiAgcHVibGljIGFzeW5jIHNpZ25Ub1N0YXJ0R2FtZShcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnNpZ25fdG9fc3RhcnRfZ2FtZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNpZ25pbmcgdG8gc3RhcnQgZ2FtZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDb21wbGV0ZSB0aGUgZ2FtZSB3aXRoIGEgd2lubmVyIC0gaW5jbHVkZXMgYXV0b21hdGljIGZ1bmQgcmVsZWFzZVxuICBwdWJsaWMgYXN5bmMgY29tcGxldGVHYW1lKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgICB3aW5uZXJBZGRyZXNzOiBzdHJpbmcsXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ29tcGxldGluZyBnYW1lIHdpdGggd2lubmVyOiAke3dpbm5lckFkZHJlc3N9YCk7XG4gICAgY29uc29sZS5sb2coYFVzaW5nIGVzY3JvdyBhZGRyZXNzOiAke3RoaXMuZXNjcm93QWRkcmVzc31gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZ5IHdhbGxldCBjb25uZWN0aW9uXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFwdG9zKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldEluZm8gPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHdhbGxldCBmb3IgdHJhbnNhY3Rpb246ICR7d2FsbGV0SW5mby5hZGRyZXNzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Y29tcGxldGVfZ2FtZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzLCB3aW5uZXJBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVsZWFzZSBmdW5kcyB3aXRob3V0IHJlcXVpcmluZyBhcHByb3ZhbFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIGNvbXBsZXRlZCwgZnVuZHMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZmVycmVkIHRvIHRoZSB3aW5uZXJcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNhY3Rpb24gaGFzaDpcIiwgcmVzcG9uc2UuaGFzaCk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkIGJlZm9yZSByZWxlYXNpbmcgZnVuZHNcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQud2FpdEZvclRyYW5zYWN0aW9uV2l0aFJlc3VsdChyZXNwb25zZS5oYXNoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlbGVhc2VGdW5kcyhzZW5kZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWxlYXNpbmcgZnVuZHMgYXV0b21hdGljYWxseSwgbWF5IG5lZWQgbWFudWFsIHJlbGVhc2U6XCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wbGV0aW5nIGdhbWU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ29tcGxldGUgdGhlIGdhbWUgYXMgYSBkcmF3IC0gaW5jbHVkZXMgYXV0b21hdGljIGZ1bmQgcmVsZWFzZVxuICBwdWJsaWMgYXN5bmMgY29tcGxldGVHYW1lQXNEcmF3KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDb21wbGV0aW5nIGdhbWUgYXMgZHJhd2ApO1xuICAgIGNvbnNvbGUubG9nKGBVc2luZyBlc2Nyb3cgYWRkcmVzczogJHt0aGlzLmVzY3Jvd0FkZHJlc3N9YCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFZlcmlmeSB3YWxsZXQgY29ubmVjdGlvblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hcHRvcykge1xuICAgICAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgY29uc29sZS5sb2coYENvbm5lY3RlZCB3YWxsZXQgZm9yIHRyYW5zYWN0aW9uOiAke3dhbGxldEluZm8uYWRkcmVzc31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmNvbXBsZXRlX2dhbWVfYXNfZHJhd2AsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVsZWFzZSBmdW5kcyB3aXRob3V0IHJlcXVpcmluZyBhcHByb3ZhbFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIGNvbXBsZXRlZCBhcyBkcmF3LCBmdW5kcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmV0dXJuZWQgdG8gcGxheWVyc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvbiBoYXNoOlwiLCByZXNwb25zZS5oYXNoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWQgYmVmb3JlIHJlbGVhc2luZyBmdW5kc1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC53YWl0Rm9yVHJhbnNhY3Rpb25XaXRoUmVzdWx0KHJlc3BvbnNlLmhhc2gpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVsZWFzZUZ1bmRzKHNlbmRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlbGVhc2luZyBmdW5kcyBhdXRvbWF0aWNhbGx5LCBtYXkgbmVlZCBtYW51YWwgcmVsZWFzZTpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbXBsZXRpbmcgZ2FtZSBhcyBkcmF3OlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFJlbGVhc2UgZnVuZHMgdG8gdGhlIHdpbm5lciBvciBiYWNrIHRvIHBsYXllcnMgaW4gY2FzZSBvZiBhIGRyYXdcbiAgcHVibGljIGFzeW5jIHJlbGVhc2VGdW5kcyhcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnJlbGVhc2VfZnVuZHNgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCByZXF1aXJlIGFwcHJvdmFsIC0gaXQncyBhdXRvbWF0ZWRcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgY29uc29sZS5sb2coXCJGdW5kcyByZWxlYXNlZCB0byB0aGUgYXBwcm9wcmlhdGUgcmVjaXBpZW50KHMpXCIpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWxlYXNpbmcgZnVuZHM6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmFpc2UgYSBkaXNwdXRlXG4gIHB1YmxpYyBhc3luYyByYWlzZURpc3B1dGUoXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHJlYXNvbjogc3RyaW5nLFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6ZXNjcm93OjpyYWlzZV9kaXNwdXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHJlYXNvbl1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByYWlzaW5nIGRpc3B1dGU6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gUmVzb2x2ZSBhIGRpc3B1dGUgKGFyYml0ZXIgb25seSlcbiAgcHVibGljIGFzeW5jIHJlc29sdmVEaXNwdXRlKFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2UgKGFyYml0ZXIpXG4gICAgcmVzb2x1dGlvbjogbnVtYmVyLCAvLyAwPWRyYXcsIDE9cGxheWVyMSB3aW5zLCAyPXBsYXllcjIgd2lucywgMz1jYW5jZWxcbiAgICByZXNvbHV0aW9uTm90ZXM6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6cmVzb2x2ZV9kaXNwdXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHJlc29sdXRpb24udG9TdHJpbmcoKSwgcmVzb2x1dGlvbk5vdGVzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlc29sdmluZyBkaXNwdXRlOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGlmIGdhbWUgaGFzIHRpbWVkIG91dFxuICBwdWJsaWMgYXN5bmMgY2hlY2tUaW1lb3V0KFxuICAgIHNlbmRlcjogYW55LCAvLyBXYWxsZXQgaW5zdGFuY2VcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Y2hlY2tfdGltZW91dGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFRyYW5zYWN0aW9uKHNlbmRlciwgcGF5bG9hZCk7XG4gICAgICBcbiAgICAgIHJldHVybiAhIXJlc3BvbnNlICYmICEhcmVzcG9uc2UuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIHRpbWVvdXQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FuY2VsIHRoZSBlc2Nyb3dcbiAgcHVibGljIGFzeW5jIGNhbmNlbEVzY3JvdyhcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmNhbmNlbF9lc2Nyb3dgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYW5jZWxsaW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBSZWZ1bmQgYWZ0ZXIgY2FuY2VsbGF0aW9uXG4gIHB1YmxpYyBhc3luYyByZWZ1bmRBZnRlckNhbmNlbGxhdGlvbihcbiAgICBzZW5kZXI6IGFueSwgLy8gV2FsbGV0IGluc3RhbmNlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgdHlwZTogXCJlbnRyeV9mdW5jdGlvbl9wYXlsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OnJlZnVuZF9hZnRlcl9jYW5jZWxsYXRpb25gLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbihzZW5kZXIsIHBheWxvYWQpO1xuICAgICAgXG4gICAgICByZXR1cm4gISFyZXNwb25zZSAmJiAhIXJlc3BvbnNlLmhhc2g7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWZ1bmRpbmcgYWZ0ZXIgY2FuY2VsbGF0aW9uOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vXG4gIC8vIFZpZXcgZnVuY3Rpb25zIChyZWFkLW9ubHkgY29udHJhY3QgY2FsbHMpXG4gIC8vXG4gIFxuICAvLyBHZXQgZXNjcm93IHN0YXR1c1xuICBwdWJsaWMgYXN5bmMgZ2V0RXNjcm93U3RhdHVzKCk6IFByb21pc2U8RXNjcm93U3RhdHVzPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IGF3YWl0IHRoaXMuY2xpZW50LmdldEFjY291bnRSZXNvdXJjZShcbiAgICAgICAgdGhpcy5lc2Nyb3dBZGRyZXNzLFxuICAgICAgICBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OkdhbWVFc2Nyb3dgXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAocmVzb3VyY2UgJiYgcmVzb3VyY2UuZGF0YSkge1xuICAgICAgICByZXR1cm4gKHJlc291cmNlLmRhdGEgYXMgYW55KS5zdGF0dXMgYXMgRXNjcm93U3RhdHVzO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmV0cmlldmUgZXNjcm93IHN0YXR1c1wiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZXNjcm93IHN0YXR1czpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgd2lubmVyIGFkZHJlc3NcbiAgcHVibGljIGFzeW5jIGdldFdpbm5lcigpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuZXNjcm93QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXNjcm93IGFkZHJlc3Mgbm90IHNldFwiKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnZpZXcoe1xuICAgICAgICBmdW5jdGlvbjogYCR7dGhpcy5tb2R1bGVBZGRyZXNzfTo6ZXNjcm93OjpnZXRfd2lubmVyYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IHdpdGggdGhlIE9wdGlvbjxhZGRyZXNzPlxuICAgICAgLy8gSWYgU29tZShhZGRyZXNzKSwgaXQgd2lsbCBiZSBhbiBvYmplY3Qgd2l0aCBhIHZlY3RvclxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbMF0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXSBhcyBzdHJpbmc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsOyAvLyBOb25lIGNhc2UgKGRyYXcgb3Igbm90IHNldClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgd2lubmVyOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEdldCBlc2Nyb3cgYmFsYW5jZVxuICBwdWJsaWMgYXN5bmMgZ2V0RXNjcm93QmFsYW5jZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF9lc2Nyb3dfYmFsYW5jZWAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHRbMF0pIC8gMTAwMDAwMDAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZXNjcm93IGJhbGFuY2U6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgYm90aCBkZXBvc2l0cyBhcmUgY29tcGxldGVcbiAgcHVibGljIGFzeW5jIGFyZUJvdGhEZXBvc2l0c0NvbXBsZXRlKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmFyZV9ib3RoX2RlcG9zaXRzX2NvbXBsZXRlYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihyZXN1bHRbMF0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBkZXBvc2l0cyBjb21wbGV0aW9uOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIEdldCBtaW5pbXVtIGJldFxuICBwdWJsaWMgYXN5bmMgZ2V0TWluaW11bUJldCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF9taW5pbXVtX2JldGAsXG4gICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXSxcbiAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5lc2Nyb3dBZGRyZXNzXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihyZXN1bHRbMF0pIC8gMTAwMDAwMDAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgbWluaW11bSBiZXQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHBsYXllciBpbmZvXG4gIHB1YmxpYyBhc3luYyBnZXRQbGF5ZXJJbmZvKHBsYXllckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGhhc0RlcG9zaXRlZDogYm9vbGVhbjtcbiAgICBkZXBvc2l0QW1vdW50OiBudW1iZXI7XG4gICAgc2lnbmVkR2FtZVN0YXJ0OiBib29sZWFuO1xuICB9PiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Z2V0X3BsYXllcl9pbmZvYCxcbiAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtdLFxuICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmVzY3Jvd0FkZHJlc3MsIHBsYXllckFkZHJlc3NdXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNEZXBvc2l0ZWQ6IEJvb2xlYW4ocmVzdWx0WzBdKSxcbiAgICAgICAgICBkZXBvc2l0QW1vdW50OiBOdW1iZXIocmVzdWx0WzFdKSAvIDEwMDAwMDAwMCwgLy8gQ29udmVydCBvY3RhcyB0byBBUFRcbiAgICAgICAgICBzaWduZWRHYW1lU3RhcnQ6IEJvb2xlYW4ocmVzdWx0WzJdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBsYXllciBpbmZvIHJlc3VsdFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgcGxheWVyIGluZm86XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IHRvdGFsIGVzY3Jvd2VkIGFtb3VudFxuICBwdWJsaWMgYXN5bmMgZ2V0VG90YWxFc2Nyb3dlZEFtb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5lc2Nyb3dBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFc2Nyb3cgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQudmlldyh7XG4gICAgICAgIGZ1bmN0aW9uOiBgJHt0aGlzLm1vZHVsZUFkZHJlc3N9Ojplc2Nyb3c6OmdldF90b3RhbF9lc2Nyb3dlZF9hbW91bnRgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIENvbnZlcnQgb2N0YXMgdG8gQVBUXG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0WzBdKSAvIDEwMDAwMDAwMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHRvdGFsIGVzY3Jvd2VkIGFtb3VudDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBHZXQgZ2FtZSB0aW1lIHJlbWFpbmluZ1xuICBwdWJsaWMgYXN5bmMgZ2V0R2FtZVRpbWVSZW1haW5pbmcoKTogUHJvbWlzZTxudW1iZXIgfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLmVzY3Jvd0FkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVzY3JvdyBhZGRyZXNzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC52aWV3KHtcbiAgICAgICAgZnVuY3Rpb246IGAke3RoaXMubW9kdWxlQWRkcmVzc306OmVzY3Jvdzo6Z2V0X2dhbWVfdGltZV9yZW1haW5pbmdgLFxuICAgICAgICB0eXBlX2FyZ3VtZW50czogW10sXG4gICAgICAgIGFyZ3VtZW50czogW3RoaXMuZXNjcm93QWRkcmVzc11cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgd2l0aCB0aGUgT3B0aW9uPHU2ND5cbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0WzBdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vbmUgY2FzZSAoZ2FtZSBub3Qgc3RhcnRlZCBvciBub3QgaW4gcGxheWluZyBzdGF0ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgZ2FtZSB0aW1lIHJlbWFpbmluZzpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBIZWxwZXIgbWV0aG9kIHRvIHN1Ym1pdCBhIHRyYW5zYWN0aW9uXG4gIHByaXZhdGUgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24oXG4gICAgc2VuZGVyOiBhbnksIC8vIFdhbGxldCBpbnN0YW5jZVxuICAgIHBheWxvYWQ6IGFueVxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3IgZGlyZWN0IHdhbGxldCBBUEkgKHdpbmRvdy5hcHRvcykgLSB0cnkgdGhpcyBmaXJzdFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hcHRvcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHdpbmRvdy5hcHRvcyB3YWxsZXQgZm9yIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIFBldHJhIGFuZCBzaW1pbGFyIHdhbGxldHNcbiAgICAgIGlmIChzZW5kZXIgJiYgc2VuZGVyLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIHByb3ZpZGVkIHdhbGxldCBmb3IgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kZXIuc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgbm8gY29tcGF0aWJsZSB3YWxsZXQgd2FzIGZvdW5kXG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gY29tcGF0aWJsZSB3YWxsZXQgZm91bmQgZm9yIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tcGF0aWJsZSB3YWxsZXQgZm91bmRcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUcmFuc2FjdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBhbiBlbnVtIGZvciBkaXNwdXRlIHJlc29sdXRpb24gY29kZXNcbmV4cG9ydCBlbnVtIERpc3B1dGVSZXNvbHV0aW9uIHtcbiAgRFJBVyA9IDAsXG4gIFBMQVlFUjFfV0lOUyA9IDEsXG4gIFBMQVlFUjJfV0lOUyA9IDIsXG4gIENBTkNFTCA9IDNcbn0gIl0sIm5hbWVzIjpbIkFwdG9zQ2xpZW50IiwiRXNjcm93U3RhdHVzIiwiRXNjcm93Q29udHJhY3RBZGFwdGVyIiwic2V0RXNjcm93QWRkcmVzcyIsImFkZHJlc3MiLCJjb25zb2xlIiwibG9nIiwiZXNjcm93QWRkcmVzcyIsImdldEVzY3Jvd0FkZHJlc3MiLCJpbml0aWFsaXplRXNjcm93Iiwic2VuZGVyIiwicGxheWVyMUFkZHJlc3MiLCJwbGF5ZXIyQWRkcmVzcyIsIm1pbmltdW1CZXQiLCJ0aW1lb3V0U2Vjb25kcyIsIm1pbmltdW1CZXRPY3RhcyIsInRvU3RyaW5nIiwid2FsbGV0QWRkcmVzcyIsImFjY291bnQiLCJyZXNwb25zZSIsIndpbmRvdyIsImFwdG9zIiwiY29ubmVjdCIsIkVycm9yIiwiYXJiaXRlckFkZHJlc3MiLCJtb2R1bGVBZGRyZXNzIiwicGF5bG9hZCIsInR5cGUiLCJmdW5jdGlvbiIsInR5cGVfYXJndW1lbnRzIiwiYXJndW1lbnRzIiwiSlNPTiIsInN0cmluZ2lmeSIsInR4UmVzcG9uc2UiLCJzdWJtaXRUcmFuc2FjdGlvbiIsImhhc2giLCJlcnJvciIsImRlcG9zaXQiLCJhbW91bnQiLCJhbW91bnRJbk9jdGFzIiwic2lnblRvU3RhcnRHYW1lIiwiY29tcGxldGVHYW1lIiwid2lubmVyQWRkcmVzcyIsIndhbGxldEluZm8iLCJjbGllbnQiLCJ3YWl0Rm9yVHJhbnNhY3Rpb25XaXRoUmVzdWx0IiwicmVsZWFzZUZ1bmRzIiwiY29tcGxldGVHYW1lQXNEcmF3IiwicmFpc2VEaXNwdXRlIiwicmVhc29uIiwicmVzb2x2ZURpc3B1dGUiLCJyZXNvbHV0aW9uIiwicmVzb2x1dGlvbk5vdGVzIiwiY2hlY2tUaW1lb3V0IiwiY2FuY2VsRXNjcm93IiwicmVmdW5kQWZ0ZXJDYW5jZWxsYXRpb24iLCJnZXRFc2Nyb3dTdGF0dXMiLCJyZXNvdXJjZSIsImdldEFjY291bnRSZXNvdXJjZSIsImRhdGEiLCJzdGF0dXMiLCJnZXRXaW5uZXIiLCJyZXN1bHQiLCJ2aWV3IiwibGVuZ3RoIiwiZ2V0RXNjcm93QmFsYW5jZSIsIk51bWJlciIsImFyZUJvdGhEZXBvc2l0c0NvbXBsZXRlIiwiQm9vbGVhbiIsImdldE1pbmltdW1CZXQiLCJnZXRQbGF5ZXJJbmZvIiwicGxheWVyQWRkcmVzcyIsImhhc0RlcG9zaXRlZCIsImRlcG9zaXRBbW91bnQiLCJzaWduZWRHYW1lU3RhcnQiLCJnZXRUb3RhbEVzY3Jvd2VkQW1vdW50IiwiZ2V0R2FtZVRpbWVSZW1haW5pbmciLCJzaWduQW5kU3VibWl0VHJhbnNhY3Rpb24iLCJjb25zdHJ1Y3RvciIsIm5vZGVVcmwiLCJEaXNwdXRlUmVzb2x1dGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contracts/EscrowContractAdapter.ts\n"));

/***/ }),

/***/ "./src/hooks/useBetting.ts":
/*!*********************************!*\
  !*** ./src/hooks/useBetting.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBetting: function() { return /* binding */ useBetting; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useBetting() {\n    // Betting state\n    const [player1Bet, setPlayer1Bet] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [player2Bet, setPlayer2Bet] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [finalBetAmount, setFinalBetAmount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Calculate minimum bet\n    const getMinimumBet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (player1Bet <= 0 || player2Bet <= 0) return 0;\n        return Math.min(player1Bet, player2Bet);\n    }, [\n        player1Bet,\n        player2Bet\n    ]);\n    // Announce bets for both players and calculate minimum\n    const announceUnifiedBet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet, onBetsAnnounced)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Announcing unified bet - Player 1: \".concat(player1Bet, \" APT, Player 2: \").concat(player2Bet, \" APT\"));\n            // Validate both players have wallets connected\n            if (!player1Wallet || !player2Wallet) {\n                throw new Error(\"Both players must connect their wallets before announcing bets\");\n            }\n            // Validate bet amounts\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must enter valid bet amounts (greater than 0)\");\n            }\n            // Check sufficient funds\n            if (player1Wallet.balance < player1Bet) {\n                throw new Error(\"Player 1 has insufficient funds. Available: \".concat(player1Wallet.balance, \" APT, Bet: \").concat(player1Bet, \" APT\"));\n            }\n            if (player2Wallet.balance < player2Bet) {\n                throw new Error(\"Player 2 has insufficient funds. Available: \".concat(player2Wallet.balance, \" APT, Bet: \").concat(player2Bet, \" APT\"));\n            }\n            // Calculate minimum bet\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Calculated minimum bet: \".concat(minimumBet, \" APT\"));\n            // Set final bet amount (pot)\n            setFinalBetAmount(minimumBet * 2);\n            // Call the callback function to update game state\n            onBetsAnnounced();\n            console.log(\"Unified bet announcement successful\");\n        } catch (error) {\n            console.error(\"Error announcing unified bet:\", error);\n            setError(error.message || \"Failed to announce unified bet\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        player1Bet,\n        player2Bet\n    ]);\n    // Transfer funds between wallets (for simulation)\n    const updatePlayerBalance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((playerNumber, amount, player1Wallet, player2Wallet, setPlayer1Wallet, setPlayer2Wallet)=>{\n        if (playerNumber === 1 && player1Wallet) {\n            setPlayer1Wallet({\n                ...player1Wallet,\n                balance: player1Wallet.balance + amount\n            });\n        } else if (playerNumber === 2 && player2Wallet) {\n            setPlayer2Wallet({\n                ...player2Wallet,\n                balance: player2Wallet.balance + amount\n            });\n        }\n    }, []);\n    // Reset betting state\n    const resetBettingState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setPlayer1Bet(0);\n        setPlayer2Bet(0);\n        setFinalBetAmount(0);\n    }, []);\n    return {\n        player1Bet,\n        setPlayer1Bet,\n        player2Bet,\n        setPlayer2Bet,\n        finalBetAmount,\n        setFinalBetAmount,\n        isLoading,\n        error,\n        setError,\n        getMinimumBet,\n        announceUnifiedBet,\n        updatePlayerBalance,\n        resetBettingState\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUNBQztRQUNBRztRQUNBVTtRQUNBSztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUJldHRpbmcudHM/YTQ4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQbGF5ZXJXYWxsZXRJbmZvIH0gZnJvbSAnLi4vdHlwZXMvZ2FtZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZXR0aW5nKCkge1xuICAvLyBCZXR0aW5nIHN0YXRlXG4gIGNvbnN0IFtwbGF5ZXIxQmV0LCBzZXRQbGF5ZXIxQmV0XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtwbGF5ZXIyQmV0LCBzZXRQbGF5ZXIyQmV0XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFtmaW5hbEJldEFtb3VudCwgc2V0RmluYWxCZXRBbW91bnRdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBDYWxjdWxhdGUgbWluaW11bSBiZXRcbiAgY29uc3QgZ2V0TWluaW11bUJldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGxheWVyMUJldCA8PSAwIHx8IHBsYXllcjJCZXQgPD0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGgubWluKHBsYXllcjFCZXQsIHBsYXllcjJCZXQpO1xuICB9LCBbcGxheWVyMUJldCwgcGxheWVyMkJldF0pO1xuXG4gIC8vIEFubm91bmNlIGJldHMgZm9yIGJvdGggcGxheWVycyBhbmQgY2FsY3VsYXRlIG1pbmltdW1cbiAgY29uc3QgYW5ub3VuY2VVbmlmaWVkQmV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHBsYXllcjFXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLFxuICAgIHBsYXllcjJXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsLFxuICAgIG9uQmV0c0Fubm91bmNlZDogKCkgPT4gdm9pZFxuICApID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBBbm5vdW5jaW5nIHVuaWZpZWQgYmV0IC0gUGxheWVyIDE6ICR7cGxheWVyMUJldH0gQVBULCBQbGF5ZXIgMjogJHtwbGF5ZXIyQmV0fSBBUFRgKTtcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgYm90aCBwbGF5ZXJzIGhhdmUgd2FsbGV0cyBjb25uZWN0ZWRcbiAgICAgIGlmICghcGxheWVyMVdhbGxldCB8fCAhcGxheWVyMldhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggcGxheWVycyBtdXN0IGNvbm5lY3QgdGhlaXIgd2FsbGV0cyBiZWZvcmUgYW5ub3VuY2luZyBiZXRzJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGJldCBhbW91bnRzXG4gICAgICBpZiAocGxheWVyMUJldCA8PSAwIHx8IHBsYXllcjJCZXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggcGxheWVycyBtdXN0IGVudGVyIHZhbGlkIGJldCBhbW91bnRzIChncmVhdGVyIHRoYW4gMCknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgc3VmZmljaWVudCBmdW5kc1xuICAgICAgaWYgKHBsYXllcjFXYWxsZXQuYmFsYW5jZSA8IHBsYXllcjFCZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGF5ZXIgMSBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzLiBBdmFpbGFibGU6ICR7cGxheWVyMVdhbGxldC5iYWxhbmNlfSBBUFQsIEJldDogJHtwbGF5ZXIxQmV0fSBBUFRgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHBsYXllcjJXYWxsZXQuYmFsYW5jZSA8IHBsYXllcjJCZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGF5ZXIgMiBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzLiBBdmFpbGFibGU6ICR7cGxheWVyMldhbGxldC5iYWxhbmNlfSBBUFQsIEJldDogJHtwbGF5ZXIyQmV0fSBBUFRgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIG1pbmltdW0gYmV0XG4gICAgICBjb25zdCBtaW5pbXVtQmV0ID0gTWF0aC5taW4ocGxheWVyMUJldCwgcGxheWVyMkJldCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ2FsY3VsYXRlZCBtaW5pbXVtIGJldDogJHttaW5pbXVtQmV0fSBBUFRgKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGZpbmFsIGJldCBhbW91bnQgKHBvdClcbiAgICAgIHNldEZpbmFsQmV0QW1vdW50KG1pbmltdW1CZXQgKiAyKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdXBkYXRlIGdhbWUgc3RhdGVcbiAgICAgIG9uQmV0c0Fubm91bmNlZCgpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnVW5pZmllZCBiZXQgYW5ub3VuY2VtZW50IHN1Y2Nlc3NmdWwnKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFubm91bmNpbmcgdW5pZmllZCBiZXQ6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGFubm91bmNlIHVuaWZpZWQgYmV0Jyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbcGxheWVyMUJldCwgcGxheWVyMkJldF0pO1xuXG4gIC8vIFRyYW5zZmVyIGZ1bmRzIGJldHdlZW4gd2FsbGV0cyAoZm9yIHNpbXVsYXRpb24pXG4gIGNvbnN0IHVwZGF0ZVBsYXllckJhbGFuY2UgPSB1c2VDYWxsYmFjaygoXG4gICAgcGxheWVyTnVtYmVyOiAxIHwgMixcbiAgICBhbW91bnQ6IG51bWJlcixcbiAgICBwbGF5ZXIxV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIyV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBzZXRQbGF5ZXIxV2FsbGV0OiAod2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCkgPT4gdm9pZCxcbiAgICBzZXRQbGF5ZXIyV2FsbGV0OiAod2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCkgPT4gdm9pZFxuICApID0+IHtcbiAgICBpZiAocGxheWVyTnVtYmVyID09PSAxICYmIHBsYXllcjFXYWxsZXQpIHtcbiAgICAgIHNldFBsYXllcjFXYWxsZXQoe1xuICAgICAgICAuLi5wbGF5ZXIxV2FsbGV0LFxuICAgICAgICBiYWxhbmNlOiBwbGF5ZXIxV2FsbGV0LmJhbGFuY2UgKyBhbW91bnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGxheWVyTnVtYmVyID09PSAyICYmIHBsYXllcjJXYWxsZXQpIHtcbiAgICAgIHNldFBsYXllcjJXYWxsZXQoe1xuICAgICAgICAuLi5wbGF5ZXIyV2FsbGV0LFxuICAgICAgICBiYWxhbmNlOiBwbGF5ZXIyV2FsbGV0LmJhbGFuY2UgKyBhbW91bnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFJlc2V0IGJldHRpbmcgc3RhdGVcbiAgY29uc3QgcmVzZXRCZXR0aW5nU3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0UGxheWVyMUJldCgwKTtcbiAgICBzZXRQbGF5ZXIyQmV0KDApO1xuICAgIHNldEZpbmFsQmV0QW1vdW50KDApO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwbGF5ZXIxQmV0LFxuICAgIHNldFBsYXllcjFCZXQsXG4gICAgcGxheWVyMkJldCxcbiAgICBzZXRQbGF5ZXIyQmV0LFxuICAgIGZpbmFsQmV0QW1vdW50LFxuICAgIHNldEZpbmFsQmV0QW1vdW50LFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBzZXRFcnJvcixcbiAgICBnZXRNaW5pbXVtQmV0LFxuICAgIGFubm91bmNlVW5pZmllZEJldCxcbiAgICB1cGRhdGVQbGF5ZXJCYWxhbmNlLFxuICAgIHJlc2V0QmV0dGluZ1N0YXRlXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlQmV0dGluZyIsInBsYXllcjFCZXQiLCJzZXRQbGF5ZXIxQmV0IiwicGxheWVyMkJldCIsInNldFBsYXllcjJCZXQiLCJmaW5hbEJldEFtb3VudCIsInNldEZpbmFsQmV0QW1vdW50IiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImdldE1pbmltdW1CZXQiLCJNYXRoIiwibWluIiwiYW5ub3VuY2VVbmlmaWVkQmV0IiwicGxheWVyMVdhbGxldCIsInBsYXllcjJXYWxsZXQiLCJvbkJldHNBbm5vdW5jZWQiLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJiYWxhbmNlIiwibWluaW11bUJldCIsIm1lc3NhZ2UiLCJ1cGRhdGVQbGF5ZXJCYWxhbmNlIiwicGxheWVyTnVtYmVyIiwiYW1vdW50Iiwic2V0UGxheWVyMVdhbGxldCIsInNldFBsYXllcjJXYWxsZXQiLCJyZXNldEJldHRpbmdTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/hooks/useBetting.ts\n"));

/***/ }),

/***/ "./src/hooks/useChessGame.ts":
/*!***********************************!*\
  !*** ./src/hooks/useChessGame.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChessGame: function() { return /* binding */ useChessGame; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var chess_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chess.js */ \"./node_modules/chess.js/dist/esm/chess.js\");\n\n\nfunction useChessGame() {\n    // Game state\n    const [game, setGame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new chess_js__WEBPACK_IMPORTED_MODULE_1__.Chess());\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"waiting\");\n    const [currentPlayer, setCurrentPlayer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"white\");\n    const [winner, setWinner] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Make a move in the chess game\n    const makeAMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((move)=>{\n        const gameCopy = new chess_js__WEBPACK_IMPORTED_MODULE_1__.Chess(game.fen());\n        try {\n            const result = gameCopy.move(move);\n            setGame(gameCopy);\n            // Switch turns\n            setCurrentPlayer(gameCopy.turn() === \"w\" ? \"white\" : \"black\");\n            return result;\n        } catch (error) {\n            return null;\n        }\n    }, [\n        game\n    ]);\n    // Handle dropping a piece on the chessboard\n    const onDrop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((sourceSquare, targetSquare)=>{\n        // Only allow moves if the game is active\n        if (gameState !== \"playing\") return false;\n        // Enforce turn-based gameplay\n        const currentTurn = game.turn() === \"w\" ? \"white\" : \"black\";\n        // In the real game, check if it's the correct player's turn\n        // For now, we just allow the move based on white/black's turn\n        if (currentTurn !== currentPlayer) {\n            console.log(\"Not your turn. Current turn: \".concat(currentTurn));\n            return false;\n        }\n        const move = makeAMove({\n            from: sourceSquare,\n            to: targetSquare,\n            promotion: \"q\"\n        });\n        // If the move is illegal, return false\n        if (move === null) return false;\n        // Check for game over conditions\n        if (game.isGameOver()) {\n            handleGameEnd();\n        }\n        return true;\n    }, [\n        game,\n        gameState,\n        currentPlayer,\n        makeAMove\n    ]);\n    // Handle game end\n    const handleGameEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((winnerParam)=>{\n        setGameState(\"completed\");\n        // Determine the winner if not provided\n        let currentWinner = winnerParam;\n        if (!currentWinner) {\n            // Determine winner based on the chess game state\n            if (game.isDraw()) {\n                currentWinner = \"draw\";\n            } else {\n                // White wins if it's not black's turn (checkmate)\n                currentWinner = game.turn() === \"b\" ? \"player1\" : \"player2\";\n            }\n        }\n        setWinner(currentWinner);\n        console.log(\"Game ended with winner: \".concat(currentWinner));\n        return currentWinner;\n    }, [\n        game\n    ]);\n    // Forfeit the current game\n    const forfeitGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((playerNumber)=>{\n        if (gameState !== \"playing\") {\n            console.log(\"Can only forfeit during an active game\");\n            return null;\n        }\n        setGameState(\"completed\");\n        // Determine the winner (opposite of the player who forfeited)\n        const winner = playerNumber === 1 ? \"player2\" : \"player1\";\n        console.log(\"Player \".concat(playerNumber, \" forfeited. \").concat(winner === \"player1\" ? \"Player 1\" : \"Player 2\", \" wins!\"));\n        // Set the winner\n        setWinner(winner);\n        return winner;\n    }, [\n        gameState\n    ]);\n    // Start a new game\n    const startNewGame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setGame(new chess_js__WEBPACK_IMPORTED_MODULE_1__.Chess());\n        setGameState(\"waiting\");\n        setCurrentPlayer(\"white\");\n        setWinner(null);\n    }, []);\n    // Reset game state (but keep the board as is)\n    const resetGameState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        console.log(\"Resetting game state\");\n        setGameState(\"waiting\");\n        setWinner(null);\n        // Reset the game board\n        setGame(new chess_js__WEBPACK_IMPORTED_MODULE_1__.Chess());\n        // Reset current player\n        setCurrentPlayer(\"white\");\n        console.log(\"Game state reset complete\");\n    }, []);\n    return {\n        game,\n        setGame,\n        gameState,\n        setGameState,\n        currentPlayer,\n        setCurrentPlayer,\n        winner,\n        setWinner,\n        makeAMove,\n        onDrop,\n        handleGameEnd,\n        forfeitGame,\n        startNewGame,\n        resetGameState\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHLEVBQUU7SUFFTCw4Q0FBOEM7SUFDOUMsTUFBTXlCLGlCQUFpQm5DLGtEQUFXQSxDQUFDO1FBQ2pDc0IsUUFBUUMsR0FBRyxDQUFDO1FBQ1pqQixhQUFhO1FBQ2JJLFVBQVU7UUFFVix1QkFBdUI7UUFDdkJOLFFBQVEsSUFBSUgsMkNBQUtBO1FBRWpCLHVCQUF1QjtRQUN2Qk8saUJBQWlCO1FBRWpCYyxRQUFRQyxHQUFHLENBQUM7SUFDZCxHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0xwQjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBTztRQUNBVTtRQUNBSTtRQUNBRTtRQUNBQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUNoZXNzR2FtZS50cz8wY2E5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENoZXNzIH0gZnJvbSAnY2hlc3MuanMnO1xuaW1wb3J0IHsgR2FtZVN0YXRlLCBXaW5uZXIgfSBmcm9tICcuLi90eXBlcy9nYW1lJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZXNzR2FtZSgpIHtcbiAgLy8gR2FtZSBzdGF0ZVxuICBjb25zdCBbZ2FtZSwgc2V0R2FtZV0gPSB1c2VTdGF0ZTxhbnk+KG5ldyBDaGVzcygpKTtcbiAgY29uc3QgW2dhbWVTdGF0ZSwgc2V0R2FtZVN0YXRlXSA9IHVzZVN0YXRlPEdhbWVTdGF0ZT4oJ3dhaXRpbmcnKTtcbiAgY29uc3QgW2N1cnJlbnRQbGF5ZXIsIHNldEN1cnJlbnRQbGF5ZXJdID0gdXNlU3RhdGU8J3doaXRlJyB8ICdibGFjayc+KCd3aGl0ZScpO1xuICBjb25zdCBbd2lubmVyLCBzZXRXaW5uZXJdID0gdXNlU3RhdGU8V2lubmVyPihudWxsKTtcbiAgXG4gIC8vIE1ha2UgYSBtb3ZlIGluIHRoZSBjaGVzcyBnYW1lXG4gIGNvbnN0IG1ha2VBTW92ZSA9IHVzZUNhbGxiYWNrKChtb3ZlOiBhbnkpID0+IHtcbiAgICBjb25zdCBnYW1lQ29weSA9IG5ldyBDaGVzcyhnYW1lLmZlbigpKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ2FtZUNvcHkubW92ZShtb3ZlKTtcbiAgICAgIHNldEdhbWUoZ2FtZUNvcHkpO1xuICAgICAgXG4gICAgICAvLyBTd2l0Y2ggdHVybnNcbiAgICAgIHNldEN1cnJlbnRQbGF5ZXIoZ2FtZUNvcHkudHVybigpID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJyk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwgW2dhbWVdKTtcblxuICAvLyBIYW5kbGUgZHJvcHBpbmcgYSBwaWVjZSBvbiB0aGUgY2hlc3Nib2FyZFxuICBjb25zdCBvbkRyb3AgPSB1c2VDYWxsYmFjaygoc291cmNlU3F1YXJlOiBzdHJpbmcsIHRhcmdldFNxdWFyZTogc3RyaW5nKSA9PiB7XG4gICAgLy8gT25seSBhbGxvdyBtb3ZlcyBpZiB0aGUgZ2FtZSBpcyBhY3RpdmVcbiAgICBpZiAoZ2FtZVN0YXRlICE9PSAncGxheWluZycpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBFbmZvcmNlIHR1cm4tYmFzZWQgZ2FtZXBsYXlcbiAgICBjb25zdCBjdXJyZW50VHVybiA9IGdhbWUudHVybigpID09PSAndycgPyAnd2hpdGUnIDogJ2JsYWNrJztcbiAgICBcbiAgICAvLyBJbiB0aGUgcmVhbCBnYW1lLCBjaGVjayBpZiBpdCdzIHRoZSBjb3JyZWN0IHBsYXllcidzIHR1cm5cbiAgICAvLyBGb3Igbm93LCB3ZSBqdXN0IGFsbG93IHRoZSBtb3ZlIGJhc2VkIG9uIHdoaXRlL2JsYWNrJ3MgdHVyblxuICAgIGlmIChjdXJyZW50VHVybiAhPT0gY3VycmVudFBsYXllcikge1xuICAgICAgY29uc29sZS5sb2coYE5vdCB5b3VyIHR1cm4uIEN1cnJlbnQgdHVybjogJHtjdXJyZW50VHVybn1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbW92ZSA9IG1ha2VBTW92ZSh7XG4gICAgICBmcm9tOiBzb3VyY2VTcXVhcmUsXG4gICAgICB0bzogdGFyZ2V0U3F1YXJlLFxuICAgICAgcHJvbW90aW9uOiAncScsIC8vIERlZmF1bHQgcHJvbW90aW9uIHRvIHF1ZWVuXG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgbW92ZSBpcyBpbGxlZ2FsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAobW92ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGdhbWUgb3ZlciBjb25kaXRpb25zXG4gICAgaWYgKGdhbWUuaXNHYW1lT3ZlcigpKSB7XG4gICAgICBoYW5kbGVHYW1lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIFtnYW1lLCBnYW1lU3RhdGUsIGN1cnJlbnRQbGF5ZXIsIG1ha2VBTW92ZV0pO1xuXG4gIC8vIEhhbmRsZSBnYW1lIGVuZFxuICBjb25zdCBoYW5kbGVHYW1lRW5kID0gdXNlQ2FsbGJhY2soKHdpbm5lclBhcmFtPzogV2lubmVyKSA9PiB7XG4gICAgc2V0R2FtZVN0YXRlKCdjb21wbGV0ZWQnKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHdpbm5lciBpZiBub3QgcHJvdmlkZWRcbiAgICBsZXQgY3VycmVudFdpbm5lciA9IHdpbm5lclBhcmFtO1xuICAgIFxuICAgIGlmICghY3VycmVudFdpbm5lcikge1xuICAgICAgLy8gRGV0ZXJtaW5lIHdpbm5lciBiYXNlZCBvbiB0aGUgY2hlc3MgZ2FtZSBzdGF0ZVxuICAgICAgaWYgKGdhbWUuaXNEcmF3KCkpIHtcbiAgICAgICAgY3VycmVudFdpbm5lciA9ICdkcmF3JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoaXRlIHdpbnMgaWYgaXQncyBub3QgYmxhY2sncyB0dXJuIChjaGVja21hdGUpXG4gICAgICAgIGN1cnJlbnRXaW5uZXIgPSBnYW1lLnR1cm4oKSA9PT0gJ2InID8gJ3BsYXllcjEnIDogJ3BsYXllcjInO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzZXRXaW5uZXIoY3VycmVudFdpbm5lcik7XG4gICAgY29uc29sZS5sb2coYEdhbWUgZW5kZWQgd2l0aCB3aW5uZXI6ICR7Y3VycmVudFdpbm5lcn1gKTtcbiAgICBcbiAgICByZXR1cm4gY3VycmVudFdpbm5lcjtcbiAgfSwgW2dhbWVdKTtcblxuICAvLyBGb3JmZWl0IHRoZSBjdXJyZW50IGdhbWVcbiAgY29uc3QgZm9yZmVpdEdhbWUgPSB1c2VDYWxsYmFjaygocGxheWVyTnVtYmVyOiAxIHwgMikgPT4ge1xuICAgIGlmIChnYW1lU3RhdGUgIT09ICdwbGF5aW5nJykge1xuICAgICAgY29uc29sZS5sb2coXCJDYW4gb25seSBmb3JmZWl0IGR1cmluZyBhbiBhY3RpdmUgZ2FtZVwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBzZXRHYW1lU3RhdGUoJ2NvbXBsZXRlZCcpO1xuICAgIFxuICAgIC8vIERldGVybWluZSB0aGUgd2lubmVyIChvcHBvc2l0ZSBvZiB0aGUgcGxheWVyIHdobyBmb3JmZWl0ZWQpXG4gICAgY29uc3Qgd2lubmVyID0gcGxheWVyTnVtYmVyID09PSAxID8gJ3BsYXllcjInIDogJ3BsYXllcjEnO1xuICAgIGNvbnNvbGUubG9nKGBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IGZvcmZlaXRlZC4gJHt3aW5uZXIgPT09ICdwbGF5ZXIxJyA/ICdQbGF5ZXIgMScgOiAnUGxheWVyIDInfSB3aW5zIWApO1xuICAgIFxuICAgIC8vIFNldCB0aGUgd2lubmVyXG4gICAgc2V0V2lubmVyKHdpbm5lcik7XG4gICAgXG4gICAgcmV0dXJuIHdpbm5lcjtcbiAgfSwgW2dhbWVTdGF0ZV0pO1xuXG4gIC8vIFN0YXJ0IGEgbmV3IGdhbWVcbiAgY29uc3Qgc3RhcnROZXdHYW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEdhbWUobmV3IENoZXNzKCkpO1xuICAgIHNldEdhbWVTdGF0ZSgnd2FpdGluZycpO1xuICAgIHNldEN1cnJlbnRQbGF5ZXIoJ3doaXRlJyk7XG4gICAgc2V0V2lubmVyKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgLy8gUmVzZXQgZ2FtZSBzdGF0ZSAoYnV0IGtlZXAgdGhlIGJvYXJkIGFzIGlzKVxuICBjb25zdCByZXNldEdhbWVTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlJlc2V0dGluZyBnYW1lIHN0YXRlXCIpO1xuICAgIHNldEdhbWVTdGF0ZSgnd2FpdGluZycpO1xuICAgIHNldFdpbm5lcihudWxsKTtcbiAgICBcbiAgICAvLyBSZXNldCB0aGUgZ2FtZSBib2FyZFxuICAgIHNldEdhbWUobmV3IENoZXNzKCkpO1xuICAgIFxuICAgIC8vIFJlc2V0IGN1cnJlbnQgcGxheWVyXG4gICAgc2V0Q3VycmVudFBsYXllcignd2hpdGUnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIkdhbWUgc3RhdGUgcmVzZXQgY29tcGxldGVcIik7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIGdhbWUsXG4gICAgc2V0R2FtZSxcbiAgICBnYW1lU3RhdGUsXG4gICAgc2V0R2FtZVN0YXRlLFxuICAgIGN1cnJlbnRQbGF5ZXIsXG4gICAgc2V0Q3VycmVudFBsYXllcixcbiAgICB3aW5uZXIsXG4gICAgc2V0V2lubmVyLFxuICAgIG1ha2VBTW92ZSxcbiAgICBvbkRyb3AsXG4gICAgaGFuZGxlR2FtZUVuZCxcbiAgICBmb3JmZWl0R2FtZSxcbiAgICBzdGFydE5ld0dhbWUsXG4gICAgcmVzZXRHYW1lU3RhdGVcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJDaGVzcyIsInVzZUNoZXNzR2FtZSIsImdhbWUiLCJzZXRHYW1lIiwiZ2FtZVN0YXRlIiwic2V0R2FtZVN0YXRlIiwiY3VycmVudFBsYXllciIsInNldEN1cnJlbnRQbGF5ZXIiLCJ3aW5uZXIiLCJzZXRXaW5uZXIiLCJtYWtlQU1vdmUiLCJtb3ZlIiwiZ2FtZUNvcHkiLCJmZW4iLCJyZXN1bHQiLCJ0dXJuIiwiZXJyb3IiLCJvbkRyb3AiLCJzb3VyY2VTcXVhcmUiLCJ0YXJnZXRTcXVhcmUiLCJjdXJyZW50VHVybiIsImNvbnNvbGUiLCJsb2ciLCJmcm9tIiwidG8iLCJwcm9tb3Rpb24iLCJpc0dhbWVPdmVyIiwiaGFuZGxlR2FtZUVuZCIsIndpbm5lclBhcmFtIiwiY3VycmVudFdpbm5lciIsImlzRHJhdyIsImZvcmZlaXRHYW1lIiwicGxheWVyTnVtYmVyIiwic3RhcnROZXdHYW1lIiwicmVzZXRHYW1lU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useChessGame.ts\n"));

/***/ }),

/***/ "./src/hooks/useEscrow.ts":
/*!********************************!*\
  !*** ./src/hooks/useEscrow.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEscrow: function() { return /* binding */ useEscrow; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contracts/EscrowContractAdapter */ \"./src/contracts/EscrowContractAdapter.ts\");\n\n\nfunction useEscrow() {\n    // Escrow adapter for blockchain interactions\n    const escrowAdapter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>new _contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowContractAdapter(\"https://fullnode.testnet.aptoslabs.com/v1\", \"0x1\" // Default module address, would be replaced with actual deployed address\n        ), []);\n    // Escrow state\n    const [useSimulationMode, setUseSimulationMode] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true); // Default to true since we're not really deploying\n    const [escrowLocked, setEscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player1EscrowLocked, setPlayer1EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [player2EscrowLocked, setPlayer2EscrowLocked] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [escrowAddress, setEscrowAddress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [escrowStatus, setEscrowStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    const [escrowBalance, setEscrowBalance] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Initialize escrow\n    const initializeEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (player1Wallet, player2Wallet)=>{\n        if (!player1Wallet || !player2Wallet) {\n            console.error(\"Cannot initialize escrow: both players must be connected\");\n            setError(\"Both players must be connected to initialize the escrow\");\n            return;\n        }\n        try {\n            setIsLoading(true);\n            console.log(\"Initializing escrow contract\");\n            // In simulation mode, just set a fake address\n            if (useSimulationMode) {\n                try {\n                    const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                    console.log(\"Creating simulated escrow with address:\", simulatedAddress);\n                    // Set the address in the adapter\n                    escrowAdapter.setEscrowAddress(simulatedAddress);\n                    // Set the address in our component state\n                    setEscrowAddress(simulatedAddress);\n                    console.log(\"Simulated escrow initialized with address:\", simulatedAddress);\n                    // Add a small delay to ensure state updates\n                    await new Promise((resolve)=>setTimeout(resolve, 100));\n                    setIsLoading(false);\n                    return;\n                } catch (simError) {\n                    console.error(\"Error in simulation mode:\", simError);\n                // Continue to try real mode, but log the error\n                }\n            }\n            // Try connecting to Player 1's wallet\n            console.log(\"Attempting to connect to Player 1's wallet for escrow initialization\");\n            // Show prompt for wallet connection\n            window.alert(\"Please make sure Player 1's wallet is selected in your Petra extension to initialize the escrow.\");\n            try {\n                const response = await window.aptos.connect();\n                // Ensure it's Player 1's wallet\n                if (response && response.address === player1Wallet.address) {\n                    console.log(\"Connected to correct wallet, creating escrow\");\n                    const createEscrowResult = await escrowAdapter.createEscrow(window.aptos, player1Wallet.address, player2Wallet.address, 0.1, player1Wallet.address, 24 * 60 * 60 // 24 hour timeout\n                    );\n                    if (createEscrowResult) {\n                        setEscrowAddress(createEscrowResult);\n                        console.log(\"Escrow contract created with address:\", createEscrowResult);\n                        setIsLoading(false);\n                        return;\n                    }\n                } else {\n                    console.warn(\"Connected to wrong wallet address:\", response === null || response === void 0 ? void 0 : response.address);\n                    throw new Error(\"Wrong wallet connected. Expected \".concat(player1Wallet.address, \" but got \").concat(response === null || response === void 0 ? void 0 : response.address, \". Please make sure Player 1's wallet is selected.\"));\n                }\n            } catch (error) {\n                console.error(\"Error with direct Petra connection:\", error);\n                throw error;\n            }\n        } catch (error) {\n            console.error(\"Error initializing escrow:\", error);\n            setError(error.message || \"Failed to initialize escrow\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Create a simulated escrow (for testing)\n    const createSimulatedEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!useSimulationMode) {\n            setError(\"Please enable simulation mode first\");\n            return;\n        }\n        console.log(\"Creating a simulated escrow for testing\");\n        const simulatedAddress = \"simulated_escrow_\" + Date.now();\n        escrowAdapter.setEscrowAddress(simulatedAddress);\n        setEscrowAddress(simulatedAddress);\n        console.log(\"Created simulated escrow with address:\", simulatedAddress);\n        // Also set escrow status to PENDING\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n    }, [\n        useSimulationMode,\n        escrowAdapter\n    ]);\n    // Connect escrow wallet\n    const connectEscrowWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting escrow wallet...\");\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension.\");\n                setIsLoading(false);\n                return;\n            }\n            // Prompt to select the escrow wallet\n            window.alert(\"Please make sure your ESCROW wallet is selected in your Petra extension.\");\n            const response = await window.aptos.connect();\n            console.log(\"Escrow wallet connection response:\", response);\n            if (response && response.address) {\n                console.log(\"Connected to escrow wallet:\", response.address);\n                // Set the escrow address in the adapter\n                escrowAdapter.setEscrowAddress(response.address);\n                // Set the address in component state\n                setEscrowAddress(response.address);\n                console.log(\"Escrow wallet set successfully:\", response.address);\n            } else {\n                throw new Error(\"Failed to get escrow wallet address\");\n            }\n        } catch (error) {\n            console.error(\"Error connecting escrow wallet:\", error);\n            setError(error.message || \"Failed to connect escrow wallet\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        escrowAdapter\n    ]);\n    // Lock the escrow by transferring the minimum bet amount from a specific player\n    const lockEscrow = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (playerNumber, player1Wallet, player2Wallet, player1Bet, player2Bet, ensureCorrectWalletConnected, getAccountBalance, transferToEscrow)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Starting escrow locking process for Player \".concat(playerNumber));\n            console.log(\"Current escrow lock status: Player 1: \".concat(player1EscrowLocked, \", Player 2: \").concat(player2EscrowLocked));\n            // Verify both players have placed bets\n            if (player1Bet <= 0 || player2Bet <= 0) {\n                throw new Error(\"Both players must announce bets before locking escrow\");\n            }\n            // Determine the minimum bet amount (this is what will be deducted)\n            const minimumBet = Math.min(player1Bet, player2Bet);\n            console.log(\"Minimum bet amount between players: \".concat(minimumBet, \" APT\"));\n            // Get player wallet\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (!playerWallet) {\n                throw new Error(\"Player \".concat(playerNumber, \" wallet not connected\"));\n            }\n            // In simulation mode, create an escrow if not yet initialized\n            if (useSimulationMode && !escrowAddress) {\n                console.log(\"No escrow initialized yet, but in simulation mode. Creating escrow now...\");\n                const simulatedAddress = \"simulated_escrow_\" + Date.now();\n                escrowAdapter.setEscrowAddress(simulatedAddress);\n                setEscrowAddress(simulatedAddress);\n                console.log(\"Auto-created simulated escrow with address:\", simulatedAddress);\n                // Brief pause to let state update\n                await new Promise((resolve)=>setTimeout(resolve, 100));\n            }\n            // Make sure an escrow address is set\n            if (!escrowAddress) {\n                throw new Error(\"No escrow wallet connected. Please connect the escrow wallet first.\");\n            }\n            console.log(\"Depositing \".concat(minimumBet, \" APT to escrow contract from Player \").concat(playerNumber));\n            // Use simulation mode if enabled\n            if (useSimulationMode) {\n                console.log(\"Using simulation mode - no actual transfer will occur\");\n                // Simulate deposit\n                await new Promise((resolve)=>setTimeout(resolve, 1000));\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                } else {\n                    setPlayer2EscrowLocked(true);\n                }\n                console.log(\"Simulated escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance in simulation mode\n                setEscrowBalance((prevBalance)=>prevBalance + minimumBet);\n            } else {\n                // Real deposit by transferring funds to the escrow address\n                // Make sure the player's wallet is connected\n                const isWalletConnected = await ensureCorrectWalletConnected(playerNumber);\n                if (!isWalletConnected) {\n                    throw new Error(\"Please connect the wallet for Player \".concat(playerNumber, \" to continue\"));\n                }\n                // Direct transfer to escrow address - using minimumBet instead of player's full bet\n                const transferSuccess = await transferToEscrow(playerNumber, minimumBet, escrowAddress);\n                if (!transferSuccess) {\n                    throw new Error(\"Failed to transfer funds to escrow for Player \".concat(playerNumber));\n                }\n                // Update UI state\n                if (playerNumber === 1) {\n                    setPlayer1EscrowLocked(true);\n                    // Refresh balance\n                    if (player1Wallet) {\n                        const newBalance = await getAccountBalance(player1Wallet.address);\n                    }\n                } else {\n                    setPlayer2EscrowLocked(true);\n                    // Refresh balance\n                    if (player2Wallet) {\n                        const newBalance = await getAccountBalance(player2Wallet.address);\n                    }\n                }\n                console.log(\"Escrow lock successful for Player \".concat(playerNumber));\n                // Update escrow balance - in real mode, we'd query the contract\n                if (escrowAddress) {\n                    const escrowBalanceResult = await getAccountBalance(escrowAddress);\n                    setEscrowBalance(escrowBalanceResult);\n                }\n            }\n            // Check if both players have locked their escrow after this player's lock\n            const bothPlayersLocked = playerNumber === 1 ?  true && player2EscrowLocked // Player 1 just locked + check if Player 2 was already locked\n             : player1EscrowLocked && true; // Check if Player 1 was already locked + Player 2 just locked\n            if (bothPlayersLocked) {\n                console.log(\"Both players have deposited funds to escrow. Ready to start game...\");\n                // Final pool amount is minimum bet  2\n                const finalPoolAmount = minimumBet * 2;\n                console.log(\"Setting final bet amount to \".concat(finalPoolAmount, \" APT (\").concat(minimumBet, \" \\xd7 2)\"));\n                setEscrowLocked(true);\n            } else {\n                console.log(\"Waiting for the other player to lock their escrow\");\n            }\n            return {\n                wasLocked: true,\n                playerNumber,\n                minimumBet\n            };\n        } catch (error) {\n            console.error(\"Error locking escrow for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to lock escrow for Player \".concat(playerNumber));\n            return {\n                wasLocked: false,\n                error: error.message || \"Failed to lock escrow for Player \".concat(playerNumber)\n            };\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        useSimulationMode,\n        escrowAddress,\n        player1EscrowLocked,\n        player2EscrowLocked,\n        escrowAdapter\n    ]);\n    // Pay winner from escrow\n    const payWinner = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (winner, player1Wallet, player2Wallet, player1Bet, player2Bet, finalBetAmount, getAccountBalance)=>{\n        try {\n            if (!winner) return;\n            console.log(\"Paying winner: \".concat(winner));\n            // Only proceed if not in simulation mode and escrow is locked\n            if (!useSimulationMode && escrowLocked && escrowAddress) {\n                // Handle draw case\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - returning funds to both players\");\n                    // For a draw, return original bet amounts to each player\n                    // Connect to escrow wallet first\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to return funds.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Return funds to Player 1\n                    if (player1Wallet) {\n                        console.log(\"Returning \".concat(player1Bet, \" APT to Player 1 from escrow\"));\n                        const payload1 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player1Wallet.address,\n                                Math.floor(player1Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse1 = await window.aptos.signAndSubmitTransaction(payload1);\n                        console.log(\"Player 1 refund transaction:\", txResponse1);\n                    }\n                    // Return funds to Player 2\n                    if (player2Wallet) {\n                        console.log(\"Returning \".concat(player2Bet, \" APT to Player 2 from escrow\"));\n                        const payload2 = {\n                            type: \"entry_function_payload\",\n                            function: \"0x1::coin::transfer\",\n                            type_arguments: [\n                                \"0x1::aptos_coin::AptosCoin\"\n                            ],\n                            arguments: [\n                                player2Wallet.address,\n                                Math.floor(player2Bet * 100000000).toString()\n                            ]\n                        };\n                        const txResponse2 = await window.aptos.signAndSubmitTransaction(payload2);\n                        console.log(\"Player 2 refund transaction:\", txResponse2);\n                    }\n                } else {\n                    const winnerWallet = winner === \"player1\" ? player1Wallet : player2Wallet;\n                    if (!winnerWallet) {\n                        throw new Error(\"Winner wallet not found\");\n                    }\n                    console.log(\"Transferring \".concat(finalBetAmount, \" APT to winner (\").concat(winnerWallet.address, \")\"));\n                    // Connect to escrow wallet\n                    window.alert(\"Please select the ESCROW wallet in your Petra extension to pay the winner.\");\n                    const escrowWalletConnected = await window.aptos.connect();\n                    if (!escrowWalletConnected || escrowWalletConnected.address !== escrowAddress) {\n                        throw new Error(\"Failed to connect to escrow wallet. Please ensure the correct wallet is selected.\");\n                    }\n                    // Transfer all funds from escrow to winner\n                    const payload = {\n                        type: \"entry_function_payload\",\n                        function: \"0x1::coin::transfer\",\n                        type_arguments: [\n                            \"0x1::aptos_coin::AptosCoin\"\n                        ],\n                        arguments: [\n                            winnerWallet.address,\n                            Math.floor(finalBetAmount * 100000000).toString()\n                        ]\n                    };\n                    const txResponse = await window.aptos.signAndSubmitTransaction(payload);\n                    console.log(\"Winner payment transaction:\", txResponse);\n                }\n                // Update player balances after transfers\n                if (player1Wallet) {\n                    await getAccountBalance(player1Wallet.address);\n                }\n                if (player2Wallet) {\n                    await getAccountBalance(player2Wallet.address);\n                }\n            } else if (useSimulationMode) {\n                if (winner === \"draw\") {\n                    console.log(\"Draw game - both players receive their bets back (simulation)\");\n                } else {\n                    console.log(\"Updating Player \".concat(winner === \"player1\" ? \"1\" : \"2\", \" wallet balance: +\").concat(finalBetAmount, \" APT (simulation)\"));\n                }\n            }\n            console.log(\"Winner payment completed successfully\");\n        } catch (error) {\n            console.error(\"Error paying winner:\", error);\n            setError(error.message || \"Failed to pay winner\");\n        }\n    }, [\n        useSimulationMode,\n        escrowLocked,\n        escrowAddress\n    ]);\n    // Reset escrow state\n    const resetEscrowState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setPlayer1EscrowLocked(false);\n        setPlayer2EscrowLocked(false);\n        setEscrowLocked(false);\n        setEscrowStatus(_contracts_EscrowContractAdapter__WEBPACK_IMPORTED_MODULE_1__.EscrowStatus.PENDING);\n        setEscrowBalance(0);\n    }, []);\n    return {\n        useSimulationMode,\n        setUseSimulationMode,\n        escrowLocked,\n        setEscrowLocked,\n        player1EscrowLocked,\n        setPlayer1EscrowLocked,\n        player2EscrowLocked,\n        setPlayer2EscrowLocked,\n        escrowAddress,\n        setEscrowAddress,\n        escrowStatus,\n        setEscrowStatus,\n        escrowBalance,\n        setEscrowBalance,\n        isLoading,\n        error,\n        setError,\n        initializeEscrow,\n        createSimulatedEscrow,\n        connectEscrowWallet,\n        lockEscrow,\n        payWinner,\n        resetEscrowState,\n        escrowAdapter\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRXNjcm93Q29udHJhY3RBZGFwdGVyLCBFc2Nyb3dTdGF0dXMgfSBmcm9tICcuLi9jb250cmFjdHMvRXNjcm93Q29udHJhY3RBZGFwdGVyJztcbmltcG9ydCB7IFBsYXllcldhbGxldEluZm8gfSBmcm9tICcuLi90eXBlcy9nYW1lJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVzY3JvdygpIHtcbiAgLy8gRXNjcm93IGFkYXB0ZXIgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gIGNvbnN0IGVzY3Jvd0FkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IG5ldyBFc2Nyb3dDb250cmFjdEFkYXB0ZXIoXG4gICAgJ2h0dHBzOi8vZnVsbG5vZGUudGVzdG5ldC5hcHRvc2xhYnMuY29tL3YxJyxcbiAgICAnMHgxJyAvLyBEZWZhdWx0IG1vZHVsZSBhZGRyZXNzLCB3b3VsZCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbCBkZXBsb3llZCBhZGRyZXNzXG4gICksIFtdKTtcblxuICAvLyBFc2Nyb3cgc3RhdGVcbiAgY29uc3QgW3VzZVNpbXVsYXRpb25Nb2RlLCBzZXRVc2VTaW11bGF0aW9uTW9kZV0gPSB1c2VTdGF0ZTxib29sZWFuPih0cnVlKTsgLy8gRGVmYXVsdCB0byB0cnVlIHNpbmNlIHdlJ3JlIG5vdCByZWFsbHkgZGVwbG95aW5nXG4gIGNvbnN0IFtlc2Nyb3dMb2NrZWQsIHNldEVzY3Jvd0xvY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtwbGF5ZXIxRXNjcm93TG9ja2VkLCBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW3BsYXllcjJFc2Nyb3dMb2NrZWQsIHNldFBsYXllcjJFc2Nyb3dMb2NrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbZXNjcm93QWRkcmVzcywgc2V0RXNjcm93QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2VzY3Jvd1N0YXR1cywgc2V0RXNjcm93U3RhdHVzXSA9IHVzZVN0YXRlPEVzY3Jvd1N0YXR1cz4oRXNjcm93U3RhdHVzLlBFTkRJTkcpO1xuICBjb25zdCBbZXNjcm93QmFsYW5jZSwgc2V0RXNjcm93QmFsYW5jZV0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEluaXRpYWxpemUgZXNjcm93XG4gIGNvbnN0IGluaXRpYWxpemVFc2Nyb3cgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgcGxheWVyMVdhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsIFxuICAgIHBsYXllcjJXYWxsZXQ6IFBsYXllcldhbGxldEluZm8gfCBudWxsXG4gICkgPT4ge1xuICAgIGlmICghcGxheWVyMVdhbGxldCB8fCAhcGxheWVyMldhbGxldCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIGVzY3JvdzogYm90aCBwbGF5ZXJzIG11c3QgYmUgY29ubmVjdGVkXCIpO1xuICAgICAgc2V0RXJyb3IoXCJCb3RoIHBsYXllcnMgbXVzdCBiZSBjb25uZWN0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZXNjcm93XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBlc2Nyb3cgY29udHJhY3RcIik7XG5cbiAgICAgIC8vIEluIHNpbXVsYXRpb24gbW9kZSwganVzdCBzZXQgYSBmYWtlIGFkZHJlc3NcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHNpbXVsYXRlZCBlc2Nyb3cgd2l0aCBhZGRyZXNzOlwiLCBzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgdGhlIGFkZHJlc3MgaW4gdGhlIGFkYXB0ZXJcbiAgICAgICAgICBlc2Nyb3dBZGFwdGVyLnNldEVzY3Jvd0FkZHJlc3Moc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IHRoZSBhZGRyZXNzIGluIG91ciBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2ltdWxhdGVkIGVzY3JvdyBpbml0aWFsaXplZCB3aXRoIGFkZHJlc3M6XCIsIHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBzdGF0ZSB1cGRhdGVzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChzaW1FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBzaW11bGF0aW9uIG1vZGU6XCIsIHNpbUVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0byB0cnkgcmVhbCBtb2RlLCBidXQgbG9nIHRoZSBlcnJvclxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBjb25uZWN0aW5nIHRvIFBsYXllciAxJ3Mgd2FsbGV0XG4gICAgICBjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byBQbGF5ZXIgMSdzIHdhbGxldCBmb3IgZXNjcm93IGluaXRpYWxpemF0aW9uXCIpO1xuICAgICAgXG4gICAgICAvLyBTaG93IHByb21wdCBmb3Igd2FsbGV0IGNvbm5lY3Rpb25cbiAgICAgIHdpbmRvdy5hbGVydChcIlBsZWFzZSBtYWtlIHN1cmUgUGxheWVyIDEncyB3YWxsZXQgaXMgc2VsZWN0ZWQgaW4geW91ciBQZXRyYSBleHRlbnNpb24gdG8gaW5pdGlhbGl6ZSB0aGUgZXNjcm93LlwiKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW5zdXJlIGl0J3MgUGxheWVyIDEncyB3YWxsZXRcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MgPT09IHBsYXllcjFXYWxsZXQuYWRkcmVzcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHRvIGNvcnJlY3Qgd2FsbGV0LCBjcmVhdGluZyBlc2Nyb3dcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgY3JlYXRlRXNjcm93UmVzdWx0ID0gYXdhaXQgZXNjcm93QWRhcHRlci5jcmVhdGVFc2Nyb3coXG4gICAgICAgICAgICB3aW5kb3cuYXB0b3MsXG4gICAgICAgICAgICBwbGF5ZXIxV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICBwbGF5ZXIyV2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICAwLjEsIC8vIE1pbmltdW0gYmV0IG9mIDAuMSBBUFRcbiAgICAgICAgICAgIHBsYXllcjFXYWxsZXQuYWRkcmVzcywgLy8gVXNlIHBsYXllciAxIGFzIGFyYml0ZXJcbiAgICAgICAgICAgIDI0ICogNjAgKiA2MCAvLyAyNCBob3VyIHRpbWVvdXRcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjcmVhdGVFc2Nyb3dSZXN1bHQpIHtcbiAgICAgICAgICAgIHNldEVzY3Jvd0FkZHJlc3MoY3JlYXRlRXNjcm93UmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXNjcm93IGNvbnRyYWN0IGNyZWF0ZWQgd2l0aCBhZGRyZXNzOlwiLCBjcmVhdGVFc2Nyb3dSZXN1bHQpO1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ29ubmVjdGVkIHRvIHdyb25nIHdhbGxldCBhZGRyZXNzOlwiLCByZXNwb25zZT8uYWRkcmVzcyk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyB3YWxsZXQgY29ubmVjdGVkLiBFeHBlY3RlZCAke3BsYXllcjFXYWxsZXQuYWRkcmVzc30gYnV0IGdvdCAke3Jlc3BvbnNlPy5hZGRyZXNzfS4gUGxlYXNlIG1ha2Ugc3VyZSBQbGF5ZXIgMSdzIHdhbGxldCBpcyBzZWxlY3RlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2l0aCBkaXJlY3QgUGV0cmEgY29ubmVjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIGVzY3JvdzpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBpbml0aWFsaXplIGVzY3Jvd1wiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFt1c2VTaW11bGF0aW9uTW9kZSwgZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIENyZWF0ZSBhIHNpbXVsYXRlZCBlc2Nyb3cgKGZvciB0ZXN0aW5nKVxuICBjb25zdCBjcmVhdGVTaW11bGF0ZWRFc2Nyb3cgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCF1c2VTaW11bGF0aW9uTW9kZSkge1xuICAgICAgc2V0RXJyb3IoXCJQbGVhc2UgZW5hYmxlIHNpbXVsYXRpb24gbW9kZSBmaXJzdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJDcmVhdGluZyBhIHNpbXVsYXRlZCBlc2Nyb3cgZm9yIHRlc3RpbmdcIik7XG4gICAgY29uc3Qgc2ltdWxhdGVkQWRkcmVzcyA9ICdzaW11bGF0ZWRfZXNjcm93XycgKyBEYXRlLm5vdygpO1xuICAgIGVzY3Jvd0FkYXB0ZXIuc2V0RXNjcm93QWRkcmVzcyhzaW11bGF0ZWRBZGRyZXNzKTtcbiAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlZCBzaW11bGF0ZWQgZXNjcm93IHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgXG4gICAgLy8gQWxzbyBzZXQgZXNjcm93IHN0YXR1cyB0byBQRU5ESU5HXG4gICAgc2V0RXNjcm93U3RhdHVzKEVzY3Jvd1N0YXR1cy5QRU5ESU5HKTtcbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dBZGFwdGVyXSk7XG5cbiAgLy8gQ29ubmVjdCBlc2Nyb3cgd2FsbGV0XG4gIGNvbnN0IGNvbm5lY3RFc2Nyb3dXYWxsZXQgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RpbmcgZXNjcm93IHdhbGxldC4uLlwiKTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuYXB0b3MpIHtcbiAgICAgICAgc2V0RXJyb3IoXCJQZXRyYSB3YWxsZXQgaXMgbm90IGluc3RhbGxlZC4gUGxlYXNlIGluc3RhbGwgdGhlIFBldHJhIHdhbGxldCBleHRlbnNpb24uXCIpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb21wdCB0byBzZWxlY3QgdGhlIGVzY3JvdyB3YWxsZXRcbiAgICAgIHdpbmRvdy5hbGVydChcIlBsZWFzZSBtYWtlIHN1cmUgeW91ciBFU0NST1cgd2FsbGV0IGlzIHNlbGVjdGVkIGluIHlvdXIgUGV0cmEgZXh0ZW5zaW9uLlwiKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgY29uc29sZS5sb2coXCJFc2Nyb3cgd2FsbGV0IGNvbm5lY3Rpb24gcmVzcG9uc2U6XCIsIHJlc3BvbnNlKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gZXNjcm93IHdhbGxldDpcIiwgcmVzcG9uc2UuYWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGhlIGVzY3JvdyBhZGRyZXNzIGluIHRoZSBhZGFwdGVyXG4gICAgICAgIGVzY3Jvd0FkYXB0ZXIuc2V0RXNjcm93QWRkcmVzcyhyZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aGUgYWRkcmVzcyBpbiBjb21wb25lbnQgc3RhdGVcbiAgICAgICAgc2V0RXNjcm93QWRkcmVzcyhyZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXNjcm93IHdhbGxldCBzZXQgc3VjY2Vzc2Z1bGx5OlwiLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgZXNjcm93IHdhbGxldCBhZGRyZXNzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbm5lY3RpbmcgZXNjcm93IHdhbGxldDpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBjb25uZWN0IGVzY3JvdyB3YWxsZXRcIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIExvY2sgdGhlIGVzY3JvdyBieSB0cmFuc2ZlcnJpbmcgdGhlIG1pbmltdW0gYmV0IGFtb3VudCBmcm9tIGEgc3BlY2lmaWMgcGxheWVyXG4gIGNvbnN0IGxvY2tFc2Nyb3cgPSB1c2VDYWxsYmFjayhhc3luYyAoXG4gICAgcGxheWVyTnVtYmVyOiAxIHwgMiwgXG4gICAgcGxheWVyMVdhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsXG4gICAgcGxheWVyMldhbGxldDogUGxheWVyV2FsbGV0SW5mbyB8IG51bGwsXG4gICAgcGxheWVyMUJldDogbnVtYmVyLFxuICAgIHBsYXllcjJCZXQ6IG51bWJlcixcbiAgICBlbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkOiAocGxheWVyTnVtYmVyOiAxIHwgMikgPT4gUHJvbWlzZTxib29sZWFuPixcbiAgICBnZXRBY2NvdW50QmFsYW5jZTogKGFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTxudW1iZXI+LFxuICAgIHRyYW5zZmVyVG9Fc2Nyb3c6IChwbGF5ZXJOdW1iZXI6IDEgfCAyLCBhbW91bnQ6IG51bWJlciwgdGFyZ2V0QWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gICkgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGVzY3JvdyBsb2NraW5nIHByb2Nlc3MgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IGVzY3JvdyBsb2NrIHN0YXR1czogUGxheWVyIDE6ICR7cGxheWVyMUVzY3Jvd0xvY2tlZH0sIFBsYXllciAyOiAke3BsYXllcjJFc2Nyb3dMb2NrZWR9YCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBib3RoIHBsYXllcnMgaGF2ZSBwbGFjZWQgYmV0c1xuICAgICAgaWYgKHBsYXllcjFCZXQgPD0gMCB8fCBwbGF5ZXIyQmV0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBwbGF5ZXJzIG11c3QgYW5ub3VuY2UgYmV0cyBiZWZvcmUgbG9ja2luZyBlc2Nyb3dcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSB0aGUgbWluaW11bSBiZXQgYW1vdW50ICh0aGlzIGlzIHdoYXQgd2lsbCBiZSBkZWR1Y3RlZClcbiAgICAgIGNvbnN0IG1pbmltdW1CZXQgPSBNYXRoLm1pbihwbGF5ZXIxQmV0LCBwbGF5ZXIyQmV0KTtcbiAgICAgIGNvbnNvbGUubG9nKGBNaW5pbXVtIGJldCBhbW91bnQgYmV0d2VlbiBwbGF5ZXJzOiAke21pbmltdW1CZXR9IEFQVGApO1xuICAgICAgXG4gICAgICAvLyBHZXQgcGxheWVyIHdhbGxldFxuICAgICAgY29uc3QgcGxheWVyV2FsbGV0ID0gcGxheWVyTnVtYmVyID09PSAxID8gcGxheWVyMVdhbGxldCA6IHBsYXllcjJXYWxsZXQ7XG4gICAgICBpZiAoIXBsYXllcldhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXllciAke3BsYXllck51bWJlcn0gd2FsbGV0IG5vdCBjb25uZWN0ZWRgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW4gc2ltdWxhdGlvbiBtb2RlLCBjcmVhdGUgYW4gZXNjcm93IGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICAgIGlmICh1c2VTaW11bGF0aW9uTW9kZSAmJiAhZXNjcm93QWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGVzY3JvdyBpbml0aWFsaXplZCB5ZXQsIGJ1dCBpbiBzaW11bGF0aW9uIG1vZGUuIENyZWF0aW5nIGVzY3JvdyBub3cuLi5cIik7XG4gICAgICAgIGNvbnN0IHNpbXVsYXRlZEFkZHJlc3MgPSAnc2ltdWxhdGVkX2VzY3Jvd18nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgZXNjcm93QWRhcHRlci5zZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBzZXRFc2Nyb3dBZGRyZXNzKHNpbXVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkF1dG8tY3JlYXRlZCBzaW11bGF0ZWQgZXNjcm93IHdpdGggYWRkcmVzczpcIiwgc2ltdWxhdGVkQWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBCcmllZiBwYXVzZSB0byBsZXQgc3RhdGUgdXBkYXRlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIGFuIGVzY3JvdyBhZGRyZXNzIGlzIHNldFxuICAgICAgaWYgKCFlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVzY3JvdyB3YWxsZXQgY29ubmVjdGVkLiBQbGVhc2UgY29ubmVjdCB0aGUgZXNjcm93IHdhbGxldCBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBEZXBvc2l0aW5nICR7bWluaW11bUJldH0gQVBUIHRvIGVzY3JvdyBjb250cmFjdCBmcm9tIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHNpbXVsYXRpb24gbW9kZSBpZiBlbmFibGVkXG4gICAgICBpZiAodXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBzaW11bGF0aW9uIG1vZGUgLSBubyBhY3R1YWwgdHJhbnNmZXIgd2lsbCBvY2N1clwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXVsYXRlIGRlcG9zaXRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBVSSBzdGF0ZVxuICAgICAgICBpZiAocGxheWVyTnVtYmVyID09PSAxKSB7XG4gICAgICAgICAgc2V0UGxheWVyMUVzY3Jvd0xvY2tlZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU2ltdWxhdGVkIGVzY3JvdyBsb2NrIHN1Y2Nlc3NmdWwgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBlc2Nyb3cgYmFsYW5jZSBpbiBzaW11bGF0aW9uIG1vZGVcbiAgICAgICAgc2V0RXNjcm93QmFsYW5jZShwcmV2QmFsYW5jZSA9PiBwcmV2QmFsYW5jZSArIG1pbmltdW1CZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVhbCBkZXBvc2l0IGJ5IHRyYW5zZmVycmluZyBmdW5kcyB0byB0aGUgZXNjcm93IGFkZHJlc3NcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwbGF5ZXIncyB3YWxsZXQgaXMgY29ubmVjdGVkXG4gICAgICAgIGNvbnN0IGlzV2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZChwbGF5ZXJOdW1iZXIpO1xuICAgICAgICBpZiAoIWlzV2FsbGV0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgY29ubmVjdCB0aGUgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9IHRvIGNvbnRpbnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERpcmVjdCB0cmFuc2ZlciB0byBlc2Nyb3cgYWRkcmVzcyAtIHVzaW5nIG1pbmltdW1CZXQgaW5zdGVhZCBvZiBwbGF5ZXIncyBmdWxsIGJldFxuICAgICAgICBjb25zdCB0cmFuc2ZlclN1Y2Nlc3MgPSBhd2FpdCB0cmFuc2ZlclRvRXNjcm93KHBsYXllck51bWJlciwgbWluaW11bUJldCwgZXNjcm93QWRkcmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRyYW5zZmVyU3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHRyYW5zZmVyIGZ1bmRzIHRvIGVzY3JvdyBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVUkgc3RhdGVcbiAgICAgICAgaWYgKHBsYXllck51bWJlciA9PT0gMSkge1xuICAgICAgICAgIHNldFBsYXllcjFFc2Nyb3dMb2NrZWQodHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVmcmVzaCBiYWxhbmNlXG4gICAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0JhbGFuY2UgPSBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZnJlc2ggYmFsYW5jZVxuICAgICAgICAgIGlmIChwbGF5ZXIyV2FsbGV0KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdCYWxhbmNlID0gYXdhaXQgZ2V0QWNjb3VudEJhbGFuY2UocGxheWVyMldhbGxldC5hZGRyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBFc2Nyb3cgbG9jayBzdWNjZXNzZnVsIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZXNjcm93IGJhbGFuY2UgLSBpbiByZWFsIG1vZGUsIHdlJ2QgcXVlcnkgdGhlIGNvbnRyYWN0XG4gICAgICAgIGlmIChlc2Nyb3dBZGRyZXNzKSB7XG4gICAgICAgICAgY29uc3QgZXNjcm93QmFsYW5jZVJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKGVzY3Jvd0FkZHJlc3MpO1xuICAgICAgICAgIHNldEVzY3Jvd0JhbGFuY2UoZXNjcm93QmFsYW5jZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgYm90aCBwbGF5ZXJzIGhhdmUgbG9ja2VkIHRoZWlyIGVzY3JvdyBhZnRlciB0aGlzIHBsYXllcidzIGxvY2tcbiAgICAgIGNvbnN0IGJvdGhQbGF5ZXJzTG9ja2VkID0gcGxheWVyTnVtYmVyID09PSAxIFxuICAgICAgICA/IHRydWUgJiYgcGxheWVyMkVzY3Jvd0xvY2tlZCAgLy8gUGxheWVyIDEganVzdCBsb2NrZWQgKyBjaGVjayBpZiBQbGF5ZXIgMiB3YXMgYWxyZWFkeSBsb2NrZWRcbiAgICAgICAgOiBwbGF5ZXIxRXNjcm93TG9ja2VkICYmIHRydWU7IC8vIENoZWNrIGlmIFBsYXllciAxIHdhcyBhbHJlYWR5IGxvY2tlZCArIFBsYXllciAyIGp1c3QgbG9ja2VkXG4gICAgICAgIFxuICAgICAgaWYgKGJvdGhQbGF5ZXJzTG9ja2VkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQm90aCBwbGF5ZXJzIGhhdmUgZGVwb3NpdGVkIGZ1bmRzIHRvIGVzY3Jvdy4gUmVhZHkgdG8gc3RhcnQgZ2FtZS4uLlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmFsIHBvb2wgYW1vdW50IGlzIG1pbmltdW0gYmV0IMOXIDJcbiAgICAgICAgY29uc3QgZmluYWxQb29sQW1vdW50ID0gbWluaW11bUJldCAqIDI7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU2V0dGluZyBmaW5hbCBiZXQgYW1vdW50IHRvICR7ZmluYWxQb29sQW1vdW50fSBBUFQgKCR7bWluaW11bUJldH0gw5cgMilgKTtcbiAgICAgICAgc2V0RXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgZm9yIHRoZSBvdGhlciBwbGF5ZXIgdG8gbG9jayB0aGVpciBlc2Nyb3dgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2FzTG9ja2VkOiB0cnVlLFxuICAgICAgICBwbGF5ZXJOdW1iZXIsXG4gICAgICAgIG1pbmltdW1CZXRcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgbG9ja2luZyBlc2Nyb3cgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGxvY2sgZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YXNMb2NrZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGxvY2sgZXNjcm93IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YFxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFt1c2VTaW11bGF0aW9uTW9kZSwgZXNjcm93QWRkcmVzcywgcGxheWVyMUVzY3Jvd0xvY2tlZCwgcGxheWVyMkVzY3Jvd0xvY2tlZCwgZXNjcm93QWRhcHRlcl0pO1xuXG4gIC8vIFBheSB3aW5uZXIgZnJvbSBlc2Nyb3dcbiAgY29uc3QgcGF5V2lubmVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKFxuICAgIHdpbm5lcjogJ3BsYXllcjEnIHwgJ3BsYXllcjInIHwgJ2RyYXcnIHwgbnVsbCxcbiAgICBwbGF5ZXIxV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIyV2FsbGV0OiBQbGF5ZXJXYWxsZXRJbmZvIHwgbnVsbCxcbiAgICBwbGF5ZXIxQmV0OiBudW1iZXIsXG4gICAgcGxheWVyMkJldDogbnVtYmVyLFxuICAgIGZpbmFsQmV0QW1vdW50OiBudW1iZXIsXG4gICAgZ2V0QWNjb3VudEJhbGFuY2U6IChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8bnVtYmVyPlxuICApID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF3aW5uZXIpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFBheWluZyB3aW5uZXI6ICR7d2lubmVyfWApO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHByb2NlZWQgaWYgbm90IGluIHNpbXVsYXRpb24gbW9kZSBhbmQgZXNjcm93IGlzIGxvY2tlZFxuICAgICAgaWYgKCF1c2VTaW11bGF0aW9uTW9kZSAmJiBlc2Nyb3dMb2NrZWQgJiYgZXNjcm93QWRkcmVzcykge1xuICAgICAgICAvLyBIYW5kbGUgZHJhdyBjYXNlXG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gcmV0dXJuaW5nIGZ1bmRzIHRvIGJvdGggcGxheWVyc1wiKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3IgYSBkcmF3LCByZXR1cm4gb3JpZ2luYWwgYmV0IGFtb3VudHMgdG8gZWFjaCBwbGF5ZXJcbiAgICAgICAgICAvLyBDb25uZWN0IHRvIGVzY3JvdyB3YWxsZXQgZmlyc3RcbiAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJQbGVhc2Ugc2VsZWN0IHRoZSBFU0NST1cgd2FsbGV0IGluIHlvdXIgUGV0cmEgZXh0ZW5zaW9uIHRvIHJldHVybiBmdW5kcy5cIik7XG4gICAgICAgICAgY29uc3QgZXNjcm93V2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWVzY3Jvd1dhbGxldENvbm5lY3RlZCB8fCBlc2Nyb3dXYWxsZXRDb25uZWN0ZWQuYWRkcmVzcyAhPT0gZXNjcm93QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gZXNjcm93IHdhbGxldC4gUGxlYXNlIGVuc3VyZSB0aGUgY29ycmVjdCB3YWxsZXQgaXMgc2VsZWN0ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXR1cm4gZnVuZHMgdG8gUGxheWVyIDFcbiAgICAgICAgICBpZiAocGxheWVyMVdhbGxldCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFJldHVybmluZyAke3BsYXllcjFCZXR9IEFQVCB0byBQbGF5ZXIgMSBmcm9tIGVzY3Jvd2ApO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZDEgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogXCIweDE6OmNvaW46OnRyYW5zZmVyXCIsXG4gICAgICAgICAgICAgIHR5cGVfYXJndW1lbnRzOiBbXCIweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pblwiXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBbcGxheWVyMVdhbGxldC5hZGRyZXNzLCBNYXRoLmZsb29yKHBsYXllcjFCZXQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlMSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24ocGF5bG9hZDEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQbGF5ZXIgMSByZWZ1bmQgdHJhbnNhY3Rpb246XCIsIHR4UmVzcG9uc2UxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmV0dXJuIGZ1bmRzIHRvIFBsYXllciAyXG4gICAgICAgICAgaWYgKHBsYXllcjJXYWxsZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXR1cm5pbmcgJHtwbGF5ZXIyQmV0fSBBUFQgdG8gUGxheWVyIDIgZnJvbSBlc2Nyb3dgKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQyID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgICB0eXBlX2FyZ3VtZW50czogW1wiMHgxOjphcHRvc19jb2luOjpBcHRvc0NvaW5cIl0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogW3BsYXllcjJXYWxsZXQuYWRkcmVzcywgTWF0aC5mbG9vcihwbGF5ZXIyQmV0ICogMTAwMDAwMDAwKS50b1N0cmluZygpXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdHhSZXNwb25zZTIgPSBhd2FpdCB3aW5kb3cuYXB0b3Muc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKHBheWxvYWQyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGxheWVyIDIgcmVmdW5kIHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICAvLyBIYW5kbGUgd2lubmVyIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd2lubmVyV2FsbGV0ID0gd2lubmVyID09PSAncGxheWVyMScgPyBwbGF5ZXIxV2FsbGV0IDogcGxheWVyMldhbGxldDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXdpbm5lcldhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lubmVyIHdhbGxldCBub3QgZm91bmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBUcmFuc2ZlcnJpbmcgJHtmaW5hbEJldEFtb3VudH0gQVBUIHRvIHdpbm5lciAoJHt3aW5uZXJXYWxsZXQuYWRkcmVzc30pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBlc2Nyb3cgd2FsbGV0XG4gICAgICAgICAgd2luZG93LmFsZXJ0KFwiUGxlYXNlIHNlbGVjdCB0aGUgRVNDUk9XIHdhbGxldCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbiB0byBwYXkgdGhlIHdpbm5lci5cIik7XG4gICAgICAgICAgY29uc3QgZXNjcm93V2FsbGV0Q29ubmVjdGVkID0gYXdhaXQgd2luZG93LmFwdG9zLmNvbm5lY3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWVzY3Jvd1dhbGxldENvbm5lY3RlZCB8fCBlc2Nyb3dXYWxsZXRDb25uZWN0ZWQuYWRkcmVzcyAhPT0gZXNjcm93QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gZXNjcm93IHdhbGxldC4gUGxlYXNlIGVuc3VyZSB0aGUgY29ycmVjdCB3YWxsZXQgaXMgc2VsZWN0ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmFuc2ZlciBhbGwgZnVuZHMgZnJvbSBlc2Nyb3cgdG8gd2lubmVyXG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW50cnlfZnVuY3Rpb25fcGF5bG9hZFwiLFxuICAgICAgICAgICAgZnVuY3Rpb246IFwiMHgxOjpjb2luOjp0cmFuc2ZlclwiLFxuICAgICAgICAgICAgdHlwZV9hcmd1bWVudHM6IFtcIjB4MTo6YXB0b3NfY29pbjo6QXB0b3NDb2luXCJdLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbd2lubmVyV2FsbGV0LmFkZHJlc3MsIE1hdGguZmxvb3IoZmluYWxCZXRBbW91bnQgKiAxMDAwMDAwMDApLnRvU3RyaW5nKCldXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0eFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmFwdG9zLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldpbm5lciBwYXltZW50IHRyYW5zYWN0aW9uOlwiLCB0eFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBsYXllciBiYWxhbmNlcyBhZnRlciB0cmFuc2ZlcnNcbiAgICAgICAgaWYgKHBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICBhd2FpdCBnZXRBY2NvdW50QmFsYW5jZShwbGF5ZXIxV2FsbGV0LmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocGxheWVyMldhbGxldCkge1xuICAgICAgICAgIGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHBsYXllcjJXYWxsZXQuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICAvLyBTaW11bGF0aW9uIG1vZGUgaGFuZGxpbmdcbiAgICAgIGVsc2UgaWYgKHVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRHJhdyBnYW1lIC0gYm90aCBwbGF5ZXJzIHJlY2VpdmUgdGhlaXIgYmV0cyBiYWNrIChzaW11bGF0aW9uKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgUGxheWVyICR7d2lubmVyID09PSAncGxheWVyMScgPyAnMScgOiAnMid9IHdhbGxldCBiYWxhbmNlOiArJHtmaW5hbEJldEFtb3VudH0gQVBUIChzaW11bGF0aW9uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiV2lubmVyIHBheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGF5aW5nIHdpbm5lcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBwYXkgd2lubmVyXCIpO1xuICAgIH1cbiAgfSwgW3VzZVNpbXVsYXRpb25Nb2RlLCBlc2Nyb3dMb2NrZWQsIGVzY3Jvd0FkZHJlc3NdKTtcblxuICAvLyBSZXNldCBlc2Nyb3cgc3RhdGVcbiAgY29uc3QgcmVzZXRFc2Nyb3dTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRQbGF5ZXIyRXNjcm93TG9ja2VkKGZhbHNlKTtcbiAgICBzZXRFc2Nyb3dMb2NrZWQoZmFsc2UpO1xuICAgIHNldEVzY3Jvd1N0YXR1cyhFc2Nyb3dTdGF0dXMuUEVORElORyk7XG4gICAgc2V0RXNjcm93QmFsYW5jZSgwKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgdXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgc2V0VXNlU2ltdWxhdGlvbk1vZGUsXG4gICAgZXNjcm93TG9ja2VkLFxuICAgIHNldEVzY3Jvd0xvY2tlZCxcbiAgICBwbGF5ZXIxRXNjcm93TG9ja2VkLCBcbiAgICBzZXRQbGF5ZXIxRXNjcm93TG9ja2VkLFxuICAgIHBsYXllcjJFc2Nyb3dMb2NrZWQsXG4gICAgc2V0UGxheWVyMkVzY3Jvd0xvY2tlZCxcbiAgICBlc2Nyb3dBZGRyZXNzLFxuICAgIHNldEVzY3Jvd0FkZHJlc3MsXG4gICAgZXNjcm93U3RhdHVzLFxuICAgIHNldEVzY3Jvd1N0YXR1cyxcbiAgICBlc2Nyb3dCYWxhbmNlLFxuICAgIHNldEVzY3Jvd0JhbGFuY2UsXG4gICAgaXNMb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHNldEVycm9yLFxuICAgIGluaXRpYWxpemVFc2Nyb3csXG4gICAgY3JlYXRlU2ltdWxhdGVkRXNjcm93LFxuICAgIGNvbm5lY3RFc2Nyb3dXYWxsZXQsXG4gICAgbG9ja0VzY3JvdyxcbiAgICBwYXlXaW5uZXIsXG4gICAgcmVzZXRFc2Nyb3dTdGF0ZSxcbiAgICBlc2Nyb3dBZGFwdGVyXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsIkVzY3Jvd0NvbnRyYWN0QWRhcHRlciIsIkVzY3Jvd1N0YXR1cyIsInVzZUVzY3JvdyIsImVzY3Jvd0FkYXB0ZXIiLCJ1c2VTaW11bGF0aW9uTW9kZSIsInNldFVzZVNpbXVsYXRpb25Nb2RlIiwiZXNjcm93TG9ja2VkIiwic2V0RXNjcm93TG9ja2VkIiwicGxheWVyMUVzY3Jvd0xvY2tlZCIsInNldFBsYXllcjFFc2Nyb3dMb2NrZWQiLCJwbGF5ZXIyRXNjcm93TG9ja2VkIiwic2V0UGxheWVyMkVzY3Jvd0xvY2tlZCIsImVzY3Jvd0FkZHJlc3MiLCJzZXRFc2Nyb3dBZGRyZXNzIiwiZXNjcm93U3RhdHVzIiwic2V0RXNjcm93U3RhdHVzIiwiUEVORElORyIsImVzY3Jvd0JhbGFuY2UiLCJzZXRFc2Nyb3dCYWxhbmNlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxpemVFc2Nyb3ciLCJwbGF5ZXIxV2FsbGV0IiwicGxheWVyMldhbGxldCIsImNvbnNvbGUiLCJsb2ciLCJzaW11bGF0ZWRBZGRyZXNzIiwiRGF0ZSIsIm5vdyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNpbUVycm9yIiwid2luZG93IiwiYWxlcnQiLCJyZXNwb25zZSIsImFwdG9zIiwiY29ubmVjdCIsImFkZHJlc3MiLCJjcmVhdGVFc2Nyb3dSZXN1bHQiLCJjcmVhdGVFc2Nyb3ciLCJ3YXJuIiwiRXJyb3IiLCJtZXNzYWdlIiwiY3JlYXRlU2ltdWxhdGVkRXNjcm93IiwiY29ubmVjdEVzY3Jvd1dhbGxldCIsImxvY2tFc2Nyb3ciLCJwbGF5ZXJOdW1iZXIiLCJwbGF5ZXIxQmV0IiwicGxheWVyMkJldCIsImVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQiLCJnZXRBY2NvdW50QmFsYW5jZSIsInRyYW5zZmVyVG9Fc2Nyb3ciLCJtaW5pbXVtQmV0IiwiTWF0aCIsIm1pbiIsInBsYXllcldhbGxldCIsInByZXZCYWxhbmNlIiwiaXNXYWxsZXRDb25uZWN0ZWQiLCJ0cmFuc2ZlclN1Y2Nlc3MiLCJuZXdCYWxhbmNlIiwiZXNjcm93QmFsYW5jZVJlc3VsdCIsImJvdGhQbGF5ZXJzTG9ja2VkIiwiZmluYWxQb29sQW1vdW50Iiwid2FzTG9ja2VkIiwicGF5V2lubmVyIiwid2lubmVyIiwiZmluYWxCZXRBbW91bnQiLCJlc2Nyb3dXYWxsZXRDb25uZWN0ZWQiLCJwYXlsb2FkMSIsInR5cGUiLCJmdW5jdGlvbiIsInR5cGVfYXJndW1lbnRzIiwiYXJndW1lbnRzIiwiZmxvb3IiLCJ0b1N0cmluZyIsInR4UmVzcG9uc2UxIiwic2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uIiwicGF5bG9hZDIiLCJ0eFJlc3BvbnNlMiIsIndpbm5lcldhbGxldCIsInBheWxvYWQiLCJ0eFJlc3BvbnNlIiwicmVzZXRFc2Nyb3dTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/hooks/useEscrow.ts\n"));

/***/ }),

/***/ "./src/hooks/useWalletConnection.ts":
/*!******************************************!*\
  !*** ./src/hooks/useWalletConnection.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useWalletConnection: function() { return /* binding */ useWalletConnection; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var aptos__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aptos */ \"./node_modules/aptos/dist/index.mjs\");\n\n\n// Define hook for wallet connection management\nfunction useWalletConnection() {\n    const [player1Wallet, setPlayer1Wallet] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [player2Wallet, setPlayer2Wallet] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [client] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new aptos__WEBPACK_IMPORTED_MODULE_1__.AptosClient(\"https://fullnode.testnet.aptoslabs.com/v1\"));\n    // Get wallet balance\n    const getAccountBalance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (address)=>{\n        try {\n            const resources = await client.getAccountResources(address);\n            const aptosCoinResource = resources.find((r)=>r.type === \"0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>\");\n            if (aptosCoinResource) {\n                const balance = aptosCoinResource.data.coin.value;\n                // Convert from octas (10^8) to APT\n                return Number(balance) / 100000000;\n            }\n            return 0;\n        } catch (error) {\n            console.error(\"Error getting account balance:\", error);\n            return 0;\n        }\n    }, [\n        client\n    ]);\n    // Connect player wallet\n    const connectPlayerWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (playerNumber)=>{\n        // Prevent multiple connection attempts\n        if (isLoading) {\n            console.log(\"Connection already in progress, ignoring duplicate request\");\n            return;\n        }\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Connecting wallet for Player \".concat(playerNumber, \"...\"));\n            // Make sure there's a global aptos object\n            if ( false || !window.aptos) {\n                setError(\"Petra wallet is not installed. Please install the Petra wallet extension from https://petra.app/ and refresh the page.\");\n                setIsLoading(false);\n                return;\n            }\n            // Check if this player's wallet is already connected\n            const playerWallet = playerNumber === 1 ? player1Wallet : player2Wallet;\n            if (playerWallet) {\n                console.log(\"Player \".concat(playerNumber, \"'s wallet is already connected:\"), playerWallet.address);\n                setIsLoading(false);\n                return;\n            }\n            // Show the correct prompt based on player number\n            window.alert(\"Please make sure Player \".concat(playerNumber, \"'s wallet is selected in your Petra extension.\"));\n            // Direct connection approach - simplest and most reliable\n            try {\n                const response = await window.aptos.connect();\n                console.log(\"Wallet connection response for Player \".concat(playerNumber, \":\"), response);\n                if (response && response.address) {\n                    console.log(\"Connected to wallet for Player \".concat(playerNumber, \":\"), response.address);\n                    // Check if this wallet is already connected as the other player\n                    const otherPlayerWallet = playerNumber === 1 ? player2Wallet : player1Wallet;\n                    if (otherPlayerWallet && otherPlayerWallet.address === response.address) {\n                        const confirmUse = window.confirm(\"WARNING: This wallet (\".concat(response.address.substring(0, 6), \"...\").concat(response.address.substring(response.address.length - 4), \") is already connected as Player \").concat(playerNumber === 1 ? \"2\" : \"1\", \".\\n\\n\") + \"Using the same wallet for both players is NOT recommended for real games.\\n\\n\" + \"Do you want to continue using this wallet for both players?\");\n                        if (!confirmUse) {\n                            throw new Error(\"Please connect a different wallet for Player \".concat(playerNumber, \". Go to your Petra extension and switch accounts first.\"));\n                        }\n                        console.log(\"User confirmed using the same wallet for both players: \".concat(response.address));\n                    }\n                    // Get wallet balance\n                    const balance = await getAccountBalance(response.address);\n                    // Set the wallet in state\n                    const walletInfo = {\n                        address: response.address,\n                        balance: balance\n                    };\n                    if (playerNumber === 1) {\n                        setPlayer1Wallet(walletInfo);\n                    } else {\n                        setPlayer2Wallet(walletInfo);\n                    }\n                    console.log(\"Successfully set Player \".concat(playerNumber, \"'s wallet\"));\n                } else {\n                    throw new Error(\"Failed to get wallet address\");\n                }\n            } catch (error) {\n                console.error(\"Error connecting wallet for Player \".concat(playerNumber, \":\"), error);\n                throw new Error(\"Failed to connect wallet: \".concat(error.message || \"Unknown error\"));\n            }\n        } catch (error) {\n            console.error(\"Error in wallet connection for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to connect wallet for Player \".concat(playerNumber));\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        player1Wallet,\n        player2Wallet,\n        isLoading,\n        getAccountBalance\n    ]);\n    // Connect Player 2 Wallet with special handling\n    const connectPlayer2Wallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        // Show detailed instructions for switching wallets\n        if (player1Wallet) {\n            const walletPreface = player1Wallet.address.substring(0, 6) + \"...\" + player1Wallet.address.substring(player1Wallet.address.length - 4);\n        }\n        // Now try to connect Player 2's wallet\n        connectPlayerWallet(2);\n    }, [\n        player1Wallet,\n        connectPlayerWallet\n    ]);\n    // Disconnect wallet\n    const disconnectWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((playerNumber)=>{\n        if (playerNumber === 1) {\n            setPlayer1Wallet(null);\n        } else {\n            setPlayer2Wallet(null);\n        }\n        // Try to disconnect from the Petra wallet if available\n        if (window && window.aptos && typeof window.aptos.disconnect === \"function\") {\n            window.aptos.disconnect().catch(console.error);\n        }\n    }, []);\n    // Reset all wallet connections\n    const resetWalletConnections = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            setIsLoading(true);\n            console.log(\"Resetting wallet connections...\");\n            // Disconnect if possible\n            if (window && window.aptos && typeof window.aptos.disconnect === \"function\") {\n                await window.aptos.disconnect().catch(console.error);\n            }\n            // Reset state\n            setPlayer1Wallet(null);\n            setPlayer2Wallet(null);\n            console.log(\"Wallet connections reset successfully\");\n        } catch (error) {\n            console.error(\"Error resetting wallet connections:\", error);\n            setError(\"Failed to reset wallet connections. Please refresh the page.\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, []);\n    // Set a manual wallet address (for simulation)\n    const setManualWalletAddress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((playerNumber)=>{\n        // Prompt user for wallet address\n        const address = window.prompt(\"Enter wallet address for Player \".concat(playerNumber, \":\"));\n        if (!address || address.trim() === \"\") {\n            console.log(\"No address provided, cancelling manual wallet setup\");\n            return;\n        }\n        try {\n            console.log(\"Setting manual wallet address for Player \".concat(playerNumber, \": \").concat(address));\n            // Create wallet info with the provided address\n            // We'll assume a balance of 10 APT for testing purposes\n            const walletInfo = {\n                address: address.trim(),\n                balance: 10 // Default balance for testing\n            };\n            // Set the wallet for the appropriate player\n            if (playerNumber === 1) {\n                setPlayer1Wallet(walletInfo);\n            } else {\n                setPlayer2Wallet(walletInfo);\n            }\n        } catch (error) {\n            console.error(\"Error setting manual wallet for Player \".concat(playerNumber, \":\"), error);\n            setError(error.message || \"Failed to set manual wallet for Player \".concat(playerNumber));\n        }\n    }, []);\n    // Function to ensure the correct wallet is connected\n    const ensureCorrectWalletConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (playerNumber)=>{\n        console.log(\"Ensuring wallet for Player \".concat(playerNumber, \" is connected\"));\n        try {\n            console.log(\"Attempting to connect to Player \".concat(playerNumber, \"'s wallet\"));\n            // Prompt user to switch to the correct wallet\n            window.alert(\"Please make sure Player \".concat(playerNumber, \"'s wallet is selected in your Petra extension.\"));\n            const response = await window.aptos.connect();\n            if (response && response.address) {\n                console.log(\"Connected to wallet with address: \".concat(response.address));\n                return true;\n            } else {\n                console.error(\"Failed to get wallet address\");\n                return false;\n            }\n        } catch (error) {\n            console.error(\"Error connecting to Player \".concat(playerNumber, \"'s wallet:\"), error);\n            return false;\n        }\n    }, []);\n    return {\n        player1Wallet,\n        player2Wallet,\n        isLoading,\n        error,\n        setError,\n        getAccountBalance,\n        connectPlayerWallet,\n        connectPlayer2Wallet,\n        disconnectWallet,\n        resetWalletConnections,\n        setManualWalletAddress,\n        ensureCorrectWalletConnected,\n        client\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPQSxPQUFPO1lBQ2RnQixRQUFRaEIsS0FBSyxDQUFDLDhCQUEyQyxPQUFia0IsY0FBYSxlQUFhbEI7WUFDdEUsT0FBTztRQUNUO0lBQ0YsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMTjtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBQztRQUNBRTtRQUNBYztRQUNBaUI7UUFDQUU7UUFDQUc7UUFDQUM7UUFDQUc7UUFDQXpDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlV2FsbGV0Q29ubmVjdGlvbi50cz84NzZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwdG9zQ2xpZW50IH0gZnJvbSAnYXB0b3MnO1xuaW1wb3J0IHsgUGxheWVyV2FsbGV0SW5mbyB9IGZyb20gJy4uL3R5cGVzL2dhbWUnO1xuXG4vLyBEZWZpbmUgaG9vayBmb3Igd2FsbGV0IGNvbm5lY3Rpb24gbWFuYWdlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldENvbm5lY3Rpb24oKSB7XG4gIGNvbnN0IFtwbGF5ZXIxV2FsbGV0LCBzZXRQbGF5ZXIxV2FsbGV0XSA9IHVzZVN0YXRlPFBsYXllcldhbGxldEluZm8gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BsYXllcjJXYWxsZXQsIHNldFBsYXllcjJXYWxsZXRdID0gdXNlU3RhdGU8UGxheWVyV2FsbGV0SW5mbyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2xpZW50XSA9IHVzZVN0YXRlPEFwdG9zQ2xpZW50PihuZXcgQXB0b3NDbGllbnQoJ2h0dHBzOi8vZnVsbG5vZGUudGVzdG5ldC5hcHRvc2xhYnMuY29tL3YxJykpO1xuXG4gIC8vIEdldCB3YWxsZXQgYmFsYW5jZVxuICBjb25zdCBnZXRBY2NvdW50QmFsYW5jZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNvdXJjZXMgPSBhd2FpdCBjbGllbnQuZ2V0QWNjb3VudFJlc291cmNlcyhhZGRyZXNzKTtcbiAgICAgIGNvbnN0IGFwdG9zQ29pblJlc291cmNlID0gcmVzb3VyY2VzLmZpbmQoXG4gICAgICAgIChyKSA9PiByLnR5cGUgPT09ICcweDE6OmNvaW46OkNvaW5TdG9yZTwweDE6OmFwdG9zX2NvaW46OkFwdG9zQ29pbj4nXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoYXB0b3NDb2luUmVzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IChhcHRvc0NvaW5SZXNvdXJjZS5kYXRhIGFzIGFueSkuY29pbi52YWx1ZTtcbiAgICAgICAgLy8gQ29udmVydCBmcm9tIG9jdGFzICgxMF44KSB0byBBUFRcbiAgICAgICAgcmV0dXJuIE51bWJlcihiYWxhbmNlKSAvIDEwMDAwMDAwMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGFjY291bnQgYmFsYW5jZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIFtjbGllbnRdKTtcblxuICAvLyBDb25uZWN0IHBsYXllciB3YWxsZXRcbiAgY29uc3QgY29ubmVjdFBsYXllcldhbGxldCA9IHVzZUNhbGxiYWNrKGFzeW5jIChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgaWYgKGlzTG9hZGluZykge1xuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGlnbm9yaW5nIGR1cGxpY2F0ZSByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBDb25uZWN0aW5nIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfS4uLmApO1xuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlcmUncyBhIGdsb2JhbCBhcHRvcyBvYmplY3RcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LmFwdG9zKSB7XG4gICAgICAgIHNldEVycm9yKFwiUGV0cmEgd2FsbGV0IGlzIG5vdCBpbnN0YWxsZWQuIFBsZWFzZSBpbnN0YWxsIHRoZSBQZXRyYSB3YWxsZXQgZXh0ZW5zaW9uIGZyb20gaHR0cHM6Ly9wZXRyYS5hcHAvIGFuZCByZWZyZXNoIHRoZSBwYWdlLlwiKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHBsYXllcidzIHdhbGxldCBpcyBhbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgY29uc3QgcGxheWVyV2FsbGV0ID0gcGxheWVyTnVtYmVyID09PSAxID8gcGxheWVyMVdhbGxldCA6IHBsYXllcjJXYWxsZXQ7XG4gICAgICBpZiAocGxheWVyV2FsbGV0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9J3Mgd2FsbGV0IGlzIGFscmVhZHkgY29ubmVjdGVkOmAsIHBsYXllcldhbGxldC5hZGRyZXNzKTtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IHRoZSBjb3JyZWN0IHByb21wdCBiYXNlZCBvbiBwbGF5ZXIgbnVtYmVyXG4gICAgICB3aW5kb3cuYWxlcnQoYFBsZWFzZSBtYWtlIHN1cmUgUGxheWVyICR7cGxheWVyTnVtYmVyfSdzIHdhbGxldCBpcyBzZWxlY3RlZCBpbiB5b3VyIFBldHJhIGV4dGVuc2lvbi5gKTtcbiAgICAgIFxuICAgICAgLy8gRGlyZWN0IGNvbm5lY3Rpb24gYXBwcm9hY2ggLSBzaW1wbGVzdCBhbmQgbW9zdCByZWxpYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuYXB0b3MuY29ubmVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgV2FsbGV0IGNvbm5lY3Rpb24gcmVzcG9uc2UgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgcmVzcG9uc2UpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmFkZHJlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHRvIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfTpgLCByZXNwb25zZS5hZGRyZXNzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHdhbGxldCBpcyBhbHJlYWR5IGNvbm5lY3RlZCBhcyB0aGUgb3RoZXIgcGxheWVyXG4gICAgICAgICAgY29uc3Qgb3RoZXJQbGF5ZXJXYWxsZXQgPSBwbGF5ZXJOdW1iZXIgPT09IDEgPyBwbGF5ZXIyV2FsbGV0IDogcGxheWVyMVdhbGxldDtcbiAgICAgICAgICBpZiAob3RoZXJQbGF5ZXJXYWxsZXQgJiYgb3RoZXJQbGF5ZXJXYWxsZXQuYWRkcmVzcyA9PT0gcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlybVVzZSA9IHdpbmRvdy5jb25maXJtKFxuICAgICAgICAgICAgICBgV0FSTklORzogVGhpcyB3YWxsZXQgKCR7cmVzcG9uc2UuYWRkcmVzcy5zdWJzdHJpbmcoMCwgNil9Li4uJHtyZXNwb25zZS5hZGRyZXNzLnN1YnN0cmluZyhyZXNwb25zZS5hZGRyZXNzLmxlbmd0aCAtIDQpfSkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgYXMgUGxheWVyICR7cGxheWVyTnVtYmVyID09PSAxID8gJzInIDogJzEnfS5cXG5cXG5gICtcbiAgICAgICAgICAgICAgYFVzaW5nIHRoZSBzYW1lIHdhbGxldCBmb3IgYm90aCBwbGF5ZXJzIGlzIE5PVCByZWNvbW1lbmRlZCBmb3IgcmVhbCBnYW1lcy5cXG5cXG5gICtcbiAgICAgICAgICAgICAgYERvIHlvdSB3YW50IHRvIGNvbnRpbnVlIHVzaW5nIHRoaXMgd2FsbGV0IGZvciBib3RoIHBsYXllcnM/YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFjb25maXJtVXNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGNvbm5lY3QgYSBkaWZmZXJlbnQgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9LiBHbyB0byB5b3VyIFBldHJhIGV4dGVuc2lvbiBhbmQgc3dpdGNoIGFjY291bnRzIGZpcnN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVXNlciBjb25maXJtZWQgdXNpbmcgdGhlIHNhbWUgd2FsbGV0IGZvciBib3RoIHBsYXllcnM6ICR7cmVzcG9uc2UuYWRkcmVzc31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHdhbGxldCBiYWxhbmNlXG4gICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGdldEFjY291bnRCYWxhbmNlKHJlc3BvbnNlLmFkZHJlc3MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0aGUgd2FsbGV0IGluIHN0YXRlXG4gICAgICAgICAgY29uc3Qgd2FsbGV0SW5mbzogUGxheWVyV2FsbGV0SW5mbyA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHJlc3BvbnNlLmFkZHJlc3MsXG4gICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlXG4gICAgICAgICAgfTtcbiAgICAgIFxuICAgICAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgICAgIHNldFBsYXllcjFXYWxsZXQod2FsbGV0SW5mbyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFBsYXllcjJXYWxsZXQod2FsbGV0SW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc2V0IFBsYXllciAke3BsYXllck51bWJlcn0ncyB3YWxsZXRgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHdhbGxldCBhZGRyZXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNvbm5lY3Rpbmcgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQ6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiB3YWxsZXQgY29ubmVjdGlvbiBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfTpgLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlIHx8IGBGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtwbGF5ZXIxV2FsbGV0LCBwbGF5ZXIyV2FsbGV0LCBpc0xvYWRpbmcsIGdldEFjY291bnRCYWxhbmNlXSk7XG5cbiAgLy8gQ29ubmVjdCBQbGF5ZXIgMiBXYWxsZXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nXG4gIGNvbnN0IGNvbm5lY3RQbGF5ZXIyV2FsbGV0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIC8vIFNob3cgZGV0YWlsZWQgaW5zdHJ1Y3Rpb25zIGZvciBzd2l0Y2hpbmcgd2FsbGV0c1xuICAgIGlmIChwbGF5ZXIxV2FsbGV0KSB7XG4gICAgICBjb25zdCB3YWxsZXRQcmVmYWNlID0gcGxheWVyMVdhbGxldC5hZGRyZXNzLnN1YnN0cmluZygwLCA2KSArIFwiLi4uXCIgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcjFXYWxsZXQuYWRkcmVzcy5zdWJzdHJpbmcocGxheWVyMVdhbGxldC5hZGRyZXNzLmxlbmd0aCAtIDQpO1xuICAgICAgXG4gICAgIFxuICAgIH1cbiAgICBcbiAgICAvLyBOb3cgdHJ5IHRvIGNvbm5lY3QgUGxheWVyIDIncyB3YWxsZXRcbiAgICBjb25uZWN0UGxheWVyV2FsbGV0KDIpO1xuICB9LCBbcGxheWVyMVdhbGxldCwgY29ubmVjdFBsYXllcldhbGxldF0pO1xuXG4gIC8vIERpc2Nvbm5lY3Qgd2FsbGV0XG4gIGNvbnN0IGRpc2Nvbm5lY3RXYWxsZXQgPSB1c2VDYWxsYmFjaygocGxheWVyTnVtYmVyOiAxIHwgMikgPT4ge1xuICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgIHNldFBsYXllcjFXYWxsZXQobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFBsYXllcjJXYWxsZXQobnVsbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBkaXNjb25uZWN0IGZyb20gdGhlIFBldHJhIHdhbGxldCBpZiBhdmFpbGFibGVcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5hcHRvcyAmJiB0eXBlb2Ygd2luZG93LmFwdG9zLmRpc2Nvbm5lY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5hcHRvcy5kaXNjb25uZWN0KCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gUmVzZXQgYWxsIHdhbGxldCBjb25uZWN0aW9uc1xuICBjb25zdCByZXNldFdhbGxldENvbm5lY3Rpb25zID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlc2V0dGluZyB3YWxsZXQgY29ubmVjdGlvbnMuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIERpc2Nvbm5lY3QgaWYgcG9zc2libGVcbiAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmFwdG9zICYmIHR5cGVvZiB3aW5kb3cuYXB0b3MuZGlzY29ubmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhd2FpdCB3aW5kb3cuYXB0b3MuZGlzY29ubmVjdCgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXNldCBzdGF0ZVxuICAgICAgc2V0UGxheWVyMVdhbGxldChudWxsKTtcbiAgICAgIHNldFBsYXllcjJXYWxsZXQobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FsbGV0IGNvbm5lY3Rpb25zIHJlc2V0IHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzZXR0aW5nIHdhbGxldCBjb25uZWN0aW9uczpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gcmVzZXQgd2FsbGV0IGNvbm5lY3Rpb25zLiBQbGVhc2UgcmVmcmVzaCB0aGUgcGFnZS5cIik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2V0IGEgbWFudWFsIHdhbGxldCBhZGRyZXNzIChmb3Igc2ltdWxhdGlvbilcbiAgY29uc3Qgc2V0TWFudWFsV2FsbGV0QWRkcmVzcyA9IHVzZUNhbGxiYWNrKChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgLy8gUHJvbXB0IHVzZXIgZm9yIHdhbGxldCBhZGRyZXNzXG4gICAgY29uc3QgYWRkcmVzcyA9IHdpbmRvdy5wcm9tcHQoYEVudGVyIHdhbGxldCBhZGRyZXNzIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OmApO1xuICAgIFxuICAgIGlmICghYWRkcmVzcyB8fCBhZGRyZXNzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gYWRkcmVzcyBwcm92aWRlZCwgY2FuY2VsbGluZyBtYW51YWwgd2FsbGV0IHNldHVwXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFNldHRpbmcgbWFudWFsIHdhbGxldCBhZGRyZXNzIGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9OiAke2FkZHJlc3N9YCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB3YWxsZXQgaW5mbyB3aXRoIHRoZSBwcm92aWRlZCBhZGRyZXNzXG4gICAgICAvLyBXZSdsbCBhc3N1bWUgYSBiYWxhbmNlIG9mIDEwIEFQVCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgICAgY29uc3Qgd2FsbGV0SW5mbzogUGxheWVyV2FsbGV0SW5mbyA9IHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcy50cmltKCksXG4gICAgICAgIGJhbGFuY2U6IDEwIC8vIERlZmF1bHQgYmFsYW5jZSBmb3IgdGVzdGluZ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHRoZSB3YWxsZXQgZm9yIHRoZSBhcHByb3ByaWF0ZSBwbGF5ZXJcbiAgICAgIGlmIChwbGF5ZXJOdW1iZXIgPT09IDEpIHtcbiAgICAgICAgc2V0UGxheWVyMVdhbGxldCh3YWxsZXRJbmZvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFBsYXllcjJXYWxsZXQod2FsbGV0SW5mbyk7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzZXR0aW5nIG1hbnVhbCB3YWxsZXQgZm9yIFBsYXllciAke3BsYXllck51bWJlcn06YCwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSB8fCBgRmFpbGVkIHRvIHNldCBtYW51YWwgd2FsbGV0IGZvciBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9YCk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gRnVuY3Rpb24gdG8gZW5zdXJlIHRoZSBjb3JyZWN0IHdhbGxldCBpcyBjb25uZWN0ZWRcbiAgY29uc3QgZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZCA9IHVzZUNhbGxiYWNrKGFzeW5jIChwbGF5ZXJOdW1iZXI6IDEgfCAyKSA9PiB7XG4gICAgY29uc29sZS5sb2coYEVuc3VyaW5nIHdhbGxldCBmb3IgUGxheWVyICR7cGxheWVyTnVtYmVyfSBpcyBjb25uZWN0ZWRgKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9J3Mgd2FsbGV0YCk7XG4gICAgICBcbiAgICAgIC8vIFByb21wdCB1c2VyIHRvIHN3aXRjaCB0byB0aGUgY29ycmVjdCB3YWxsZXRcbiAgICAgIHdpbmRvdy5hbGVydChgUGxlYXNlIG1ha2Ugc3VyZSBQbGF5ZXIgJHtwbGF5ZXJOdW1iZXJ9J3Mgd2FsbGV0IGlzIHNlbGVjdGVkIGluIHlvdXIgUGV0cmEgZXh0ZW5zaW9uLmApO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5hcHRvcy5jb25uZWN0KCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYWRkcmVzcykge1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGVkIHRvIHdhbGxldCB3aXRoIGFkZHJlc3M6ICR7cmVzcG9uc2UuYWRkcmVzc31gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCB3YWxsZXQgYWRkcmVzc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb25uZWN0aW5nIHRvIFBsYXllciAke3BsYXllck51bWJlcn0ncyB3YWxsZXQ6YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgcGxheWVyMVdhbGxldCxcbiAgICBwbGF5ZXIyV2FsbGV0LFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBzZXRFcnJvcixcbiAgICBnZXRBY2NvdW50QmFsYW5jZSxcbiAgICBjb25uZWN0UGxheWVyV2FsbGV0LFxuICAgIGNvbm5lY3RQbGF5ZXIyV2FsbGV0LFxuICAgIGRpc2Nvbm5lY3RXYWxsZXQsXG4gICAgcmVzZXRXYWxsZXRDb25uZWN0aW9ucyxcbiAgICBzZXRNYW51YWxXYWxsZXRBZGRyZXNzLFxuICAgIGVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQsXG4gICAgY2xpZW50XG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiQXB0b3NDbGllbnQiLCJ1c2VXYWxsZXRDb25uZWN0aW9uIiwicGxheWVyMVdhbGxldCIsInNldFBsYXllcjFXYWxsZXQiLCJwbGF5ZXIyV2FsbGV0Iiwic2V0UGxheWVyMldhbGxldCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjbGllbnQiLCJnZXRBY2NvdW50QmFsYW5jZSIsImFkZHJlc3MiLCJyZXNvdXJjZXMiLCJnZXRBY2NvdW50UmVzb3VyY2VzIiwiYXB0b3NDb2luUmVzb3VyY2UiLCJmaW5kIiwiciIsInR5cGUiLCJiYWxhbmNlIiwiZGF0YSIsImNvaW4iLCJ2YWx1ZSIsIk51bWJlciIsImNvbnNvbGUiLCJjb25uZWN0UGxheWVyV2FsbGV0IiwicGxheWVyTnVtYmVyIiwibG9nIiwid2luZG93IiwiYXB0b3MiLCJwbGF5ZXJXYWxsZXQiLCJhbGVydCIsInJlc3BvbnNlIiwiY29ubmVjdCIsIm90aGVyUGxheWVyV2FsbGV0IiwiY29uZmlybVVzZSIsImNvbmZpcm0iLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJFcnJvciIsIndhbGxldEluZm8iLCJtZXNzYWdlIiwiY29ubmVjdFBsYXllcjJXYWxsZXQiLCJ3YWxsZXRQcmVmYWNlIiwiZGlzY29ubmVjdFdhbGxldCIsImRpc2Nvbm5lY3QiLCJjYXRjaCIsInJlc2V0V2FsbGV0Q29ubmVjdGlvbnMiLCJzZXRNYW51YWxXYWxsZXRBZGRyZXNzIiwicHJvbXB0IiwidHJpbSIsImVuc3VyZUNvcnJlY3RXYWxsZXRDb25uZWN0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useWalletConnection.ts\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aptos-labs/wallet-adapter-react */ \"./node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs\");\n/* harmony import */ var _components_LoadingComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/LoadingComponent */ \"./src/components/LoadingComponent.tsx\");\n/* harmony import */ var _components_PlayerPanel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/PlayerPanel */ \"./src/components/PlayerPanel.tsx\");\n/* harmony import */ var _components_ChessGamePanel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/ChessGamePanel */ \"./src/components/ChessGamePanel.tsx\");\n/* harmony import */ var _components_EscrowPanel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/EscrowPanel */ \"./src/components/EscrowPanel.tsx\");\n/* harmony import */ var _utils_transactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/transactions */ \"./src/utils/transactions.ts\");\n/* harmony import */ var _hooks_useWalletConnection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../hooks/useWalletConnection */ \"./src/hooks/useWalletConnection.ts\");\n/* harmony import */ var _hooks_useEscrow__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../hooks/useEscrow */ \"./src/hooks/useEscrow.ts\");\n/* harmony import */ var _hooks_useChessGame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../hooks/useChessGame */ \"./src/hooks/useChessGame.ts\");\n/* harmony import */ var _hooks_useBetting__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../hooks/useBetting */ \"./src/hooks/useBetting.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n// Import custom hooks\n\n\n\n\nfunction Home() {\n    _s();\n    // Use wallet adapter from Aptos\n    const { signAndSubmitTransaction, disconnect, connected, account } = (0,_aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet)();\n    // Use our custom hooks for different aspects of the application\n    const walletHook = (0,_hooks_useWalletConnection__WEBPACK_IMPORTED_MODULE_9__.useWalletConnection)();\n    const escrowHook = (0,_hooks_useEscrow__WEBPACK_IMPORTED_MODULE_10__.useEscrow)();\n    const gameHook = (0,_hooks_useChessGame__WEBPACK_IMPORTED_MODULE_11__.useChessGame)();\n    const bettingHook = (0,_hooks_useBetting__WEBPACK_IMPORTED_MODULE_12__.useBetting)();\n    // Initialize escrow when both wallets are connected\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (walletHook.player1Wallet && walletHook.player2Wallet && !escrowHook.escrowAddress && !walletHook.isLoading) {\n            console.log(\"Both wallets connected, initializing escrow\");\n            // In simulation mode, create a simulated escrow automatically\n            if (escrowHook.useSimulationMode) {\n                escrowHook.createSimulatedEscrow();\n            }\n        }\n    }, [\n        walletHook.player1Wallet,\n        walletHook.player2Wallet,\n        escrowHook.escrowAddress,\n        walletHook.isLoading,\n        escrowHook.useSimulationMode\n    ]);\n    // Check if both players have locked their escrow and start the game if they have\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (escrowHook.player1EscrowLocked && escrowHook.player2EscrowLocked && gameHook.gameState !== \"playing\") {\n            // Calculate final bet amount\n            const minBetAmount = Math.min(bettingHook.player1Bet, bettingHook.player2Bet);\n            bettingHook.setFinalBetAmount(minBetAmount * 2);\n            // Update escrow status\n            escrowHook.setEscrowLocked(true);\n            // Start the game\n            gameHook.setGameState(\"playing\");\n        }\n    }, [\n        escrowHook.player1EscrowLocked,\n        escrowHook.player2EscrowLocked,\n        gameHook.gameState,\n        bettingHook\n    ]);\n    // Handle escrow locking from a player\n    const handleLockEscrow = async (playerNumber)=>{\n        // Use the escrow hook to lock the escrow\n        const result = await escrowHook.lockEscrow(playerNumber, walletHook.player1Wallet, walletHook.player2Wallet, bettingHook.player1Bet, bettingHook.player2Bet, walletHook.ensureCorrectWalletConnected, walletHook.getAccountBalance, async (playerNumber, amount, targetAddress)=>{\n            return (0,_utils_transactions__WEBPACK_IMPORTED_MODULE_8__.transferToEscrow)(playerNumber, amount, targetAddress, escrowHook.useSimulationMode);\n        });\n        // If the lock was successful and it was a simulation, update player wallet balances\n        if (result.wasLocked && escrowHook.useSimulationMode) {\n            const minimumBet = Math.min(bettingHook.player1Bet, bettingHook.player2Bet);\n            // Reduce the balance of the player who locked\n            if (playerNumber === 1 && walletHook.player1Wallet) {\n                walletHook.player1Wallet.balance -= minimumBet;\n            } else if (playerNumber === 2 && walletHook.player2Wallet) {\n                walletHook.player2Wallet.balance -= minimumBet;\n            }\n        }\n    };\n    // Announce bets\n    const handleAnnounceUnifiedBet = ()=>{\n        bettingHook.announceUnifiedBet(walletHook.player1Wallet, walletHook.player2Wallet, ()=>gameHook.setGameState(\"betting\"));\n    };\n    // Forfeit the current game\n    const handleForfeit = ()=>{\n        const currentPlayerNumber = gameHook.currentPlayer === \"white\" ? 1 : 2;\n        const winner = gameHook.forfeitGame(currentPlayerNumber);\n        if (winner) {\n            handleGameEnd(winner);\n        }\n    };\n    // Handle game end and payments\n    const handleGameEnd = async (winnerParam)=>{\n        // Determine the winner\n        const winner = winnerParam || gameHook.handleGameEnd();\n        // Pay the winner if escrow is locked\n        if (escrowHook.escrowLocked) {\n            await escrowHook.payWinner(winner, walletHook.player1Wallet, walletHook.player2Wallet, bettingHook.player1Bet, bettingHook.player2Bet, bettingHook.finalBetAmount, walletHook.getAccountBalance);\n            // If we're in simulation mode, update the player balances accordingly\n            if (escrowHook.useSimulationMode) {\n                if (winner === \"draw\") {\n                    // Return the bets to each player\n                    if (walletHook.player1Wallet) {\n                        walletHook.player1Wallet.balance += bettingHook.player1Bet;\n                    }\n                    if (walletHook.player2Wallet) {\n                        walletHook.player2Wallet.balance += bettingHook.player2Bet;\n                    }\n                } else {\n                    // Give the full pot to the winner\n                    if (winner === \"player1\" && walletHook.player1Wallet) {\n                        walletHook.player1Wallet.balance += bettingHook.finalBetAmount;\n                    } else if (winner === \"player2\" && walletHook.player2Wallet) {\n                        walletHook.player2Wallet.balance += bettingHook.finalBetAmount;\n                    }\n                }\n            }\n        }\n        // Reset the game state after a delay\n        setTimeout(()=>{\n            resetAllState();\n        }, 3000);\n    };\n    // Reset all state\n    const resetAllState = ()=>{\n        gameHook.resetGameState();\n        bettingHook.resetBettingState();\n        escrowHook.resetEscrowState();\n    };\n    // Start a new game\n    const handleStartNewGame = ()=>{\n        gameHook.startNewGame();\n        bettingHook.resetBettingState();\n        escrowHook.resetEscrowState();\n    };\n    // Initialize escrow contract\n    const handleInitializeEscrow = ()=>{\n        escrowHook.initializeEscrow(walletHook.player1Wallet, walletHook.player2Wallet);\n    };\n    // Show error panel if there's an error\n    const error = walletHook.error || escrowHook.error || bettingHook.error;\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"container mx-auto px-4 py-8\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 bg-red-50 border border-red-200 rounded-lg max-w-lg mx-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-bold text-red-800 mb-2\",\n                        children: \"Error\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 179,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-red-600 mb-4\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 180,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-3\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>{\n                                    walletHook.setError(null);\n                                    escrowHook.setError(null);\n                                    bettingHook.setError(null);\n                                },\n                                className: \"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\",\n                                children: \"Dismiss\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 182,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: walletHook.resetWalletConnections,\n                                className: \"px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700\",\n                                children: \"Reset Wallet Connections\"\n                            }, void 0, false, {\n                                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                                lineNumber: 192,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 181,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 178,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n            lineNumber: 177,\n            columnNumber: 7\n        }, this);\n    }\n    // Show loading state\n    const isLoading = walletHook.isLoading || escrowHook.isLoading || bettingHook.isLoading;\n    if (isLoading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LoadingComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n            fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n            lineNumber: 207,\n            columnNumber: 12\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"container mx-auto px-4 py-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Chess Game with Aptos\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 213,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Play chess with Aptos blockchain integration\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 215,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 212,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-3xl font-bold text-center mb-8\",\n                children: \"Chess Game with Aptos\"\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 218,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 md:grid-cols-3 gap-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PlayerPanel__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        playerNumber: 1,\n                        playerWallet: walletHook.player1Wallet,\n                        playerBet: bettingHook.player1Bet,\n                        playerEscrowLocked: escrowHook.player1EscrowLocked,\n                        otherPlayerBet: bettingHook.player2Bet,\n                        gameState: gameHook.gameState,\n                        useSimulationMode: escrowHook.useSimulationMode,\n                        onConnectWallet: walletHook.connectPlayerWallet,\n                        onDisconnectWallet: walletHook.disconnectWallet,\n                        onSetManualWalletAddress: walletHook.setManualWalletAddress,\n                        onLockEscrow: ()=>handleLockEscrow(1)\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 222,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ChessGamePanel__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                        game: gameHook.game,\n                        gameState: gameHook.gameState,\n                        currentPlayer: gameHook.currentPlayer,\n                        winner: gameHook.winner,\n                        finalBetAmount: bettingHook.finalBetAmount,\n                        player1Wallet: walletHook.player1Wallet,\n                        player2Wallet: walletHook.player2Wallet,\n                        player1Bet: bettingHook.player1Bet,\n                        player2Bet: bettingHook.player2Bet,\n                        onDrop: gameHook.onDrop,\n                        onAnnounceUnifiedBet: handleAnnounceUnifiedBet,\n                        onStartNewGame: handleStartNewGame,\n                        onForfeit: handleForfeit,\n                        onPlayer1BetChange: bettingHook.setPlayer1Bet,\n                        onPlayer2BetChange: bettingHook.setPlayer2Bet\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 237,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PlayerPanel__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        playerNumber: 2,\n                        playerWallet: walletHook.player2Wallet,\n                        playerBet: bettingHook.player2Bet,\n                        playerEscrowLocked: escrowHook.player2EscrowLocked,\n                        otherPlayerBet: bettingHook.player1Bet,\n                        gameState: gameHook.gameState,\n                        useSimulationMode: escrowHook.useSimulationMode,\n                        onConnectWallet: ()=>walletHook.connectPlayer2Wallet(),\n                        onDisconnectWallet: walletHook.disconnectWallet,\n                        onSetManualWalletAddress: walletHook.setManualWalletAddress,\n                        onLockEscrow: ()=>handleLockEscrow(2)\n                    }, void 0, false, {\n                        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                        lineNumber: 256,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 220,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_EscrowPanel__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                escrowAddress: escrowHook.escrowAddress,\n                escrowStatus: escrowHook.escrowStatus,\n                escrowBalance: escrowHook.escrowBalance,\n                useSimulationMode: escrowHook.useSimulationMode,\n                setUseSimulationMode: escrowHook.setUseSimulationMode,\n                onConnectEscrowWallet: escrowHook.connectEscrowWallet,\n                onDisconnectEscrow: ()=>escrowHook.setEscrowAddress(null),\n                onCreateSimulatedEscrow: escrowHook.createSimulatedEscrow,\n                onInitializeEscrow: handleInitializeEscrow,\n                onResetGame: resetAllState,\n                onResetWallets: walletHook.resetWalletConnections\n            }, void 0, false, {\n                fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n                lineNumber: 272,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ayushsinghchauhan/Downloads/dont_delete/cd3/src/pages/index.tsx\",\n        lineNumber: 211,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"S7pAH5oMpDvY/TN9/vYfWmSvHEM=\", false, function() {\n    return [\n        _aptos_labs_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_3__.useWallet,\n        _hooks_useWalletConnection__WEBPACK_IMPORTED_MODULE_9__.useWalletConnection,\n        _hooks_useEscrow__WEBPACK_IMPORTED_MODULE_10__.useEscrow,\n        _hooks_useChessGame__WEBPACK_IMPORTED_MODULE_11__.useChessGame,\n        _hooks_useBetting__WEBPACK_IMPORTED_MODULE_12__.useBetting\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QywwREFBVUE7OztLQVJSQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvaW5kZXgudHN4PzE5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gJ0BhcHRvcy1sYWJzL3dhbGxldC1hZGFwdGVyLXJlYWN0JztcbmltcG9ydCB7IEdhbWVEYXNoYm9hcmQgfSBmcm9tICcuLi9jb21wb25lbnRzL0dhbWVEYXNoYm9hcmQnO1xuaW1wb3J0IExvYWRpbmdDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9Mb2FkaW5nQ29tcG9uZW50JztcbmltcG9ydCBQbGF5ZXJQYW5lbCBmcm9tICcuLi9jb21wb25lbnRzL1BsYXllclBhbmVsJztcbmltcG9ydCBDaGVzc0dhbWVQYW5lbCBmcm9tICcuLi9jb21wb25lbnRzL0NoZXNzR2FtZVBhbmVsJztcbmltcG9ydCBFc2Nyb3dQYW5lbCBmcm9tICcuLi9jb21wb25lbnRzL0VzY3Jvd1BhbmVsJztcbmltcG9ydCB7IHRyYW5zZmVyVG9Fc2Nyb3cgfSBmcm9tICcuLi91dGlscy90cmFuc2FjdGlvbnMnO1xuXG4vLyBJbXBvcnQgY3VzdG9tIGhvb2tzXG5pbXBvcnQgeyB1c2VXYWxsZXRDb25uZWN0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlV2FsbGV0Q29ubmVjdGlvbic7XG5pbXBvcnQgeyB1c2VFc2Nyb3cgfSBmcm9tICcuLi9ob29rcy91c2VFc2Nyb3cnO1xuaW1wb3J0IHsgdXNlQ2hlc3NHYW1lIH0gZnJvbSAnLi4vaG9va3MvdXNlQ2hlc3NHYW1lJztcbmltcG9ydCB7IHVzZUJldHRpbmcgfSBmcm9tICcuLi9ob29rcy91c2VCZXR0aW5nJztcblxuLy8gQWRkIHR5cGUgZGVjbGFyYXRpb25zIGZvciB0aGUgd2luZG93LmFwdG9zIG9iamVjdFxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBhcHRvczogYW55O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIC8vIFVzZSB3YWxsZXQgYWRhcHRlciBmcm9tIEFwdG9zXG4gIGNvbnN0IHsgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uLCBkaXNjb25uZWN0LCBjb25uZWN0ZWQsIGFjY291bnQgfSA9IHVzZVdhbGxldCgpO1xuICBcbiAgLy8gVXNlIG91ciBjdXN0b20gaG9va3MgZm9yIGRpZmZlcmVudCBhc3BlY3RzIG9mIHRoZSBhcHBsaWNhdGlvblxuICBjb25zdCB3YWxsZXRIb29rID0gdXNlV2FsbGV0Q29ubmVjdGlvbigpO1xuICBjb25zdCBlc2Nyb3dIb29rID0gdXNlRXNjcm93KCk7XG4gIGNvbnN0IGdhbWVIb29rID0gdXNlQ2hlc3NHYW1lKCk7XG4gIGNvbnN0IGJldHRpbmdIb29rID0gdXNlQmV0dGluZygpO1xuXG4gIC8vIEluaXRpYWxpemUgZXNjcm93IHdoZW4gYm90aCB3YWxsZXRzIGFyZSBjb25uZWN0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAod2FsbGV0SG9vay5wbGF5ZXIxV2FsbGV0ICYmIHdhbGxldEhvb2sucGxheWVyMldhbGxldCAmJiAhZXNjcm93SG9vay5lc2Nyb3dBZGRyZXNzICYmICF3YWxsZXRIb29rLmlzTG9hZGluZykge1xuICAgICAgY29uc29sZS5sb2coXCJCb3RoIHdhbGxldHMgY29ubmVjdGVkLCBpbml0aWFsaXppbmcgZXNjcm93XCIpO1xuICAgICAgXG4gICAgICAvLyBJbiBzaW11bGF0aW9uIG1vZGUsIGNyZWF0ZSBhIHNpbXVsYXRlZCBlc2Nyb3cgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGVzY3Jvd0hvb2sudXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgICAgZXNjcm93SG9vay5jcmVhdGVTaW11bGF0ZWRFc2Nyb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQsIHdhbGxldEhvb2sucGxheWVyMldhbGxldCwgZXNjcm93SG9vay5lc2Nyb3dBZGRyZXNzLCB3YWxsZXRIb29rLmlzTG9hZGluZywgZXNjcm93SG9vay51c2VTaW11bGF0aW9uTW9kZV0pO1xuXG4gIC8vIENoZWNrIGlmIGJvdGggcGxheWVycyBoYXZlIGxvY2tlZCB0aGVpciBlc2Nyb3cgYW5kIHN0YXJ0IHRoZSBnYW1lIGlmIHRoZXkgaGF2ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlc2Nyb3dIb29rLnBsYXllcjFFc2Nyb3dMb2NrZWQgJiYgZXNjcm93SG9vay5wbGF5ZXIyRXNjcm93TG9ja2VkICYmIGdhbWVIb29rLmdhbWVTdGF0ZSAhPT0gJ3BsYXlpbmcnKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgZmluYWwgYmV0IGFtb3VudFxuICAgICAgY29uc3QgbWluQmV0QW1vdW50ID0gTWF0aC5taW4oYmV0dGluZ0hvb2sucGxheWVyMUJldCwgYmV0dGluZ0hvb2sucGxheWVyMkJldCk7XG4gICAgICBiZXR0aW5nSG9vay5zZXRGaW5hbEJldEFtb3VudChtaW5CZXRBbW91bnQgKiAyKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGVzY3JvdyBzdGF0dXNcbiAgICAgIGVzY3Jvd0hvb2suc2V0RXNjcm93TG9ja2VkKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBTdGFydCB0aGUgZ2FtZVxuICAgICAgZ2FtZUhvb2suc2V0R2FtZVN0YXRlKCdwbGF5aW5nJyk7XG4gICAgfVxuICB9LCBbZXNjcm93SG9vay5wbGF5ZXIxRXNjcm93TG9ja2VkLCBlc2Nyb3dIb29rLnBsYXllcjJFc2Nyb3dMb2NrZWQsIGdhbWVIb29rLmdhbWVTdGF0ZSwgYmV0dGluZ0hvb2tdKTtcblxuICAvLyBIYW5kbGUgZXNjcm93IGxvY2tpbmcgZnJvbSBhIHBsYXllclxuICBjb25zdCBoYW5kbGVMb2NrRXNjcm93ID0gYXN5bmMgKHBsYXllck51bWJlcjogMSB8IDIpID0+IHtcbiAgICAvLyBVc2UgdGhlIGVzY3JvdyBob29rIHRvIGxvY2sgdGhlIGVzY3Jvd1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzY3Jvd0hvb2subG9ja0VzY3JvdyhcbiAgICAgIHBsYXllck51bWJlcixcbiAgICAgIHdhbGxldEhvb2sucGxheWVyMVdhbGxldCxcbiAgICAgIHdhbGxldEhvb2sucGxheWVyMldhbGxldCxcbiAgICAgIGJldHRpbmdIb29rLnBsYXllcjFCZXQsXG4gICAgICBiZXR0aW5nSG9vay5wbGF5ZXIyQmV0LFxuICAgICAgd2FsbGV0SG9vay5lbnN1cmVDb3JyZWN0V2FsbGV0Q29ubmVjdGVkLFxuICAgICAgd2FsbGV0SG9vay5nZXRBY2NvdW50QmFsYW5jZSxcbiAgICAgIGFzeW5jIChwbGF5ZXJOdW1iZXIsIGFtb3VudCwgdGFyZ2V0QWRkcmVzcykgPT4ge1xuICAgICAgICByZXR1cm4gdHJhbnNmZXJUb0VzY3JvdyhwbGF5ZXJOdW1iZXIsIGFtb3VudCwgdGFyZ2V0QWRkcmVzcywgZXNjcm93SG9vay51c2VTaW11bGF0aW9uTW9kZSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIElmIHRoZSBsb2NrIHdhcyBzdWNjZXNzZnVsIGFuZCBpdCB3YXMgYSBzaW11bGF0aW9uLCB1cGRhdGUgcGxheWVyIHdhbGxldCBiYWxhbmNlc1xuICAgIGlmIChyZXN1bHQud2FzTG9ja2VkICYmIGVzY3Jvd0hvb2sudXNlU2ltdWxhdGlvbk1vZGUpIHtcbiAgICAgIGNvbnN0IG1pbmltdW1CZXQgPSBNYXRoLm1pbihiZXR0aW5nSG9vay5wbGF5ZXIxQmV0LCBiZXR0aW5nSG9vay5wbGF5ZXIyQmV0KTtcbiAgICAgIFxuICAgICAgLy8gUmVkdWNlIHRoZSBiYWxhbmNlIG9mIHRoZSBwbGF5ZXIgd2hvIGxvY2tlZFxuICAgICAgaWYgKHBsYXllck51bWJlciA9PT0gMSAmJiB3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgd2FsbGV0SG9vay5wbGF5ZXIxV2FsbGV0LmJhbGFuY2UgLT0gbWluaW11bUJldDtcbiAgICAgIH0gZWxzZSBpZiAocGxheWVyTnVtYmVyID09PSAyICYmIHdhbGxldEhvb2sucGxheWVyMldhbGxldCkge1xuICAgICAgICB3YWxsZXRIb29rLnBsYXllcjJXYWxsZXQuYmFsYW5jZSAtPSBtaW5pbXVtQmV0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBbm5vdW5jZSBiZXRzXG4gIGNvbnN0IGhhbmRsZUFubm91bmNlVW5pZmllZEJldCA9ICgpID0+IHtcbiAgICBiZXR0aW5nSG9vay5hbm5vdW5jZVVuaWZpZWRCZXQoXG4gICAgICB3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQsXG4gICAgICB3YWxsZXRIb29rLnBsYXllcjJXYWxsZXQsXG4gICAgICAoKSA9PiBnYW1lSG9vay5zZXRHYW1lU3RhdGUoJ2JldHRpbmcnKVxuICAgICk7XG4gIH07XG5cbiAgLy8gRm9yZmVpdCB0aGUgY3VycmVudCBnYW1lXG4gIGNvbnN0IGhhbmRsZUZvcmZlaXQgPSAoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFBsYXllck51bWJlciA9IGdhbWVIb29rLmN1cnJlbnRQbGF5ZXIgPT09ICd3aGl0ZScgPyAxIDogMjtcbiAgICBjb25zdCB3aW5uZXIgPSBnYW1lSG9vay5mb3JmZWl0R2FtZShjdXJyZW50UGxheWVyTnVtYmVyKTtcbiAgICBcbiAgICBpZiAod2lubmVyKSB7XG4gICAgICBoYW5kbGVHYW1lRW5kKHdpbm5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhhbmRsZSBnYW1lIGVuZCBhbmQgcGF5bWVudHNcbiAgY29uc3QgaGFuZGxlR2FtZUVuZCA9IGFzeW5jICh3aW5uZXJQYXJhbT86ICdwbGF5ZXIxJyB8ICdwbGF5ZXIyJyB8ICdkcmF3JyB8IG51bGwpID0+IHtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHdpbm5lclxuICAgIGNvbnN0IHdpbm5lciA9IHdpbm5lclBhcmFtIHx8IGdhbWVIb29rLmhhbmRsZUdhbWVFbmQoKTtcbiAgICBcbiAgICAvLyBQYXkgdGhlIHdpbm5lciBpZiBlc2Nyb3cgaXMgbG9ja2VkXG4gICAgaWYgKGVzY3Jvd0hvb2suZXNjcm93TG9ja2VkKSB7XG4gICAgICBhd2FpdCBlc2Nyb3dIb29rLnBheVdpbm5lcihcbiAgICAgICAgd2lubmVyLFxuICAgICAgICB3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQsXG4gICAgICAgIHdhbGxldEhvb2sucGxheWVyMldhbGxldCxcbiAgICAgICAgYmV0dGluZ0hvb2sucGxheWVyMUJldCxcbiAgICAgICAgYmV0dGluZ0hvb2sucGxheWVyMkJldCxcbiAgICAgICAgYmV0dGluZ0hvb2suZmluYWxCZXRBbW91bnQsXG4gICAgICAgIHdhbGxldEhvb2suZ2V0QWNjb3VudEJhbGFuY2VcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIElmIHdlJ3JlIGluIHNpbXVsYXRpb24gbW9kZSwgdXBkYXRlIHRoZSBwbGF5ZXIgYmFsYW5jZXMgYWNjb3JkaW5nbHlcbiAgICAgIGlmIChlc2Nyb3dIb29rLnVzZVNpbXVsYXRpb25Nb2RlKSB7XG4gICAgICAgIGlmICh3aW5uZXIgPT09ICdkcmF3Jykge1xuICAgICAgICAgIC8vIFJldHVybiB0aGUgYmV0cyB0byBlYWNoIHBsYXllclxuICAgICAgICAgIGlmICh3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQpIHtcbiAgICAgICAgICAgIHdhbGxldEhvb2sucGxheWVyMVdhbGxldC5iYWxhbmNlICs9IGJldHRpbmdIb29rLnBsYXllcjFCZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICh3YWxsZXRIb29rLnBsYXllcjJXYWxsZXQpIHtcbiAgICAgICAgICAgIHdhbGxldEhvb2sucGxheWVyMldhbGxldC5iYWxhbmNlICs9IGJldHRpbmdIb29rLnBsYXllcjJCZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdpdmUgdGhlIGZ1bGwgcG90IHRvIHRoZSB3aW5uZXJcbiAgICAgICAgICBpZiAod2lubmVyID09PSAncGxheWVyMScgJiYgd2FsbGV0SG9vay5wbGF5ZXIxV2FsbGV0KSB7XG4gICAgICAgICAgICB3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQuYmFsYW5jZSArPSBiZXR0aW5nSG9vay5maW5hbEJldEFtb3VudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpbm5lciA9PT0gJ3BsYXllcjInICYmIHdhbGxldEhvb2sucGxheWVyMldhbGxldCkge1xuICAgICAgICAgICAgd2FsbGV0SG9vay5wbGF5ZXIyV2FsbGV0LmJhbGFuY2UgKz0gYmV0dGluZ0hvb2suZmluYWxCZXRBbW91bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IHRoZSBnYW1lIHN0YXRlIGFmdGVyIGEgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc2V0QWxsU3RhdGUoKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcblxuICAvLyBSZXNldCBhbGwgc3RhdGVcbiAgY29uc3QgcmVzZXRBbGxTdGF0ZSA9ICgpID0+IHtcbiAgICBnYW1lSG9vay5yZXNldEdhbWVTdGF0ZSgpO1xuICAgIGJldHRpbmdIb29rLnJlc2V0QmV0dGluZ1N0YXRlKCk7XG4gICAgZXNjcm93SG9vay5yZXNldEVzY3Jvd1N0YXRlKCk7XG4gIH07XG5cbiAgLy8gU3RhcnQgYSBuZXcgZ2FtZVxuICBjb25zdCBoYW5kbGVTdGFydE5ld0dhbWUgPSAoKSA9PiB7XG4gICAgZ2FtZUhvb2suc3RhcnROZXdHYW1lKCk7XG4gICAgYmV0dGluZ0hvb2sucmVzZXRCZXR0aW5nU3RhdGUoKTtcbiAgICBlc2Nyb3dIb29rLnJlc2V0RXNjcm93U3RhdGUoKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIGVzY3JvdyBjb250cmFjdFxuICBjb25zdCBoYW5kbGVJbml0aWFsaXplRXNjcm93ID0gKCkgPT4ge1xuICAgIGVzY3Jvd0hvb2suaW5pdGlhbGl6ZUVzY3Jvdyh3YWxsZXRIb29rLnBsYXllcjFXYWxsZXQsIHdhbGxldEhvb2sucGxheWVyMldhbGxldCk7XG4gIH07XG5cbiAgLy8gU2hvdyBlcnJvciBwYW5lbCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gIGNvbnN0IGVycm9yID0gd2FsbGV0SG9vay5lcnJvciB8fCBlc2Nyb3dIb29rLmVycm9yIHx8IGJldHRpbmdIb29rLmVycm9yO1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgbXgtYXV0byBweC00IHB5LThcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTYgYmctcmVkLTUwIGJvcmRlciBib3JkZXItcmVkLTIwMCByb3VuZGVkLWxnIG1heC13LWxnIG14LWF1dG9cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGQgdGV4dC1yZWQtODAwIG1iLTJcIj5FcnJvcjwvaDI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtNjAwIG1iLTRcIj57ZXJyb3J9PC9wPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtM1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhbGxldEhvb2suc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICAgICAgZXNjcm93SG9vay5zZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgICAgICBiZXR0aW5nSG9vay5zZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLXJlZC02MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLXJlZC03MDBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBEaXNtaXNzXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3dhbGxldEhvb2sucmVzZXRXYWxsZXRDb25uZWN0aW9uc31cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWdyYXktNjAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTcwMFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFJlc2V0IFdhbGxldCBDb25uZWN0aW9uc1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIFNob3cgbG9hZGluZyBzdGF0ZVxuICBjb25zdCBpc0xvYWRpbmcgPSB3YWxsZXRIb29rLmlzTG9hZGluZyB8fCBlc2Nyb3dIb29rLmlzTG9hZGluZyB8fCBiZXR0aW5nSG9vay5pc0xvYWRpbmc7XG4gIGlmIChpc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gPExvYWRpbmdDb21wb25lbnQgLz47XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG14LWF1dG8gcHgtNCBweS04XCI+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPkNoZXNzIEdhbWUgd2l0aCBBcHRvczwvdGl0bGU+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJQbGF5IGNoZXNzIHdpdGggQXB0b3MgYmxvY2tjaGFpbiBpbnRlZ3JhdGlvblwiIC8+XG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cblxuICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCB0ZXh0LWNlbnRlciBtYi04XCI+Q2hlc3MgR2FtZSB3aXRoIEFwdG9zPC9oMT5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0zIGdhcC02XCI+XG4gICAgICAgIHsvKiBMZWZ0IHBhbmVsIC0gUGxheWVyIDEgKi99XG4gICAgICAgIDxQbGF5ZXJQYW5lbCBcbiAgICAgICAgICBwbGF5ZXJOdW1iZXI9ezF9XG4gICAgICAgICAgcGxheWVyV2FsbGV0PXt3YWxsZXRIb29rLnBsYXllcjFXYWxsZXR9XG4gICAgICAgICAgcGxheWVyQmV0PXtiZXR0aW5nSG9vay5wbGF5ZXIxQmV0fVxuICAgICAgICAgIHBsYXllckVzY3Jvd0xvY2tlZD17ZXNjcm93SG9vay5wbGF5ZXIxRXNjcm93TG9ja2VkfVxuICAgICAgICAgIG90aGVyUGxheWVyQmV0PXtiZXR0aW5nSG9vay5wbGF5ZXIyQmV0fVxuICAgICAgICAgIGdhbWVTdGF0ZT17Z2FtZUhvb2suZ2FtZVN0YXRlfVxuICAgICAgICAgIHVzZVNpbXVsYXRpb25Nb2RlPXtlc2Nyb3dIb29rLnVzZVNpbXVsYXRpb25Nb2RlfVxuICAgICAgICAgIG9uQ29ubmVjdFdhbGxldD17d2FsbGV0SG9vay5jb25uZWN0UGxheWVyV2FsbGV0fVxuICAgICAgICAgIG9uRGlzY29ubmVjdFdhbGxldD17d2FsbGV0SG9vay5kaXNjb25uZWN0V2FsbGV0fVxuICAgICAgICAgIG9uU2V0TWFudWFsV2FsbGV0QWRkcmVzcz17d2FsbGV0SG9vay5zZXRNYW51YWxXYWxsZXRBZGRyZXNzfVxuICAgICAgICAgIG9uTG9ja0VzY3Jvdz17KCkgPT4gaGFuZGxlTG9ja0VzY3JvdygxKX1cbiAgICAgICAgLz5cbiAgICAgICAgICBcbiAgICAgICAgey8qIE1pZGRsZSBwYW5lbCAtIEdhbWUgKi99XG4gICAgICAgIDxDaGVzc0dhbWVQYW5lbFxuICAgICAgICAgIGdhbWU9e2dhbWVIb29rLmdhbWV9XG4gICAgICAgICAgZ2FtZVN0YXRlPXtnYW1lSG9vay5nYW1lU3RhdGV9XG4gICAgICAgICAgY3VycmVudFBsYXllcj17Z2FtZUhvb2suY3VycmVudFBsYXllcn1cbiAgICAgICAgICB3aW5uZXI9e2dhbWVIb29rLndpbm5lcn1cbiAgICAgICAgICBmaW5hbEJldEFtb3VudD17YmV0dGluZ0hvb2suZmluYWxCZXRBbW91bnR9XG4gICAgICAgICAgcGxheWVyMVdhbGxldD17d2FsbGV0SG9vay5wbGF5ZXIxV2FsbGV0fVxuICAgICAgICAgIHBsYXllcjJXYWxsZXQ9e3dhbGxldEhvb2sucGxheWVyMldhbGxldH1cbiAgICAgICAgICBwbGF5ZXIxQmV0PXtiZXR0aW5nSG9vay5wbGF5ZXIxQmV0fVxuICAgICAgICAgIHBsYXllcjJCZXQ9e2JldHRpbmdIb29rLnBsYXllcjJCZXR9XG4gICAgICAgICAgb25Ecm9wPXtnYW1lSG9vay5vbkRyb3B9XG4gICAgICAgICAgb25Bbm5vdW5jZVVuaWZpZWRCZXQ9e2hhbmRsZUFubm91bmNlVW5pZmllZEJldH1cbiAgICAgICAgICBvblN0YXJ0TmV3R2FtZT17aGFuZGxlU3RhcnROZXdHYW1lfVxuICAgICAgICAgIG9uRm9yZmVpdD17aGFuZGxlRm9yZmVpdH1cbiAgICAgICAgICBvblBsYXllcjFCZXRDaGFuZ2U9e2JldHRpbmdIb29rLnNldFBsYXllcjFCZXR9XG4gICAgICAgICAgb25QbGF5ZXIyQmV0Q2hhbmdlPXtiZXR0aW5nSG9vay5zZXRQbGF5ZXIyQmV0fVxuICAgICAgICAvPlxuICAgICAgICAgIFxuICAgICAgICB7LyogUmlnaHQgcGFuZWwgLSBQbGF5ZXIgMiAqL31cbiAgICAgICAgPFBsYXllclBhbmVsIFxuICAgICAgICAgIHBsYXllck51bWJlcj17Mn1cbiAgICAgICAgICBwbGF5ZXJXYWxsZXQ9e3dhbGxldEhvb2sucGxheWVyMldhbGxldH1cbiAgICAgICAgICBwbGF5ZXJCZXQ9e2JldHRpbmdIb29rLnBsYXllcjJCZXR9XG4gICAgICAgICAgcGxheWVyRXNjcm93TG9ja2VkPXtlc2Nyb3dIb29rLnBsYXllcjJFc2Nyb3dMb2NrZWR9XG4gICAgICAgICAgb3RoZXJQbGF5ZXJCZXQ9e2JldHRpbmdIb29rLnBsYXllcjFCZXR9XG4gICAgICAgICAgZ2FtZVN0YXRlPXtnYW1lSG9vay5nYW1lU3RhdGV9XG4gICAgICAgICAgdXNlU2ltdWxhdGlvbk1vZGU9e2VzY3Jvd0hvb2sudXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgICAgb25Db25uZWN0V2FsbGV0PXsoKSA9PiB3YWxsZXRIb29rLmNvbm5lY3RQbGF5ZXIyV2FsbGV0KCl9XG4gICAgICAgICAgb25EaXNjb25uZWN0V2FsbGV0PXt3YWxsZXRIb29rLmRpc2Nvbm5lY3RXYWxsZXR9XG4gICAgICAgICAgb25TZXRNYW51YWxXYWxsZXRBZGRyZXNzPXt3YWxsZXRIb29rLnNldE1hbnVhbFdhbGxldEFkZHJlc3N9XG4gICAgICAgICAgb25Mb2NrRXNjcm93PXsoKSA9PiBoYW5kbGVMb2NrRXNjcm93KDIpfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBDb250cmFjdCBzdGF0dXMgcGFuZWwgKi99XG4gICAgICA8RXNjcm93UGFuZWwgXG4gICAgICAgIGVzY3Jvd0FkZHJlc3M9e2VzY3Jvd0hvb2suZXNjcm93QWRkcmVzc31cbiAgICAgICAgZXNjcm93U3RhdHVzPXtlc2Nyb3dIb29rLmVzY3Jvd1N0YXR1c31cbiAgICAgICAgZXNjcm93QmFsYW5jZT17ZXNjcm93SG9vay5lc2Nyb3dCYWxhbmNlfVxuICAgICAgICB1c2VTaW11bGF0aW9uTW9kZT17ZXNjcm93SG9vay51c2VTaW11bGF0aW9uTW9kZX1cbiAgICAgICAgc2V0VXNlU2ltdWxhdGlvbk1vZGU9e2VzY3Jvd0hvb2suc2V0VXNlU2ltdWxhdGlvbk1vZGV9XG4gICAgICAgIG9uQ29ubmVjdEVzY3Jvd1dhbGxldD17ZXNjcm93SG9vay5jb25uZWN0RXNjcm93V2FsbGV0fVxuICAgICAgICBvbkRpc2Nvbm5lY3RFc2Nyb3c9eygpID0+IGVzY3Jvd0hvb2suc2V0RXNjcm93QWRkcmVzcyhudWxsKX1cbiAgICAgICAgb25DcmVhdGVTaW11bGF0ZWRFc2Nyb3c9e2VzY3Jvd0hvb2suY3JlYXRlU2ltdWxhdGVkRXNjcm93fVxuICAgICAgICBvbkluaXRpYWxpemVFc2Nyb3c9e2hhbmRsZUluaXRpYWxpemVFc2Nyb3d9XG4gICAgICAgIG9uUmVzZXRHYW1lPXtyZXNldEFsbFN0YXRlfVxuICAgICAgICBvblJlc2V0V2FsbGV0cz17d2FsbGV0SG9vay5yZXNldFdhbGxldENvbm5lY3Rpb25zfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIkhlYWQiLCJ1c2VXYWxsZXQiLCJMb2FkaW5nQ29tcG9uZW50IiwiUGxheWVyUGFuZWwiLCJDaGVzc0dhbWVQYW5lbCIsIkVzY3Jvd1BhbmVsIiwidHJhbnNmZXJUb0VzY3JvdyIsInVzZVdhbGxldENvbm5lY3Rpb24iLCJ1c2VFc2Nyb3ciLCJ1c2VDaGVzc0dhbWUiLCJ1c2VCZXR0aW5nIiwiSG9tZSIsInNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbiIsImRpc2Nvbm5lY3QiLCJjb25uZWN0ZWQiLCJhY2NvdW50Iiwid2FsbGV0SG9vayIsImVzY3Jvd0hvb2siLCJnYW1lSG9vayIsImJldHRpbmdIb29rIiwicGxheWVyMVdhbGxldCIsInBsYXllcjJXYWxsZXQiLCJlc2Nyb3dBZGRyZXNzIiwiaXNMb2FkaW5nIiwiY29uc29sZSIsImxvZyIsInVzZVNpbXVsYXRpb25Nb2RlIiwiY3JlYXRlU2ltdWxhdGVkRXNjcm93IiwicGxheWVyMUVzY3Jvd0xvY2tlZCIsInBsYXllcjJFc2Nyb3dMb2NrZWQiLCJnYW1lU3RhdGUiLCJtaW5CZXRBbW91bnQiLCJNYXRoIiwibWluIiwicGxheWVyMUJldCIsInBsYXllcjJCZXQiLCJzZXRGaW5hbEJldEFtb3VudCIsInNldEVzY3Jvd0xvY2tlZCIsInNldEdhbWVTdGF0ZSIsImhhbmRsZUxvY2tFc2Nyb3ciLCJwbGF5ZXJOdW1iZXIiLCJyZXN1bHQiLCJsb2NrRXNjcm93IiwiZW5zdXJlQ29ycmVjdFdhbGxldENvbm5lY3RlZCIsImdldEFjY291bnRCYWxhbmNlIiwiYW1vdW50IiwidGFyZ2V0QWRkcmVzcyIsIndhc0xvY2tlZCIsIm1pbmltdW1CZXQiLCJiYWxhbmNlIiwiaGFuZGxlQW5ub3VuY2VVbmlmaWVkQmV0IiwiYW5ub3VuY2VVbmlmaWVkQmV0IiwiaGFuZGxlRm9yZmVpdCIsImN1cnJlbnRQbGF5ZXJOdW1iZXIiLCJjdXJyZW50UGxheWVyIiwid2lubmVyIiwiZm9yZmVpdEdhbWUiLCJoYW5kbGVHYW1lRW5kIiwid2lubmVyUGFyYW0iLCJlc2Nyb3dMb2NrZWQiLCJwYXlXaW5uZXIiLCJmaW5hbEJldEFtb3VudCIsInNldFRpbWVvdXQiLCJyZXNldEFsbFN0YXRlIiwicmVzZXRHYW1lU3RhdGUiLCJyZXNldEJldHRpbmdTdGF0ZSIsInJlc2V0RXNjcm93U3RhdGUiLCJoYW5kbGVTdGFydE5ld0dhbWUiLCJzdGFydE5ld0dhbWUiLCJoYW5kbGVJbml0aWFsaXplRXNjcm93IiwiaW5pdGlhbGl6ZUVzY3JvdyIsImVycm9yIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJwIiwiYnV0dG9uIiwib25DbGljayIsInNldEVycm9yIiwicmVzZXRXYWxsZXRDb25uZWN0aW9ucyIsInRpdGxlIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwibGluayIsInJlbCIsImhyZWYiLCJoMSIsInBsYXllcldhbGxldCIsInBsYXllckJldCIsInBsYXllckVzY3Jvd0xvY2tlZCIsIm90aGVyUGxheWVyQmV0Iiwib25Db25uZWN0V2FsbGV0IiwiY29ubmVjdFBsYXllcldhbGxldCIsIm9uRGlzY29ubmVjdFdhbGxldCIsImRpc2Nvbm5lY3RXYWxsZXQiLCJvblNldE1hbnVhbFdhbGxldEFkZHJlc3MiLCJzZXRNYW51YWxXYWxsZXRBZGRyZXNzIiwib25Mb2NrRXNjcm93IiwiZ2FtZSIsIm9uRHJvcCIsIm9uQW5ub3VuY2VVbmlmaWVkQmV0Iiwib25TdGFydE5ld0dhbWUiLCJvbkZvcmZlaXQiLCJvblBsYXllcjFCZXRDaGFuZ2UiLCJzZXRQbGF5ZXIxQmV0Iiwib25QbGF5ZXIyQmV0Q2hhbmdlIiwic2V0UGxheWVyMkJldCIsImNvbm5lY3RQbGF5ZXIyV2FsbGV0IiwiZXNjcm93U3RhdHVzIiwiZXNjcm93QmFsYW5jZSIsInNldFVzZVNpbXVsYXRpb25Nb2RlIiwib25Db25uZWN0RXNjcm93V2FsbGV0IiwiY29ubmVjdEVzY3Jvd1dhbGxldCIsIm9uRGlzY29ubmVjdEVzY3JvdyIsInNldEVzY3Jvd0FkZHJlc3MiLCJvbkNyZWF0ZVNpbXVsYXRlZEVzY3JvdyIsIm9uSW5pdGlhbGl6ZUVzY3JvdyIsIm9uUmVzZXRHYW1lIiwib25SZXNldFdhbGxldHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ })

});